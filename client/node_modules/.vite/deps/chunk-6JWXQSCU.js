import {
  getInjectedMetamaskProvider
} from "./chunk-XBH54BOD.js";
import {
  getInjectedPhantomProvider
} from "./chunk-R5U57HIL.js";
import {
  getInjectedRainbowProvider
} from "./chunk-BFYOF2QD.js";
import {
  ERC6551_REGISTRY
} from "./chunk-PMPHILAH.js";
import {
  ThirdwebSDK
} from "./chunk-SRFLFQ4O.js";
import {
  getInjectedOKXProvider
} from "./chunk-YS4BYOTJ.js";
import {
  $t2 as $t,
  D2 as D,
  IEvents,
  JsonRpcProvider,
  N,
  Qt,
  RELAY_JSONRPC,
  V,
  Vn,
  _,
  detect,
  encodeIss,
  esm_default,
  esm_exports,
  formatJsonRpcError,
  formatJsonRpcRequest,
  formatJsonRpcResult,
  generateKeyPair,
  getBigIntRpcId,
  h,
  init_esm,
  isJsonRpcError,
  isJsonRpcRequest,
  isJsonRpcResponse,
  isJsonRpcResult,
  jt,
  payloadId,
  q,
  require_chacha20poly1305,
  require_cjs,
  require_cjs2,
  require_cjs3,
  require_cjs4,
  require_cjs5,
  require_hkdf,
  require_lodash,
  require_query_string,
  require_random,
  require_sha256,
  require_x25519,
  safeJsonParse,
  safeJsonStringify,
  signJWT,
  zr
} from "./chunk-SU72FDED.js";
import {
  require_events
} from "./chunk-UR4CD6SH.js";
import {
  getInjectedCoreWalletProvider
} from "./chunk-6IYXXNBD.js";
import {
  WagmiAdapter
} from "./chunk-6FDWOVUB.js";
import {
  _classPrivateMethodGet,
  _classPrivateMethodInitSpec
} from "./chunk-ZXQ5YOFG.js";
import {
  walletIds
} from "./chunk-QSI6K2SV.js";
import {
  assertWindowEthereum
} from "./chunk-BL3IWORX.js";
import {
  _classPrivateFieldGet,
  _classPrivateFieldInitSpec,
  _classPrivateFieldSet
} from "./chunk-64WJJLDE.js";
import {
  _defineProperty
} from "./chunk-6OBQOEDS.js";
import {
  normalizePriceValue
} from "./chunk-HP5C2NQN.js";
import {
  fetchCurrencyValue,
  isNativeToken
} from "./chunk-UEMNZHIS.js";
import {
  NATIVE_TOKEN_ADDRESS,
  getChainProvider,
  isContractDeployed
} from "./chunk-3RUZ5SWH.js";
import {
  require_utils
} from "./chunk-BV4CII2J.js";
import {
  concat,
  fromString,
  toString
} from "./chunk-457LSDR5.js";
import {
  eventemitter3_default
} from "./chunk-I4TCAHS5.js";
import {
  Contract,
  Wallet,
  ethers_exports,
  init_lib7 as init_lib3,
  utils_exports
} from "./chunk-FA7CNXA4.js";
import {
  hashMessage,
  init_lib11 as init_lib,
  init_lib15 as init_lib2,
  lib_exports19 as lib_exports,
  recoverAddress
} from "./chunk-7GXO2BXT.js";
import {
  c1,
  defaultChains,
  getValidChainRPCs,
  updateChainRPCs
} from "./chunk-SMUNBUKY.js";
import {
  _global,
  import_process,
  init_shim,
  require_buffer
} from "./chunk-6SWLQQ3Q.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-GN3OLCG2.js";

// node_modules/unfetch/dist/unfetch.module.js
var unfetch_module_exports = {};
__export(unfetch_module_exports, {
  default: () => unfetch_module_default
});
function unfetch_module_default(e, n2) {
  return n2 = n2 || {}, new Promise(function(t, r) {
    var s = new XMLHttpRequest(), o2 = [], u3 = [], i2 = {}, a2 = function() {
      return { ok: 2 == (s.status / 100 | 0), statusText: s.statusText, status: s.status, url: s.responseURL, text: function() {
        return Promise.resolve(s.responseText);
      }, json: function() {
        return Promise.resolve(s.responseText).then(JSON.parse);
      }, blob: function() {
        return Promise.resolve(new Blob([s.response]));
      }, clone: a2, headers: { keys: function() {
        return o2;
      }, entries: function() {
        return u3;
      }, get: function(e2) {
        return i2[e2.toLowerCase()];
      }, has: function(e2) {
        return e2.toLowerCase() in i2;
      } } };
    };
    for (var l2 in s.open(n2.method || "get", e, true), s.onload = function() {
      s.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function(e2, n3, t2) {
        o2.push(n3 = n3.toLowerCase()), u3.push([n3, t2]), i2[n3] = i2[n3] ? i2[n3] + "," + t2 : t2;
      }), t(a2());
    }, s.onerror = r, s.withCredentials = "include" == n2.credentials, n2.headers)
      s.setRequestHeader(l2, n2.headers[l2]);
    s.send(n2.body || null);
  });
}
var init_unfetch_module = __esm({
  "node_modules/unfetch/dist/unfetch.module.js"() {
    init_shim();
  }
});

// node_modules/isomorphic-unfetch/browser.js
var require_browser = __commonJS({
  "node_modules/isomorphic-unfetch/browser.js"(exports, module) {
    init_shim();
    module.exports = self.fetch || (self.fetch = (init_unfetch_module(), __toCommonJS(unfetch_module_exports)).default || (init_unfetch_module(), __toCommonJS(unfetch_module_exports)));
  }
});

// node_modules/@thirdweb-dev/wallets/dist/thirdweb-dev-wallets.browser.esm.js
init_shim();

// node_modules/@walletconnect/web3wallet/dist/index.es.js
init_shim();

// node_modules/@walletconnect/auth-client/dist/index.es.js
init_shim();
var import_logger = __toESM(require_cjs3());
var import_events = __toESM(require_events());
var import_time = __toESM(require_cjs());
init_lib();
init_lib2();
var import_isomorphic_unfetch = __toESM(require_browser());
var import_random = __toESM(require_random());
var import_sha256 = __toESM(require_sha256());
var G = class {
  constructor(t) {
    this.client = t;
  }
};
var H = class {
  constructor(t) {
    this.opts = t;
  }
};
var Y = "https://rpc.walletconnect.com/v1";
var R = { wc_authRequest: { req: { ttl: import_time.ONE_DAY, prompt: true, tag: 3e3 }, res: { ttl: import_time.ONE_DAY, prompt: false, tag: 3001 } } };
var U = { min: import_time.FIVE_MINUTES, max: import_time.SEVEN_DAYS };
var $ = "wc";
var Q = 1;
var Z = "auth";
var B = "authClient";
var F = `${$}@${1}:${Z}:`;
var x = `${F}:PUB_KEY`;
function z(r) {
  return r == null ? void 0 : r.split(":");
}
function Ze(r) {
  const t = r && z(r);
  if (t)
    return t[3];
}
function We(r) {
  const t = r && z(r);
  if (t)
    return t[2] + ":" + t[3];
}
function W(r) {
  const t = r && z(r);
  if (t)
    return t.pop();
}
async function et(r, t, e, i2, n2) {
  switch (e.t) {
    case "eip191":
      return tt(r, t, e.s);
    case "eip1271":
      return await rt(r, t, e.s, i2, n2);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${e.t}`);
  }
}
function tt(r, t, e) {
  return recoverAddress(hashMessage(t), e).toLowerCase() === r.toLowerCase();
}
async function rt(r, t, e, i2, n2) {
  try {
    const s = "0x1626ba7e", o2 = "0000000000000000000000000000000000000000000000000000000000000040", u3 = "0000000000000000000000000000000000000000000000000000000000000041", a2 = e.substring(2), c2 = hashMessage(t).substring(2), h4 = s + c2 + o2 + u3 + a2, f3 = await (0, import_isomorphic_unfetch.default)(`${Y}/?chainId=${i2}&projectId=${n2}`, { method: "POST", body: JSON.stringify({ id: it(), jsonrpc: "2.0", method: "eth_call", params: [{ to: r, data: h4 }, "latest"] }) }), { result: p4 } = await f3.json();
    return p4 ? p4.slice(0, s.length).toLowerCase() === s.toLowerCase() : false;
  } catch (s) {
    return console.error("isValidEip1271Signature: ", s), false;
  }
}
function it() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
function ee(r) {
  return r.getAll().filter((t) => "requester" in t);
}
function te(r, t) {
  return ee(r).find((e) => e.id === t);
}
function nt(r) {
  const t = jt(r.aud), e = new RegExp(`${r.domain}`).test(r.aud), i2 = !!r.nonce, n2 = r.type ? r.type === "eip4361" : true, s = r.expiry;
  if (s && !Qt(s, U)) {
    const { message: o2 } = N("MISSING_OR_INVALID", `request() expiry: ${s}. Expiry must be a number (in seconds) between ${U.min} and ${U.max}`);
    throw new Error(o2);
  }
  return !!(t && e && i2 && n2);
}
function st(r, t) {
  return !!te(t, r.id);
}
function ot(r = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(r) : new Uint8Array(r);
}
function ut(r, t) {
  if (r.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var e = new Uint8Array(256), i2 = 0; i2 < e.length; i2++)
    e[i2] = 255;
  for (var n2 = 0; n2 < r.length; n2++) {
    var s = r.charAt(n2), o2 = s.charCodeAt(0);
    if (e[o2] !== 255)
      throw new TypeError(s + " is ambiguous");
    e[o2] = n2;
  }
  var u3 = r.length, a2 = r.charAt(0), c2 = Math.log(u3) / Math.log(256), h4 = Math.log(256) / Math.log(u3);
  function f3(D5) {
    if (D5 instanceof Uint8Array || (ArrayBuffer.isView(D5) ? D5 = new Uint8Array(D5.buffer, D5.byteOffset, D5.byteLength) : Array.isArray(D5) && (D5 = Uint8Array.from(D5))), !(D5 instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (D5.length === 0)
      return "";
    for (var l2 = 0, m3 = 0, E4 = 0, y4 = D5.length; E4 !== y4 && D5[E4] === 0; )
      E4++, l2++;
    for (var w4 = (y4 - E4) * h4 + 1 >>> 0, g5 = new Uint8Array(w4); E4 !== y4; ) {
      for (var C2 = D5[E4], _4 = 0, b4 = w4 - 1; (C2 !== 0 || _4 < m3) && b4 !== -1; b4--, _4++)
        C2 += 256 * g5[b4] >>> 0, g5[b4] = C2 % u3 >>> 0, C2 = C2 / u3 >>> 0;
      if (C2 !== 0)
        throw new Error("Non-zero carry");
      m3 = _4, E4++;
    }
    for (var v2 = w4 - m3; v2 !== w4 && g5[v2] === 0; )
      v2++;
    for (var q4 = a2.repeat(l2); v2 < w4; ++v2)
      q4 += r.charAt(g5[v2]);
    return q4;
  }
  function p4(D5) {
    if (typeof D5 != "string")
      throw new TypeError("Expected String");
    if (D5.length === 0)
      return new Uint8Array();
    var l2 = 0;
    if (D5[l2] !== " ") {
      for (var m3 = 0, E4 = 0; D5[l2] === a2; )
        m3++, l2++;
      for (var y4 = (D5.length - l2) * c2 + 1 >>> 0, w4 = new Uint8Array(y4); D5[l2]; ) {
        var g5 = e[D5.charCodeAt(l2)];
        if (g5 === 255)
          return;
        for (var C2 = 0, _4 = y4 - 1; (g5 !== 0 || C2 < E4) && _4 !== -1; _4--, C2++)
          g5 += u3 * w4[_4] >>> 0, w4[_4] = g5 % 256 >>> 0, g5 = g5 / 256 >>> 0;
        if (g5 !== 0)
          throw new Error("Non-zero carry");
        E4 = C2, l2++;
      }
      if (D5[l2] !== " ") {
        for (var b4 = y4 - E4; b4 !== y4 && w4[b4] === 0; )
          b4++;
        for (var v2 = new Uint8Array(m3 + (y4 - b4)), q4 = m3; b4 !== y4; )
          v2[q4++] = w4[b4++];
        return v2;
      }
    }
  }
  function A3(D5) {
    var l2 = p4(D5);
    if (l2)
      return l2;
    throw new Error(`Non-${t} character`);
  }
  return { encode: f3, decodeUnsafe: p4, decode: A3 };
}
var at = ut;
var Dt = at;
var re = (r) => {
  if (r instanceof Uint8Array && r.constructor.name === "Uint8Array")
    return r;
  if (r instanceof ArrayBuffer)
    return new Uint8Array(r);
  if (ArrayBuffer.isView(r))
    return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var ct = (r) => new TextEncoder().encode(r);
var ht = (r) => new TextDecoder().decode(r);
var lt = class {
  constructor(t, e, i2) {
    this.name = t, this.prefix = e, this.baseEncode = i2;
  }
  encode(t) {
    if (t instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(t)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var dt = class {
  constructor(t, e, i2) {
    if (this.name = t, this.prefix = e, e.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = e.codePointAt(0), this.baseDecode = i2;
  }
  decode(t) {
    if (typeof t == "string") {
      if (t.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(t.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(t) {
    return ie(this, t);
  }
};
var pt = class {
  constructor(t) {
    this.decoders = t;
  }
  or(t) {
    return ie(this, t);
  }
  decode(t) {
    const e = t[0], i2 = this.decoders[e];
    if (i2)
      return i2.decode(t);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var ie = (r, t) => new pt({ ...r.decoders || { [r.prefix]: r }, ...t.decoders || { [t.prefix]: t } });
var ft = class {
  constructor(t, e, i2, n2) {
    this.name = t, this.prefix = e, this.baseEncode = i2, this.baseDecode = n2, this.encoder = new lt(t, e, i2), this.decoder = new dt(t, e, n2);
  }
  encode(t) {
    return this.encoder.encode(t);
  }
  decode(t) {
    return this.decoder.decode(t);
  }
};
var O = ({ name: r, prefix: t, encode: e, decode: i2 }) => new ft(r, t, e, i2);
var T = ({ prefix: r, name: t, alphabet: e }) => {
  const { encode: i2, decode: n2 } = Dt(e, t);
  return O({ prefix: r, name: t, encode: i2, decode: (s) => re(n2(s)) });
};
var gt = (r, t, e, i2) => {
  const n2 = {};
  for (let h4 = 0; h4 < t.length; ++h4)
    n2[t[h4]] = h4;
  let s = r.length;
  for (; r[s - 1] === "="; )
    --s;
  const o2 = new Uint8Array(s * e / 8 | 0);
  let u3 = 0, a2 = 0, c2 = 0;
  for (let h4 = 0; h4 < s; ++h4) {
    const f3 = n2[r[h4]];
    if (f3 === void 0)
      throw new SyntaxError(`Non-${i2} character`);
    a2 = a2 << e | f3, u3 += e, u3 >= 8 && (u3 -= 8, o2[c2++] = 255 & a2 >> u3);
  }
  if (u3 >= e || 255 & a2 << 8 - u3)
    throw new SyntaxError("Unexpected end of data");
  return o2;
};
var Et = (r, t, e) => {
  const i2 = t[t.length - 1] === "=", n2 = (1 << e) - 1;
  let s = "", o2 = 0, u3 = 0;
  for (let a2 = 0; a2 < r.length; ++a2)
    for (u3 = u3 << 8 | r[a2], o2 += 8; o2 > e; )
      o2 -= e, s += t[n2 & u3 >> o2];
  if (o2 && (s += t[n2 & u3 << e - o2]), i2)
    for (; s.length * e & 7; )
      s += "=";
  return s;
};
var d = ({ name: r, prefix: t, bitsPerChar: e, alphabet: i2 }) => O({ prefix: t, name: r, encode(n2) {
  return Et(n2, i2, e);
}, decode(n2) {
  return gt(n2, i2, e, r);
} });
var bt = O({ prefix: "\0", name: "identity", encode: (r) => ht(r), decode: (r) => ct(r) });
var yt = Object.freeze({ __proto__: null, identity: bt });
var wt = d({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var Ct = Object.freeze({ __proto__: null, base2: wt });
var mt = d({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var vt = Object.freeze({ __proto__: null, base8: mt });
var At = T({ prefix: "9", name: "base10", alphabet: "0123456789" });
var _t = Object.freeze({ __proto__: null, base10: At });
var xt = d({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Rt = d({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Ft = Object.freeze({ __proto__: null, base16: xt, base16upper: Rt });
var Tt = d({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var It = d({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var qt = d({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var Ut = d({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var Ot = d({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var St = d({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var Pt = d({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var Nt = d({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var $t2 = d({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var Bt = Object.freeze({ __proto__: null, base32: Tt, base32upper: It, base32pad: qt, base32padupper: Ut, base32hex: Ot, base32hexupper: St, base32hexpad: Pt, base32hexpadupper: Nt, base32z: $t2 });
var zt = T({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var jt2 = T({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Mt = Object.freeze({ __proto__: null, base36: zt, base36upper: jt2 });
var Lt = T({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Kt = T({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Vt = Object.freeze({ __proto__: null, base58btc: Lt, base58flickr: Kt });
var kt = d({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var Jt = d({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var Xt = d({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var Gt = d({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Ht = Object.freeze({ __proto__: null, base64: kt, base64pad: Jt, base64url: Xt, base64urlpad: Gt });
var ne = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var Yt = ne.reduce((r, t, e) => (r[e] = t, r), []);
var Qt2 = ne.reduce((r, t, e) => (r[t.codePointAt(0)] = e, r), []);
function Zt(r) {
  return r.reduce((t, e) => (t += Yt[e], t), "");
}
function Wt(r) {
  const t = [];
  for (const e of r) {
    const i2 = Qt2[e.codePointAt(0)];
    if (i2 === void 0)
      throw new Error(`Non-base256emoji character: ${e}`);
    t.push(i2);
  }
  return new Uint8Array(t);
}
var er = O({ prefix: "\u{1F680}", name: "base256emoji", encode: Zt, decode: Wt });
var tr = Object.freeze({ __proto__: null, base256emoji: er });
var rr = oe;
var se = 128;
var ir = 127;
var nr = ~ir;
var sr = Math.pow(2, 31);
function oe(r, t, e) {
  t = t || [], e = e || 0;
  for (var i2 = e; r >= sr; )
    t[e++] = r & 255 | se, r /= 128;
  for (; r & nr; )
    t[e++] = r & 255 | se, r >>>= 7;
  return t[e] = r | 0, oe.bytes = e - i2 + 1, t;
}
var or = j;
var ur = 128;
var ue = 127;
function j(r, i2) {
  var e = 0, i2 = i2 || 0, n2 = 0, s = i2, o2, u3 = r.length;
  do {
    if (s >= u3)
      throw j.bytes = 0, new RangeError("Could not decode varint");
    o2 = r[s++], e += n2 < 28 ? (o2 & ue) << n2 : (o2 & ue) * Math.pow(2, n2), n2 += 7;
  } while (o2 >= ur);
  return j.bytes = s - i2, e;
}
var ar = Math.pow(2, 7);
var Dr = Math.pow(2, 14);
var cr = Math.pow(2, 21);
var hr = Math.pow(2, 28);
var lr = Math.pow(2, 35);
var dr = Math.pow(2, 42);
var pr = Math.pow(2, 49);
var fr = Math.pow(2, 56);
var gr = Math.pow(2, 63);
var Er = function(r) {
  return r < ar ? 1 : r < Dr ? 2 : r < cr ? 3 : r < hr ? 4 : r < lr ? 5 : r < dr ? 6 : r < pr ? 7 : r < fr ? 8 : r < gr ? 9 : 10;
};
var br = { encode: rr, decode: or, encodingLength: Er };
var ae = br;
var De = (r, t, e = 0) => (ae.encode(r, t, e), t);
var ce = (r) => ae.encodingLength(r);
var M = (r, t) => {
  const e = t.byteLength, i2 = ce(r), n2 = i2 + ce(e), s = new Uint8Array(n2 + e);
  return De(r, s, 0), De(e, s, i2), s.set(t, n2), new yr(r, e, t, s);
};
var yr = class {
  constructor(t, e, i2, n2) {
    this.code = t, this.size = e, this.digest = i2, this.bytes = n2;
  }
};
var he = ({ name: r, code: t, encode: e }) => new wr(r, t, e);
var wr = class {
  constructor(t, e, i2) {
    this.name = t, this.code = e, this.encode = i2;
  }
  digest(t) {
    if (t instanceof Uint8Array) {
      const e = this.encode(t);
      return e instanceof Uint8Array ? M(this.code, e) : e.then((i2) => M(this.code, i2));
    } else
      throw Error("Unknown type, must be binary type");
  }
};
var le = (r) => async (t) => new Uint8Array(await crypto.subtle.digest(r, t));
var Cr = he({ name: "sha2-256", code: 18, encode: le("SHA-256") });
var mr = he({ name: "sha2-512", code: 19, encode: le("SHA-512") });
var vr = Object.freeze({ __proto__: null, sha256: Cr, sha512: mr });
var de = 0;
var Ar = "identity";
var pe = re;
var _r = (r) => M(de, pe(r));
var xr = { code: de, name: Ar, encode: pe, digest: _r };
var Rr = Object.freeze({ __proto__: null, identity: xr });
new TextEncoder(), new TextDecoder();
var fe = { ...yt, ...Ct, ...vt, ..._t, ...Ft, ...Bt, ...Mt, ...Vt, ...Ht, ...tr };
({ ...vr, ...Rr });
function ge(r, t, e, i2) {
  return { name: r, prefix: t, encoder: { name: r, prefix: t, encode: e }, decoder: { decode: i2 } };
}
var Ee = ge("utf8", "u", (r) => "u" + new TextDecoder("utf8").decode(r), (r) => new TextEncoder().encode(r.substring(1)));
var L = ge("ascii", "a", (r) => {
  let t = "a";
  for (let e = 0; e < r.length; e++)
    t += String.fromCharCode(r[e]);
  return t;
}, (r) => {
  r = r.substring(1);
  const t = ot(r.length);
  for (let e = 0; e < r.length; e++)
    t[e] = r.charCodeAt(e);
  return t;
});
var be = { utf8: Ee, "utf-8": Ee, hex: fe.base16, latin1: L, ascii: L, binary: L, ...fe };
function Fr(r, t = "utf8") {
  const e = be[t];
  if (!e)
    throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r, "utf8") : e.decoder.decode(`${e.prefix}${r}`);
}
function Tr(r, t = "utf8") {
  const e = be[t];
  if (!e)
    throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r.buffer, r.byteOffset, r.byteLength).toString("utf8") : e.encoder.encode(r).substring(1);
}
var ye = "base16";
var we = "utf8";
function K(r) {
  const t = (0, import_sha256.hash)(Fr(r, we));
  return Tr(t, ye);
}
var Or = Object.defineProperty;
var Sr = Object.defineProperties;
var Pr = Object.getOwnPropertyDescriptors;
var Ce = Object.getOwnPropertySymbols;
var Nr = Object.prototype.hasOwnProperty;
var $r = Object.prototype.propertyIsEnumerable;
var me = (r, t, e) => t in r ? Or(r, t, { enumerable: true, configurable: true, writable: true, value: e }) : r[t] = e;
var I = (r, t) => {
  for (var e in t || (t = {}))
    Nr.call(t, e) && me(r, e, t[e]);
  if (Ce)
    for (var e of Ce(t))
      $r.call(t, e) && me(r, e, t[e]);
  return r;
};
var V2 = (r, t) => Sr(r, Pr(t));
var Br = class extends G {
  constructor(t) {
    super(t), this.initialized = false, this.name = "authEngine", this.init = () => {
      this.initialized || (this.registerRelayerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({ methods: Object.keys(R) }), this.initialized = true);
    }, this.request = async (e, i2) => {
      if (this.isInitialized(), !nt(e))
        throw new Error("Invalid request");
      if (i2 != null && i2.topic)
        return await this.requestOnKnownPairing(i2.topic, e);
      const { chainId: n2, statement: s, aud: o2, domain: u3, nonce: a2, type: c2, exp: h4, nbf: f3 } = e, { topic: p4, uri: A3 } = await this.client.core.pairing.create();
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: p4, uri: A3 } });
      const D5 = await this.client.core.crypto.generateKeyPair(), l2 = Vn(D5);
      await this.client.authKeys.set(x, { responseTopic: l2, publicKey: D5 }), await this.client.pairingTopics.set(l2, { topic: l2, pairingTopic: p4 }), await this.client.core.relayer.subscribe(l2), this.client.logger.info(`sending request to new pairing topic: ${p4}`);
      const m3 = await this.sendRequest(p4, "wc_authRequest", { payloadParams: { type: c2 != null ? c2 : "eip4361", chainId: n2, statement: s, aud: o2, domain: u3, version: "1", nonce: a2, iat: new Date().toISOString(), exp: h4, nbf: f3 }, requester: { publicKey: D5, metadata: this.client.metadata } }, {}, e.expiry);
      return this.client.logger.info(`sent request to new pairing topic: ${p4}`), { uri: A3, id: m3 };
    }, this.respond = async (e, i2) => {
      if (this.isInitialized(), !st(e, this.client.requests))
        throw new Error("Invalid response");
      const n2 = te(this.client.requests, e.id);
      if (!n2)
        throw new Error(`Could not find pending auth request with id ${e.id}`);
      const s = n2.requester.publicKey, o2 = await this.client.core.crypto.generateKeyPair(), u3 = Vn(s), a2 = { type: _, receiverPublicKey: s, senderPublicKey: o2 };
      if ("error" in e) {
        await this.sendError(n2.id, u3, e, a2);
        return;
      }
      const c2 = { h: { t: "eip4361" }, p: V2(I({}, n2.cacaoPayload), { iss: i2 }), s: e.signature };
      await this.sendResult(n2.id, u3, c2, a2), await this.client.core.pairing.activate({ topic: n2.pairingTopic }), await this.client.requests.update(n2.id, I({}, c2));
    }, this.getPendingRequests = () => ee(this.client.requests), this.formatMessage = (e, i2) => {
      this.client.logger.debug(`formatMessage, cacao is: ${JSON.stringify(e)}`);
      const n2 = `${e.domain} wants you to sign in with your Ethereum account:`, s = W(i2), o2 = e.statement, u3 = `URI: ${e.aud}`, a2 = `Version: ${e.version}`, c2 = `Chain ID: ${Ze(i2)}`, h4 = `Nonce: ${e.nonce}`, f3 = `Issued At: ${e.iat}`, p4 = e.exp ? `Expiry: ${e.exp}` : void 0, A3 = e.resources && e.resources.length > 0 ? `Resources:
${e.resources.map((D5) => `- ${D5}`).join(`
`)}` : void 0;
      return [n2, s, "", o2, "", u3, a2, c2, h4, f3, p4, A3].filter((D5) => D5 != null).join(`
`);
    }, this.setExpiry = async (e, i2) => {
      this.client.core.pairing.pairings.keys.includes(e) && await this.client.core.pairing.updateExpiry({ topic: e, expiry: i2 }), this.client.core.expirer.set(e, i2);
    }, this.sendRequest = async (e, i2, n2, s, o2) => {
      const u3 = formatJsonRpcRequest(i2, n2), a2 = await this.client.core.crypto.encode(e, u3, s), c2 = R[i2].req;
      if (o2 && (c2.ttl = o2), this.client.core.history.set(e, u3), q()) {
        const h4 = K(JSON.stringify(u3));
        this.client.core.verify.register({ attestationId: h4 });
      }
      return await this.client.core.relayer.publish(e, a2, V2(I({}, c2), { internal: { throwOnFailedPublish: true } })), u3.id;
    }, this.sendResult = async (e, i2, n2, s) => {
      const o2 = formatJsonRpcResult(e, n2), u3 = await this.client.core.crypto.encode(i2, o2, s), a2 = await this.client.core.history.get(i2, e), c2 = R[a2.request.method].res;
      return await this.client.core.relayer.publish(i2, u3, V2(I({}, c2), { internal: { throwOnFailedPublish: true } })), await this.client.core.history.resolve(o2), o2.id;
    }, this.sendError = async (e, i2, n2, s) => {
      const o2 = formatJsonRpcError(e, n2.error), u3 = await this.client.core.crypto.encode(i2, o2, s), a2 = await this.client.core.history.get(i2, e), c2 = R[a2.request.method].res;
      return await this.client.core.relayer.publish(i2, u3, c2), await this.client.core.history.resolve(o2), o2.id;
    }, this.requestOnKnownPairing = async (e, i2) => {
      const n2 = this.client.core.pairing.pairings.getAll({ active: true }).find((A3) => A3.topic === e);
      if (!n2)
        throw new Error(`Could not find pairing for provided topic ${e}`);
      const { publicKey: s } = this.client.authKeys.get(x), { chainId: o2, statement: u3, aud: a2, domain: c2, nonce: h4, type: f3 } = i2, p4 = await this.sendRequest(n2.topic, "wc_authRequest", { payloadParams: { type: f3 != null ? f3 : "eip4361", chainId: o2, statement: u3, aud: a2, domain: c2, version: "1", nonce: h4, iat: new Date().toISOString() }, requester: { publicKey: s, metadata: this.client.metadata } }, {}, i2.expiry);
      return this.client.logger.info(`sent request to known pairing topic: ${n2.topic}`), { id: p4 };
    }, this.onPairingCreated = (e) => {
      const i2 = this.getPendingRequests();
      if (i2) {
        const n2 = Object.values(i2).find((s) => s.pairingTopic === e.topic);
        n2 && this.handleAuthRequest(n2);
      }
    }, this.onRelayEventRequest = (e) => {
      const { topic: i2, payload: n2 } = e, s = n2.method;
      switch (s) {
        case "wc_authRequest":
          return this.onAuthRequest(i2, n2);
        default:
          return this.client.logger.info(`Unsupported request method ${s}`);
      }
    }, this.onRelayEventResponse = async (e) => {
      const { topic: i2, payload: n2 } = e, s = (await this.client.core.history.get(i2, n2.id)).request.method;
      switch (s) {
        case "wc_authRequest":
          return this.onAuthResponse(i2, n2);
        default:
          return this.client.logger.info(`Unsupported response method ${s}`);
      }
    }, this.onAuthRequest = async (e, i2) => {
      const { requester: n2, payloadParams: s } = i2.params;
      this.client.logger.info({ type: "onAuthRequest", topic: e, payload: i2 });
      const o2 = K(JSON.stringify(i2)), u3 = await this.getVerifyContext(o2, this.client.metadata), a2 = { requester: n2, pairingTopic: e, id: i2.id, cacaoPayload: s, verifyContext: u3 };
      await this.client.requests.set(i2.id, a2), this.handleAuthRequest(a2);
    }, this.handleAuthRequest = async (e) => {
      const { id: i2, pairingTopic: n2, requester: s, cacaoPayload: o2, verifyContext: u3 } = e;
      try {
        this.client.emit("auth_request", { id: i2, topic: n2, params: { requester: s, cacaoPayload: o2 }, verifyContext: u3 });
      } catch (a2) {
        await this.sendError(e.id, e.pairingTopic, a2), this.client.logger.error(a2);
      }
    }, this.onAuthResponse = async (e, i2) => {
      const { id: n2 } = i2;
      if (this.client.logger.info({ type: "onAuthResponse", topic: e, response: i2 }), isJsonRpcResult(i2)) {
        const { pairingTopic: s } = this.client.pairingTopics.get(e);
        await this.client.core.pairing.activate({ topic: s });
        const { s: o2, p: u3 } = i2.result;
        await this.client.requests.set(n2, I({ id: n2, pairingTopic: s }, i2.result));
        const a2 = this.formatMessage(u3, u3.iss);
        this.client.logger.debug(`reconstructed message:
`, JSON.stringify(a2)), this.client.logger.debug("payload.iss:", u3.iss), this.client.logger.debug("signature:", o2);
        const c2 = W(u3.iss), h4 = We(u3.iss);
        if (!c2)
          throw new Error("Could not derive address from `payload.iss`");
        if (!h4)
          throw new Error("Could not derive chainId from `payload.iss`");
        this.client.logger.debug("walletAddress extracted from `payload.iss`:", c2), await et(c2, a2, o2, h4, this.client.projectId) ? this.client.emit("auth_response", { id: n2, topic: e, params: i2 }) : this.client.emit("auth_response", { id: n2, topic: e, params: { message: "Invalid signature", code: -1 } });
      } else
        isJsonRpcError(i2) && this.client.emit("auth_response", { id: n2, topic: e, params: i2 });
    }, this.getVerifyContext = async (e, i2) => {
      const n2 = { verified: { verifyUrl: i2.verifyUrl || "", validation: "UNKNOWN", origin: i2.url || "" } };
      try {
        const s = await this.client.core.verify.resolve({ attestationId: e, verifyUrl: i2.verifyUrl });
        s && (n2.verified.origin = s.origin, n2.verified.isScam = s.isScam, n2.verified.validation = origin === new URL(i2.url).origin ? "VALID" : "INVALID");
      } catch (s) {
        this.client.logger.error(s);
      }
      return this.client.logger.info(`Verify context: ${JSON.stringify(n2)}`), n2;
    };
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = N("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(D.message, async (t) => {
      const { topic: e, message: i2 } = t, { responseTopic: n2, publicKey: s } = this.client.authKeys.keys.includes(x) ? this.client.authKeys.get(x) : { responseTopic: void 0, publicKey: void 0 };
      if (n2 && e !== n2) {
        this.client.logger.debug("[Auth] Ignoring message from unknown topic", e);
        return;
      }
      const o2 = await this.client.core.crypto.decode(e, i2, { receiverPublicKey: s });
      isJsonRpcRequest(o2) ? (this.client.core.history.set(e, o2), this.onRelayEventRequest({ topic: e, payload: o2 })) : isJsonRpcResponse(o2) && (await this.client.core.history.resolve(o2), this.onRelayEventResponse({ topic: e, payload: o2 }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(V.create, (t) => this.onPairingCreated(t));
  }
};
var S = class extends H {
  constructor(t) {
    super(t), this.protocol = $, this.version = Q, this.name = B, this.events = new import_events.EventEmitter(), this.emit = (i2, n2) => this.events.emit(i2, n2), this.on = (i2, n2) => this.events.on(i2, n2), this.once = (i2, n2) => this.events.once(i2, n2), this.off = (i2, n2) => this.events.off(i2, n2), this.removeListener = (i2, n2) => this.events.removeListener(i2, n2), this.request = async (i2, n2) => {
      try {
        return await this.engine.request(i2, n2);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.respond = async (i2, n2) => {
      try {
        return await this.engine.respond(i2, n2);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.getPendingRequests = () => {
      try {
        return this.engine.getPendingRequests();
      } catch (i2) {
        throw this.logger.error(i2.message), i2;
      }
    }, this.formatMessage = (i2, n2) => {
      try {
        return this.engine.formatMessage(i2, n2);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    };
    const e = typeof t.logger < "u" && typeof t.logger != "string" ? t.logger : (0, import_logger.pino)((0, import_logger.getDefaultLoggerOptions)({ level: t.logger || "error" }));
    this.name = (t == null ? void 0 : t.name) || B, this.metadata = t.metadata, this.projectId = t.projectId, this.core = t.core || new zr(t), this.logger = (0, import_logger.generateChildLogger)(e, this.name), this.authKeys = new $t(this.core, this.logger, "authKeys", F, () => x), this.pairingTopics = new $t(this.core, this.logger, "pairingTopics", F), this.requests = new $t(this.core, this.logger, "requests", F, (i2) => i2.id), this.engine = new Br(this);
  }
  static async init(t) {
    const e = new S(t);
    return await e.initialize(), e;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.authKeys.init(), await this.requests.init(), await this.pairingTopics.init(), await this.engine.init(), this.logger.info("AuthClient Initialization Success"), this.logger.info({ authClient: this });
    } catch (t) {
      throw this.logger.info("AuthClient Initialization Failure"), this.logger.error(t.message), t;
    }
  }
};
var zr2 = S;

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/sign-client/dist/index.es.js
init_shim();

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/core/dist/index.es.js
init_shim();
var import_events4 = __toESM(require_events());
var import_heartbeat = __toESM(require_cjs2());
var import_logger2 = __toESM(require_cjs3());

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/types/dist/index.es.js
init_shim();
init_esm();
var import_events3 = __toESM(require_events());
var n = class extends IEvents {
  constructor(s) {
    super(), this.opts = s, this.protocol = "wc", this.version = 2;
  }
};
var h2 = class extends IEvents {
  constructor(s, t) {
    super(), this.core = s, this.logger = t, this.records = /* @__PURE__ */ new Map();
  }
};
var a = class {
  constructor(s, t) {
    this.logger = s, this.core = t;
  }
};
var u = class extends IEvents {
  constructor(s, t) {
    super(), this.relayer = s, this.logger = t;
  }
};
var g = class extends IEvents {
  constructor(s) {
    super();
  }
};
var p = class {
  constructor(s, t, o2, w4) {
    this.core = s, this.logger = t, this.name = o2;
  }
};
var d2 = class extends IEvents {
  constructor(s, t) {
    super(), this.relayer = s, this.logger = t;
  }
};
var E = class extends IEvents {
  constructor(s, t) {
    super(), this.core = s, this.logger = t;
  }
};
var y = class {
  constructor(s, t) {
    this.projectId = s, this.logger = t;
  }
};
var b = class {
  constructor(s) {
    this.opts = s, this.protocol = "wc", this.version = 2;
  }
};
var S2 = class {
  constructor(s) {
    this.client = s;
  }
};

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/utils/dist/index.es.js
init_shim();
var import_chacha20poly1305 = __toESM(require_chacha20poly1305());
var import_hkdf = __toESM(require_hkdf());
var import_random2 = __toESM(require_random());
var import_sha2562 = __toESM(require_sha256());
var fe2 = __toESM(require_x25519());
var import_time2 = __toESM(require_cjs());
var import_window_getters = __toESM(require_cjs4());
var import_window_metadata = __toESM(require_cjs5());
var V3 = __toESM(require_query_string());
function K2(e, n2) {
  return e.includes(":") ? [e] : n2.chains || [];
}
var J = "base10";
var p2 = "base16";
var x2 = "base64pad";
var F2 = "utf8";
var Q2 = 0;
var _2 = 1;
var $n = 0;
var Ie2 = 1;
var Z2 = 12;
var X = 32;
function jn() {
  const e = fe2.generateKeyPair();
  return { privateKey: toString(e.secretKey, p2), publicKey: toString(e.publicKey, p2) };
}
function Dn() {
  const e = (0, import_random2.randomBytes)(X);
  return toString(e, p2);
}
function kn(e, n2) {
  const t = fe2.sharedKey(fromString(e, p2), fromString(n2, p2), true), r = new import_hkdf.HKDF(import_sha2562.SHA256, t).expand(X);
  return toString(r, p2);
}
function Vn2(e) {
  const n2 = (0, import_sha2562.hash)(fromString(e, p2));
  return toString(n2, p2);
}
function Mn(e) {
  const n2 = (0, import_sha2562.hash)(fromString(e, F2));
  return toString(n2, p2);
}
function Pe(e) {
  return fromString(`${e}`, J);
}
function $2(e) {
  return Number(toString(e, J));
}
function Kn(e) {
  const n2 = Pe(typeof e.type < "u" ? e.type : Q2);
  if ($2(n2) === _2 && typeof e.senderPublicKey > "u")
    throw new Error("Missing sender public key for type 1 envelope");
  const t = typeof e.senderPublicKey < "u" ? fromString(e.senderPublicKey, p2) : void 0, r = typeof e.iv < "u" ? fromString(e.iv, p2) : (0, import_random2.randomBytes)(Z2), o2 = new import_chacha20poly1305.ChaCha20Poly1305(fromString(e.symKey, p2)).seal(r, fromString(e.message, F2));
  return Te2({ type: n2, sealed: o2, iv: r, senderPublicKey: t });
}
function Ln(e) {
  const n2 = new import_chacha20poly1305.ChaCha20Poly1305(fromString(e.symKey, p2)), { sealed: t, iv: r } = ee2(e.encoded), o2 = n2.open(r, t);
  if (o2 === null)
    throw new Error("Failed to decrypt");
  return toString(o2, F2);
}
function Te2(e) {
  if ($2(e.type) === _2) {
    if (typeof e.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
    return toString(concat([e.type, e.senderPublicKey, e.iv, e.sealed]), x2);
  }
  return toString(concat([e.type, e.iv, e.sealed]), x2);
}
function ee2(e) {
  const n2 = fromString(e, x2), t = n2.slice($n, Ie2), r = Ie2;
  if ($2(t) === _2) {
    const l2 = r + X, d4 = l2 + Z2, c2 = n2.slice(r, l2), u3 = n2.slice(l2, d4), a2 = n2.slice(d4);
    return { type: t, sealed: a2, iv: u3, senderPublicKey: c2 };
  }
  const o2 = r + Z2, s = n2.slice(r, o2), i2 = n2.slice(o2);
  return { type: t, sealed: i2, iv: s };
}
function xn(e, n2) {
  const t = ee2(e);
  return Re2({ type: $2(t.type), senderPublicKey: typeof t.senderPublicKey < "u" ? toString(t.senderPublicKey, p2) : void 0, receiverPublicKey: n2 == null ? void 0 : n2.receiverPublicKey });
}
function Re2(e) {
  const n2 = (e == null ? void 0 : e.type) || Q2;
  if (n2 === _2) {
    if (typeof (e == null ? void 0 : e.senderPublicKey) > "u")
      throw new Error("missing sender public key");
    if (typeof (e == null ? void 0 : e.receiverPublicKey) > "u")
      throw new Error("missing receiver public key");
  }
  return { type: n2, senderPublicKey: e == null ? void 0 : e.senderPublicKey, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey };
}
function Fn(e) {
  return e.type === _2 && typeof e.senderPublicKey == "string" && typeof e.receiverPublicKey == "string";
}
var Hn = Object.defineProperty;
var Ae = Object.getOwnPropertySymbols;
var qn = Object.prototype.hasOwnProperty;
var Bn = Object.prototype.propertyIsEnumerable;
var Ue = (e, n2, t) => n2 in e ? Hn(e, n2, { enumerable: true, configurable: true, writable: true, value: t }) : e[n2] = t;
var _e = (e, n2) => {
  for (var t in n2 || (n2 = {}))
    qn.call(n2, t) && Ue(e, t, n2[t]);
  if (Ae)
    for (var t of Ae(n2))
      Bn.call(n2, t) && Ue(e, t, n2[t]);
  return e;
};
var Ce2 = "ReactNative";
var m = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
var je = "js";
function te2() {
  return typeof import_process.default < "u" && typeof import_process.default.versions < "u" && typeof import_process.default.versions.node < "u";
}
function j2() {
  return !(0, import_window_getters.getDocument)() && !!(0, import_window_getters.getNavigator)() && navigator.product === Ce2;
}
function q2() {
  return !te2() && !!(0, import_window_getters.getNavigator)();
}
function R2() {
  return j2() ? m.reactNative : te2() ? m.node : q2() ? m.browser : m.unknown;
}
function De2(e, n2) {
  let t = V3.parse(e);
  return t = _e(_e({}, t), n2), e = V3.stringify(t), e;
}
function zn() {
  return (0, import_window_metadata.getWindowMetadata)() || { name: "", description: "", url: "", icons: [""] };
}
function ke2() {
  if (R2() === m.reactNative && typeof _global < "u" && typeof (_global == null ? void 0 : _global.Platform) < "u") {
    const { OS: t, Version: r } = _global.Platform;
    return [t, r].join("-");
  }
  const e = detect();
  if (e === null)
    return "unknown";
  const n2 = e.os ? e.os.replace(" ", "").toLowerCase() : "unknown";
  return e.type === "browser" ? [n2, e.name, e.version].join("-") : [n2, e.version].join("-");
}
function Ve() {
  var e;
  const n2 = R2();
  return n2 === m.browser ? [n2, ((e = (0, import_window_getters.getLocation)()) == null ? void 0 : e.host) || "unknown"].join(":") : n2;
}
function Me(e, n2, t) {
  const r = ke2(), o2 = Ve();
  return [[e, n2].join("-"), [je, t].join("-"), r, o2].join("/");
}
function Jn({ protocol: e, version: n2, relayUrl: t, sdkVersion: r, auth: o2, projectId: s, useOnCloseEvent: i2 }) {
  const l2 = t.split("?"), d4 = Me(e, n2, r), c2 = { auth: o2, ua: d4, projectId: s, useOnCloseEvent: i2 || void 0 }, u3 = De2(l2[1] || "", c2);
  return l2[0] + "?" + u3;
}
function O2(e, n2) {
  return e.filter((t) => n2.includes(t)).length === e.length;
}
function et2(e) {
  return Object.fromEntries(e.entries());
}
function nt2(e) {
  return new Map(Object.entries(e));
}
function st2(e = import_time2.FIVE_MINUTES, n2) {
  const t = (0, import_time2.toMiliseconds)(e || import_time2.FIVE_MINUTES);
  let r, o2, s;
  return { resolve: (i2) => {
    s && r && (clearTimeout(s), r(i2));
  }, reject: (i2) => {
    s && o2 && (clearTimeout(s), o2(i2));
  }, done: () => new Promise((i2, l2) => {
    s = setTimeout(() => {
      l2(new Error(n2));
    }, t), r = i2, o2 = l2;
  }) };
}
function it2(e, n2, t) {
  return new Promise(async (r, o2) => {
    const s = setTimeout(() => o2(new Error(t)), n2);
    try {
      const i2 = await e;
      r(i2);
    } catch (i2) {
      o2(i2);
    }
    clearTimeout(s);
  });
}
function re2(e, n2) {
  if (typeof n2 == "string" && n2.startsWith(`${e}:`))
    return n2;
  if (e.toLowerCase() === "topic") {
    if (typeof n2 != "string")
      throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${n2}`;
  } else if (e.toLowerCase() === "id") {
    if (typeof n2 != "number")
      throw new Error('Value must be "number" for expirer target type: id');
    return `id:${n2}`;
  }
  throw new Error(`Unknown expirer target type: ${e}`);
}
function ct2(e) {
  return re2("topic", e);
}
function at2(e) {
  return re2("id", e);
}
function ut2(e) {
  const [n2, t] = e.split(":"), r = { id: void 0, topic: void 0 };
  if (n2 === "topic" && typeof t == "string")
    r.topic = t;
  else if (n2 === "id" && Number.isInteger(Number(t)))
    r.id = Number(t);
  else
    throw new Error(`Invalid target, expected id:number or topic:string, got ${n2}:${t}`);
  return r;
}
function lt2(e, n2) {
  return (0, import_time2.fromMiliseconds)((n2 || Date.now()) + (0, import_time2.toMiliseconds)(e));
}
function dt2(e) {
  return Date.now() >= (0, import_time2.toMiliseconds)(e);
}
function ft2(e, n2) {
  return `${e}${n2 ? `:${n2}` : ""}`;
}
async function pt2({ id: e, topic: n2, wcDeepLink: t }) {
  try {
    if (!t)
      return;
    const r = typeof t == "string" ? JSON.parse(t) : t;
    let o2 = r == null ? void 0 : r.href;
    if (typeof o2 != "string")
      return;
    o2.endsWith("/") && (o2 = o2.slice(0, -1));
    const s = `${o2}/wc?requestId=${e}&sessionTopic=${n2}`, i2 = R2();
    i2 === m.browser ? s.startsWith("https://") ? window.open(s, "_blank", "noreferrer noopener") : window.open(s, "_self", "noreferrer noopener") : i2 === m.reactNative && typeof (_global == null ? void 0 : _global.Linking) < "u" && await _global.Linking.openURL(s);
  } catch (r) {
    console.error(r);
  }
}
var Fe2 = "irn";
function mt2(e) {
  return (e == null ? void 0 : e.relay) || { protocol: Fe2 };
}
function yt2(e) {
  const n2 = RELAY_JSONRPC[e];
  if (typeof n2 > "u")
    throw new Error(`Relay Protocol not supported: ${e}`);
  return n2;
}
var ht2 = Object.defineProperty;
var He = Object.getOwnPropertySymbols;
var vt2 = Object.prototype.hasOwnProperty;
var gt2 = Object.prototype.propertyIsEnumerable;
var qe = (e, n2, t) => n2 in e ? ht2(e, n2, { enumerable: true, configurable: true, writable: true, value: t }) : e[n2] = t;
var Et2 = (e, n2) => {
  for (var t in n2 || (n2 = {}))
    vt2.call(n2, t) && qe(e, t, n2[t]);
  if (He)
    for (var t of He(n2))
      gt2.call(n2, t) && qe(e, t, n2[t]);
  return e;
};
function Be(e, n2 = "-") {
  const t = {}, r = "relay" + n2;
  return Object.keys(e).forEach((o2) => {
    if (o2.startsWith(r)) {
      const s = o2.replace(r, ""), i2 = e[o2];
      t[s] = i2;
    }
  }), t;
}
function bt2(e) {
  e = e.includes("wc://") ? e.replace("wc://", "") : e, e = e.includes("wc:") ? e.replace("wc:", "") : e;
  const n2 = e.indexOf(":"), t = e.indexOf("?") !== -1 ? e.indexOf("?") : void 0, r = e.substring(0, n2), o2 = e.substring(n2 + 1, t).split("@"), s = typeof t < "u" ? e.substring(t) : "", i2 = V3.parse(s);
  return { protocol: r, topic: Ge(o2[0]), version: parseInt(o2[1], 10), symKey: i2.symKey, relay: Be(i2) };
}
function Ge(e) {
  return e.startsWith("//") ? e.substring(2) : e;
}
function We2(e, n2 = "-") {
  const t = "relay", r = {};
  return Object.keys(e).forEach((o2) => {
    const s = t + n2 + o2;
    e[o2] && (r[s] = e[o2]);
  }), r;
}
function Nt2(e) {
  return `${e.protocol}:${e.topic}@${e.version}?` + V3.stringify(Et2({ symKey: e.symKey }, We2(e.relay)));
}
function A(e) {
  const n2 = [];
  return e.forEach((t) => {
    const [r, o2] = t.split(":");
    n2.push(`${r}:${o2}`);
  }), n2;
}
function Je2(e) {
  const n2 = [];
  return Object.values(e).forEach((t) => {
    n2.push(...A(t.accounts));
  }), n2;
}
function Qe(e, n2) {
  const t = [];
  return Object.values(e).forEach((r) => {
    A(r.accounts).includes(n2) && t.push(...r.methods);
  }), t;
}
function Ze2(e, n2) {
  const t = [];
  return Object.values(e).forEach((r) => {
    A(r.accounts).includes(n2) && t.push(...r.events);
  }), t;
}
function At2(e, n2) {
  const t = cn(e, n2);
  if (t)
    throw new Error(t.message);
  const r = {};
  for (const [o2, s] of Object.entries(e))
    r[o2] = { methods: s.methods, events: s.events, chains: s.accounts.map((i2) => `${i2.split(":")[0]}:${i2.split(":")[1]}`) };
  return r;
}
var _t2 = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
var Ct2 = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function N3(e, n2) {
  const { message: t, code: r } = Ct2[e];
  return { message: n2 ? `${t} ${n2}` : t, code: r };
}
function U2(e, n2) {
  const { message: t, code: r } = _t2[e];
  return { message: n2 ? `${t} ${n2}` : t, code: r };
}
function D2(e, n2) {
  return Array.isArray(e) ? typeof n2 < "u" && e.length ? e.every(n2) : true : false;
}
function B2(e) {
  return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length;
}
function w(e) {
  return typeof e > "u";
}
function h3(e, n2) {
  return n2 && w(e) ? true : typeof e == "string" && !!e.trim().length;
}
function G2(e, n2) {
  return n2 && w(e) ? true : typeof e == "number" && !isNaN(e);
}
function $t3(e, n2) {
  const { requiredNamespaces: t } = n2, r = Object.keys(e.namespaces), o2 = Object.keys(t);
  let s = true;
  return O2(o2, r) ? (r.forEach((i2) => {
    const { accounts: l2, methods: d4, events: c2 } = e.namespaces[i2], u3 = A(l2), a2 = t[i2];
    (!O2(K2(i2, a2), u3) || !O2(a2.methods, d4) || !O2(a2.events, c2)) && (s = false);
  }), s) : false;
}
function k(e) {
  return h3(e, false) && e.includes(":") ? e.split(":").length === 2 : false;
}
function en(e) {
  if (h3(e, false) && e.includes(":")) {
    const n2 = e.split(":");
    if (n2.length === 3) {
      const t = n2[0] + ":" + n2[1];
      return !!n2[2] && k(t);
    }
  }
  return false;
}
function jt3(e) {
  if (h3(e, false))
    try {
      return typeof new URL(e) < "u";
    } catch {
      return false;
    }
  return false;
}
function Dt2(e) {
  var n2;
  return (n2 = e == null ? void 0 : e.proposer) == null ? void 0 : n2.publicKey;
}
function kt2(e) {
  return e == null ? void 0 : e.topic;
}
function Vt2(e, n2) {
  let t = null;
  return h3(e == null ? void 0 : e.publicKey, false) || (t = N3("MISSING_OR_INVALID", `${n2} controller public key should be a string`)), t;
}
function ie2(e) {
  let n2 = true;
  return D2(e) ? e.length && (n2 = e.every((t) => h3(t, false))) : n2 = false, n2;
}
function nn(e, n2, t) {
  let r = null;
  return D2(n2) && n2.length ? n2.forEach((o2) => {
    r || k(o2) || (r = U2("UNSUPPORTED_CHAINS", `${t}, chain ${o2} should be a string and conform to "namespace:chainId" format`));
  }) : k(e) || (r = U2("UNSUPPORTED_CHAINS", `${t}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r;
}
function tn(e, n2, t) {
  let r = null;
  return Object.entries(e).forEach(([o2, s]) => {
    if (r)
      return;
    const i2 = nn(o2, K2(o2, s), `${n2} ${t}`);
    i2 && (r = i2);
  }), r;
}
function rn(e, n2) {
  let t = null;
  return D2(e) ? e.forEach((r) => {
    t || en(r) || (t = U2("UNSUPPORTED_ACCOUNTS", `${n2}, account ${r} should be a string and conform to "namespace:chainId:address" format`));
  }) : t = U2("UNSUPPORTED_ACCOUNTS", `${n2}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), t;
}
function on(e, n2) {
  let t = null;
  return Object.values(e).forEach((r) => {
    if (t)
      return;
    const o2 = rn(r == null ? void 0 : r.accounts, `${n2} namespace`);
    o2 && (t = o2);
  }), t;
}
function sn(e, n2) {
  let t = null;
  return ie2(e == null ? void 0 : e.methods) ? ie2(e == null ? void 0 : e.events) || (t = U2("UNSUPPORTED_EVENTS", `${n2}, events should be an array of strings or empty array for no events`)) : t = U2("UNSUPPORTED_METHODS", `${n2}, methods should be an array of strings or empty array for no methods`), t;
}
function ce2(e, n2) {
  let t = null;
  return Object.values(e).forEach((r) => {
    if (t)
      return;
    const o2 = sn(r, `${n2}, namespace`);
    o2 && (t = o2);
  }), t;
}
function Mt2(e, n2, t) {
  let r = null;
  if (e && B2(e)) {
    const o2 = ce2(e, n2);
    o2 && (r = o2);
    const s = tn(e, n2, t);
    s && (r = s);
  } else
    r = N3("MISSING_OR_INVALID", `${n2}, ${t} should be an object with data`);
  return r;
}
function cn(e, n2) {
  let t = null;
  if (e && B2(e)) {
    const r = ce2(e, n2);
    r && (t = r);
    const o2 = on(e, n2);
    o2 && (t = o2);
  } else
    t = N3("MISSING_OR_INVALID", `${n2}, namespaces should be an object with data`);
  return t;
}
function an(e) {
  return h3(e.protocol, true);
}
function Kt2(e, n2) {
  let t = false;
  return n2 && !e ? t = true : e && D2(e) && e.length && e.forEach((r) => {
    t = an(r);
  }), t;
}
function Lt2(e) {
  return typeof e == "number";
}
function xt2(e) {
  return typeof e < "u" && typeof e !== null;
}
function Ft2(e) {
  return !(!e || typeof e != "object" || !e.code || !G2(e.code, false) || !e.message || !h3(e.message, false));
}
function Ht2(e) {
  return !(w(e) || !h3(e.method, false));
}
function qt2(e) {
  return !(w(e) || w(e.result) && w(e.error) || !G2(e.id, false) || !h3(e.jsonrpc, false));
}
function Bt2(e) {
  return !(w(e) || !h3(e.name, false));
}
function Gt2(e, n2) {
  return !(!k(n2) || !Je2(e).includes(n2));
}
function Wt2(e, n2, t) {
  return h3(t, false) ? Qe(e, n2).includes(t) : false;
}
function zt2(e, n2, t) {
  return h3(t, false) ? Ze2(e, n2).includes(t) : false;
}
function un(e, n2, t) {
  let r = null;
  const o2 = Yt2(e), s = Jt2(n2), i2 = Object.keys(o2), l2 = Object.keys(s), d4 = ln(Object.keys(e)), c2 = ln(Object.keys(n2)), u3 = d4.filter((a2) => !c2.includes(a2));
  return u3.length && (r = N3("NON_CONFORMING_NAMESPACES", `${t} namespaces keys don't satisfy requiredNamespaces.
      Required: ${u3.toString()}
      Received: ${Object.keys(n2).toString()}`)), O2(i2, l2) || (r = N3("NON_CONFORMING_NAMESPACES", `${t} namespaces chains don't satisfy required namespaces.
      Required: ${i2.toString()}
      Approved: ${l2.toString()}`)), Object.keys(n2).forEach((a2) => {
    if (!a2.includes(":") || r)
      return;
    const b4 = A(n2[a2].accounts);
    b4.includes(a2) || (r = N3("NON_CONFORMING_NAMESPACES", `${t} namespaces accounts don't satisfy namespace accounts for ${a2}
        Required: ${a2}
        Approved: ${b4.toString()}`));
  }), i2.forEach((a2) => {
    r || (O2(o2[a2].methods, s[a2].methods) ? O2(o2[a2].events, s[a2].events) || (r = N3("NON_CONFORMING_NAMESPACES", `${t} namespaces events don't satisfy namespace events for ${a2}`)) : r = N3("NON_CONFORMING_NAMESPACES", `${t} namespaces methods don't satisfy namespace methods for ${a2}`));
  }), r;
}
function Yt2(e) {
  const n2 = {};
  return Object.keys(e).forEach((t) => {
    var r;
    t.includes(":") ? n2[t] = e[t] : (r = e[t].chains) == null || r.forEach((o2) => {
      n2[o2] = { methods: e[t].methods, events: e[t].events };
    });
  }), n2;
}
function ln(e) {
  return [...new Set(e.map((n2) => n2.includes(":") ? n2.split(":")[0] : n2))];
}
function Jt2(e) {
  const n2 = {};
  return Object.keys(e).forEach((t) => {
    if (t.includes(":"))
      n2[t] = e[t];
    else {
      const r = A(e[t].accounts);
      r == null ? void 0 : r.forEach((o2) => {
        n2[o2] = { accounts: e[t].accounts.filter((s) => s.includes(`${o2}:`)), methods: e[t].methods, events: e[t].events };
      });
    }
  }), n2;
}
function Qt3(e, n2) {
  return G2(e, false) && e <= n2.max && e >= n2.min;
}
function Zt2() {
  const e = R2();
  return new Promise((n2) => {
    switch (e) {
      case m.browser:
        n2(dn());
        break;
      case m.reactNative:
        n2(fn());
        break;
      case m.node:
        n2(pn());
        break;
      default:
        n2(true);
    }
  });
}
function dn() {
  return q2() && (navigator == null ? void 0 : navigator.onLine);
}
async function fn() {
  if (j2() && typeof _global < "u" && _global != null && _global.NetInfo) {
    const e = await (_global == null ? void 0 : _global.NetInfo.fetch());
    return e == null ? void 0 : e.isConnected;
  }
  return true;
}
function pn() {
  return true;
}
function Xt2(e) {
  switch (R2()) {
    case m.browser:
      mn(e);
      break;
    case m.reactNative:
      yn(e);
      break;
    case m.node:
      break;
  }
}
function mn(e) {
  !j2() && q2() && (window.addEventListener("online", () => e(true)), window.addEventListener("offline", () => e(false)));
}
function yn(e) {
  var _a;
  j2() && typeof _global < "u" && _global != null && _global.NetInfo && ((_a = _global) == null ? void 0 : _a.NetInfo.addEventListener((n2) => e(n2 == null ? void 0 : n2.isConnected)));
}
var ae2 = {};
var er2 = class {
  static get(n2) {
    return ae2[n2];
  }
  static set(n2, t) {
    ae2[n2] = t;
  }
  static delete(n2) {
    delete ae2[n2];
  }
};

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/core/dist/index.es.js
var import_time3 = __toESM(require_cjs());
var import_lodash = __toESM(require_lodash());
function Bi(r, e) {
  if (r.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), i2 = 0; i2 < t.length; i2++)
    t[i2] = 255;
  for (var s = 0; s < r.length; s++) {
    var n2 = r.charAt(s), a2 = n2.charCodeAt(0);
    if (t[a2] !== 255)
      throw new TypeError(n2 + " is ambiguous");
    t[a2] = s;
  }
  var o2 = r.length, h4 = r.charAt(0), u3 = Math.log(o2) / Math.log(256), d4 = Math.log(256) / Math.log(o2);
  function p4(c2) {
    if (c2 instanceof Uint8Array || (ArrayBuffer.isView(c2) ? c2 = new Uint8Array(c2.buffer, c2.byteOffset, c2.byteLength) : Array.isArray(c2) && (c2 = Uint8Array.from(c2))), !(c2 instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (c2.length === 0)
      return "";
    for (var m3 = 0, z3 = 0, I4 = 0, _4 = c2.length; I4 !== _4 && c2[I4] === 0; )
      I4++, m3++;
    for (var S4 = (_4 - I4) * d4 + 1 >>> 0, b4 = new Uint8Array(S4); I4 !== _4; ) {
      for (var T3 = c2[I4], A3 = 0, C2 = S4 - 1; (T3 !== 0 || A3 < z3) && C2 !== -1; C2--, A3++)
        T3 += 256 * b4[C2] >>> 0, b4[C2] = T3 % o2 >>> 0, T3 = T3 / o2 >>> 0;
      if (T3 !== 0)
        throw new Error("Non-zero carry");
      z3 = A3, I4++;
    }
    for (var x4 = S4 - z3; x4 !== S4 && b4[x4] === 0; )
      x4++;
    for (var j4 = h4.repeat(m3); x4 < S4; ++x4)
      j4 += r.charAt(b4[x4]);
    return j4;
  }
  function y4(c2) {
    if (typeof c2 != "string")
      throw new TypeError("Expected String");
    if (c2.length === 0)
      return new Uint8Array();
    var m3 = 0;
    if (c2[m3] !== " ") {
      for (var z3 = 0, I4 = 0; c2[m3] === h4; )
        z3++, m3++;
      for (var _4 = (c2.length - m3) * u3 + 1 >>> 0, S4 = new Uint8Array(_4); c2[m3]; ) {
        var b4 = t[c2.charCodeAt(m3)];
        if (b4 === 255)
          return;
        for (var T3 = 0, A3 = _4 - 1; (b4 !== 0 || T3 < I4) && A3 !== -1; A3--, T3++)
          b4 += o2 * S4[A3] >>> 0, S4[A3] = b4 % 256 >>> 0, b4 = b4 / 256 >>> 0;
        if (b4 !== 0)
          throw new Error("Non-zero carry");
        I4 = T3, m3++;
      }
      if (c2[m3] !== " ") {
        for (var C2 = _4 - I4; C2 !== _4 && S4[C2] === 0; )
          C2++;
        for (var x4 = new Uint8Array(z3 + (_4 - C2)), j4 = z3; C2 !== _4; )
          x4[j4++] = S4[C2++];
        return x4;
      }
    }
  }
  function M4(c2) {
    var m3 = y4(c2);
    if (m3)
      return m3;
    throw new Error(`Non-${e} character`);
  }
  return { encode: p4, decodeUnsafe: y4, decode: M4 };
}
var Vi = Bi;
var qi = Vi;
var ze = (r) => {
  if (r instanceof Uint8Array && r.constructor.name === "Uint8Array")
    return r;
  if (r instanceof ArrayBuffer)
    return new Uint8Array(r);
  if (ArrayBuffer.isView(r))
    return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var ji = (r) => new TextEncoder().encode(r);
var Yi = (r) => new TextDecoder().decode(r);
var Gi = class {
  constructor(e, t, i2) {
    this.name = e, this.prefix = t, this.baseEncode = i2;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var Hi = class {
  constructor(e, t, i2) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = i2;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return Ne(this, e);
  }
};
var Ji = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return Ne(this, e);
  }
  decode(e) {
    const t = e[0], i2 = this.decoders[t];
    if (i2)
      return i2.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var Ne = (r, e) => new Ji({ ...r.decoders || { [r.prefix]: r }, ...e.decoders || { [e.prefix]: e } });
var Wi = class {
  constructor(e, t, i2, s) {
    this.name = e, this.prefix = t, this.baseEncode = i2, this.baseDecode = s, this.encoder = new Gi(e, t, i2), this.decoder = new Hi(e, t, s);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
var X2 = ({ name: r, prefix: e, encode: t, decode: i2 }) => new Wi(r, e, t, i2);
var B3 = ({ prefix: r, name: e, alphabet: t }) => {
  const { encode: i2, decode: s } = qi(t, e);
  return X2({ prefix: r, name: e, encode: i2, decode: (n2) => ze(s(n2)) });
};
var Xi = (r, e, t, i2) => {
  const s = {};
  for (let d4 = 0; d4 < e.length; ++d4)
    s[e[d4]] = d4;
  let n2 = r.length;
  for (; r[n2 - 1] === "="; )
    --n2;
  const a2 = new Uint8Array(n2 * t / 8 | 0);
  let o2 = 0, h4 = 0, u3 = 0;
  for (let d4 = 0; d4 < n2; ++d4) {
    const p4 = s[r[d4]];
    if (p4 === void 0)
      throw new SyntaxError(`Non-${i2} character`);
    h4 = h4 << t | p4, o2 += t, o2 >= 8 && (o2 -= 8, a2[u3++] = 255 & h4 >> o2);
  }
  if (o2 >= t || 255 & h4 << 8 - o2)
    throw new SyntaxError("Unexpected end of data");
  return a2;
};
var Qi = (r, e, t) => {
  const i2 = e[e.length - 1] === "=", s = (1 << t) - 1;
  let n2 = "", a2 = 0, o2 = 0;
  for (let h4 = 0; h4 < r.length; ++h4)
    for (o2 = o2 << 8 | r[h4], a2 += 8; a2 > t; )
      a2 -= t, n2 += e[s & o2 >> a2];
  if (a2 && (n2 += e[s & o2 << t - a2]), i2)
    for (; n2.length * t & 7; )
      n2 += "=";
  return n2;
};
var g2 = ({ name: r, prefix: e, bitsPerChar: t, alphabet: i2 }) => X2({ prefix: e, name: r, encode(s) {
  return Qi(s, i2, t);
}, decode(s) {
  return Xi(s, i2, t, r);
} });
var Zi = X2({ prefix: "\0", name: "identity", encode: (r) => Yi(r), decode: (r) => ji(r) });
var es = Object.freeze({ __proto__: null, identity: Zi });
var ts = g2({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var is = Object.freeze({ __proto__: null, base2: ts });
var ss = g2({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var rs = Object.freeze({ __proto__: null, base8: ss });
var ns = B3({ prefix: "9", name: "base10", alphabet: "0123456789" });
var as = Object.freeze({ __proto__: null, base10: ns });
var os = g2({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var hs = g2({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var cs = Object.freeze({ __proto__: null, base16: os, base16upper: hs });
var us = g2({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var ls = g2({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var ds = g2({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var gs = g2({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var ps = g2({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var Ds = g2({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var ys = g2({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var ms = g2({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var bs = g2({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var fs = Object.freeze({ __proto__: null, base32: us, base32upper: ls, base32pad: ds, base32padupper: gs, base32hex: ps, base32hexupper: Ds, base32hexpad: ys, base32hexpadupper: ms, base32z: bs });
var Es = B3({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var ws = B3({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var vs = Object.freeze({ __proto__: null, base36: Es, base36upper: ws });
var Is = B3({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Cs = B3({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Rs = Object.freeze({ __proto__: null, base58btc: Is, base58flickr: Cs });
var _s = g2({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var Ss = g2({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var Ts = g2({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var Ps = g2({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var xs = Object.freeze({ __proto__: null, base64: _s, base64pad: Ss, base64url: Ts, base64urlpad: Ps });
var Ue2 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var Os = Ue2.reduce((r, e, t) => (r[t] = e, r), []);
var As = Ue2.reduce((r, e, t) => (r[e.codePointAt(0)] = t, r), []);
function zs(r) {
  return r.reduce((e, t) => (e += Os[t], e), "");
}
function Ns(r) {
  const e = [];
  for (const t of r) {
    const i2 = As[t.codePointAt(0)];
    if (i2 === void 0)
      throw new Error(`Non-base256emoji character: ${t}`);
    e.push(i2);
  }
  return new Uint8Array(e);
}
var Us = X2({ prefix: "\u{1F680}", name: "base256emoji", encode: zs, decode: Ns });
var Ls = Object.freeze({ __proto__: null, base256emoji: Us });
var Fs = Fe3;
var Le2 = 128;
var $s = 127;
var Ms = ~$s;
var ks = Math.pow(2, 31);
function Fe3(r, e, t) {
  e = e || [], t = t || 0;
  for (var i2 = t; r >= ks; )
    e[t++] = r & 255 | Le2, r /= 128;
  for (; r & Ms; )
    e[t++] = r & 255 | Le2, r >>>= 7;
  return e[t] = r | 0, Fe3.bytes = t - i2 + 1, e;
}
var Ks = he3;
var Bs = 128;
var $e = 127;
function he3(r, i2) {
  var t = 0, i2 = i2 || 0, s = 0, n2 = i2, a2, o2 = r.length;
  do {
    if (n2 >= o2)
      throw he3.bytes = 0, new RangeError("Could not decode varint");
    a2 = r[n2++], t += s < 28 ? (a2 & $e) << s : (a2 & $e) * Math.pow(2, s), s += 7;
  } while (a2 >= Bs);
  return he3.bytes = n2 - i2, t;
}
var Vs = Math.pow(2, 7);
var qs = Math.pow(2, 14);
var js = Math.pow(2, 21);
var Ys = Math.pow(2, 28);
var Gs = Math.pow(2, 35);
var Hs = Math.pow(2, 42);
var Js = Math.pow(2, 49);
var Ws = Math.pow(2, 56);
var Xs = Math.pow(2, 63);
var Qs = function(r) {
  return r < Vs ? 1 : r < qs ? 2 : r < js ? 3 : r < Ys ? 4 : r < Gs ? 5 : r < Hs ? 6 : r < Js ? 7 : r < Ws ? 8 : r < Xs ? 9 : 10;
};
var Zs = { encode: Fs, decode: Ks, encodingLength: Qs };
var Me2 = Zs;
var ke3 = (r, e, t = 0) => (Me2.encode(r, e, t), e);
var Ke2 = (r) => Me2.encodingLength(r);
var ce3 = (r, e) => {
  const t = e.byteLength, i2 = Ke2(r), s = i2 + Ke2(t), n2 = new Uint8Array(s + t);
  return ke3(r, n2, 0), ke3(t, n2, i2), n2.set(e, s), new er3(r, t, e, n2);
};
var er3 = class {
  constructor(e, t, i2, s) {
    this.code = e, this.size = t, this.digest = i2, this.bytes = s;
  }
};
var Be2 = ({ name: r, code: e, encode: t }) => new tr2(r, e, t);
var tr2 = class {
  constructor(e, t, i2) {
    this.name = e, this.code = t, this.encode = i2;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array ? ce3(this.code, t) : t.then((i2) => ce3(this.code, i2));
    } else
      throw Error("Unknown type, must be binary type");
  }
};
var Ve2 = (r) => async (e) => new Uint8Array(await crypto.subtle.digest(r, e));
var ir2 = Be2({ name: "sha2-256", code: 18, encode: Ve2("SHA-256") });
var sr2 = Be2({ name: "sha2-512", code: 19, encode: Ve2("SHA-512") });
var rr2 = Object.freeze({ __proto__: null, sha256: ir2, sha512: sr2 });
var qe2 = 0;
var nr2 = "identity";
var je2 = ze;
var ar2 = (r) => ce3(qe2, je2(r));
var or2 = { code: qe2, name: nr2, encode: je2, digest: ar2 };
var hr2 = Object.freeze({ __proto__: null, identity: or2 });
new TextEncoder(), new TextDecoder();
var Ye = { ...es, ...is, ...rs, ...as, ...cs, ...fs, ...vs, ...Rs, ...xs, ...Ls };
({ ...rr2, ...hr2 });
function Ge2(r) {
  return globalThis.Buffer != null ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength) : r;
}
function cr2(r = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Ge2(globalThis.Buffer.allocUnsafe(r)) : new Uint8Array(r);
}
function He2(r, e, t, i2) {
  return { name: r, prefix: e, encoder: { name: r, prefix: e, encode: t }, decoder: { decode: i2 } };
}
var Je3 = He2("utf8", "u", (r) => "u" + new TextDecoder("utf8").decode(r), (r) => new TextEncoder().encode(r.substring(1)));
var ue3 = He2("ascii", "a", (r) => {
  let e = "a";
  for (let t = 0; t < r.length; t++)
    e += String.fromCharCode(r[t]);
  return e;
}, (r) => {
  r = r.substring(1);
  const e = cr2(r.length);
  for (let t = 0; t < r.length; t++)
    e[t] = r.charCodeAt(t);
  return e;
});
var ur2 = { utf8: Je3, "utf-8": Je3, hex: Ye.base16, latin1: ue3, ascii: ue3, binary: ue3, ...Ye };
function lr2(r, e = "utf8") {
  const t = ur2[e];
  if (!t)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Ge2(globalThis.Buffer.from(r, "utf-8")) : t.decoder.decode(`${t.prefix}${r}`);
}
var le3 = "wc";
var We3 = 2;
var Q3 = "core";
var O3 = `${le3}@2:${Q3}:`;
var Xe2 = { name: Q3, logger: "error" };
var Qe2 = { database: ":memory:" };
var Ze3 = "crypto";
var de3 = "client_ed25519_seed";
var et3 = import_time3.ONE_DAY;
var tt2 = "keychain";
var it3 = "0.3";
var st3 = "messages";
var rt2 = "0.3";
var nt3 = import_time3.SIX_HOURS;
var at3 = "publisher";
var ot2 = "irn";
var ht3 = "error";
var ge2 = "wss://relay.walletconnect.com";
var pe2 = "wss://relay.walletconnect.org";
var ct3 = "relayer";
var D3 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var ut3 = "_subscription";
var P = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var lt3 = import_time3.ONE_SECOND;
var dt3 = "2.10.3";
var gt3 = 1e4;
var pt3 = "0.3";
var Dt3 = "WALLETCONNECT_CLIENT_ID";
var w2 = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var yt3 = "subscription";
var mt3 = "0.3";
var bt3 = import_time3.FIVE_SECONDS * 1e3;
var ft3 = "pairing";
var Et3 = "0.3";
var F3 = { wc_pairingDelete: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time3.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time3.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 0 } } };
var V4 = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" };
var R3 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var wt2 = "history";
var vt3 = "0.3";
var It2 = "expirer";
var v = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var Ct3 = "0.3";
var Z3 = "verify-api";
var $3 = "https://verify.walletconnect.com";
var ee3 = "https://verify.walletconnect.org";
var Rt2 = [$3, ee3];
var _t3 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, this.keychain = /* @__PURE__ */ new Map(), this.name = tt2, this.version = it3, this.initialized = false, this.storagePrefix = O3, this.init = async () => {
      if (!this.initialized) {
        const i2 = await this.getKeyChain();
        typeof i2 < "u" && (this.keychain = i2), this.initialized = true;
      }
    }, this.has = (i2) => (this.isInitialized(), this.keychain.has(i2)), this.set = async (i2, s) => {
      this.isInitialized(), this.keychain.set(i2, s), await this.persist();
    }, this.get = (i2) => {
      this.isInitialized();
      const s = this.keychain.get(i2);
      if (typeof s > "u") {
        const { message: n2 } = N3("NO_MATCHING_KEY", `${this.name}: ${i2}`);
        throw new Error(n2);
      }
      return s;
    }, this.del = async (i2) => {
      this.isInitialized(), this.keychain.delete(i2), await this.persist();
    }, this.core = e, this.logger = (0, import_logger2.generateChildLogger)(t, this.name);
  }
  get context() {
    return (0, import_logger2.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, et2(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? nt2(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N3("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var St2 = class {
  constructor(e, t, i2) {
    this.core = e, this.logger = t, this.name = Ze3, this.initialized = false, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }, this.hasKeys = (s) => (this.isInitialized(), this.keychain.has(s)), this.getClientId = async () => {
      this.isInitialized();
      const s = await this.getClientSeed(), n2 = generateKeyPair(s);
      return encodeIss(n2.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const s = jn();
      return this.setPrivateKey(s.publicKey, s.privateKey);
    }, this.signJWT = async (s) => {
      this.isInitialized();
      const n2 = await this.getClientSeed(), a2 = generateKeyPair(n2), o2 = Dn(), h4 = et3;
      return await signJWT(o2, s, h4, a2);
    }, this.generateSharedKey = (s, n2, a2) => {
      this.isInitialized();
      const o2 = this.getPrivateKey(s), h4 = kn(o2, n2);
      return this.setSymKey(h4, a2);
    }, this.setSymKey = async (s, n2) => {
      this.isInitialized();
      const a2 = n2 || Vn2(s);
      return await this.keychain.set(a2, s), a2;
    }, this.deleteKeyPair = async (s) => {
      this.isInitialized(), await this.keychain.del(s);
    }, this.deleteSymKey = async (s) => {
      this.isInitialized(), await this.keychain.del(s);
    }, this.encode = async (s, n2, a2) => {
      this.isInitialized();
      const o2 = Re2(a2), h4 = safeJsonStringify(n2);
      if (Fn(o2)) {
        const y4 = o2.senderPublicKey, M4 = o2.receiverPublicKey;
        s = await this.generateSharedKey(y4, M4);
      }
      const u3 = this.getSymKey(s), { type: d4, senderPublicKey: p4 } = o2;
      return Kn({ type: d4, symKey: u3, message: h4, senderPublicKey: p4 });
    }, this.decode = async (s, n2, a2) => {
      this.isInitialized();
      const o2 = xn(n2, a2);
      if (Fn(o2)) {
        const h4 = o2.receiverPublicKey, u3 = o2.senderPublicKey;
        s = await this.generateSharedKey(h4, u3);
      }
      try {
        const h4 = this.getSymKey(s), u3 = Ln({ symKey: h4, encoded: n2 });
        return safeJsonParse(u3);
      } catch (h4) {
        this.logger.error(`Failed to decode message from topic: '${s}', clientId: '${await this.getClientId()}'`), this.logger.error(h4);
      }
    }, this.getPayloadType = (s) => {
      const n2 = ee2(s);
      return $2(n2.type);
    }, this.getPayloadSenderPublicKey = (s) => {
      const n2 = ee2(s);
      return n2.senderPublicKey ? toString(n2.senderPublicKey, p2) : void 0;
    }, this.core = e, this.logger = (0, import_logger2.generateChildLogger)(t, this.name), this.keychain = i2 || new _t3(this.core, this.logger);
  }
  get context() {
    return (0, import_logger2.getLoggerContext)(this.logger);
  }
  async setPrivateKey(e, t) {
    return await this.keychain.set(e, t), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(de3);
    } catch {
      e = Dn(), await this.keychain.set(de3, e);
    }
    return lr2(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N3("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Tt2 = class extends a {
  constructor(e, t) {
    super(e, t), this.logger = e, this.core = t, this.messages = /* @__PURE__ */ new Map(), this.name = st3, this.version = rt2, this.initialized = false, this.storagePrefix = O3, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const i2 = await this.getRelayerMessages();
          typeof i2 < "u" && (this.messages = i2), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (i2) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i2);
        } finally {
          this.initialized = true;
        }
      }
    }, this.set = async (i2, s) => {
      this.isInitialized();
      const n2 = Mn(s);
      let a2 = this.messages.get(i2);
      return typeof a2 > "u" && (a2 = {}), typeof a2[n2] < "u" || (a2[n2] = s, this.messages.set(i2, a2), await this.persist()), n2;
    }, this.get = (i2) => {
      this.isInitialized();
      let s = this.messages.get(i2);
      return typeof s > "u" && (s = {}), s;
    }, this.has = (i2, s) => {
      this.isInitialized();
      const n2 = this.get(i2), a2 = Mn(s);
      return typeof n2[a2] < "u";
    }, this.del = async (i2) => {
      this.isInitialized(), this.messages.delete(i2), await this.persist();
    }, this.logger = (0, import_logger2.generateChildLogger)(e, this.name), this.core = t;
  }
  get context() {
    return (0, import_logger2.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, et2(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? nt2(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N3("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var yr2 = class extends u {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, this.events = new import_events4.EventEmitter(), this.name = at3, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = (0, import_time3.toMiliseconds)(import_time3.TEN_SECONDS), this.needsTransportRestart = false, this.publish = async (i2, s, n2) => {
      var a2;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i2, message: s, opts: n2 } });
      try {
        const o2 = (n2 == null ? void 0 : n2.ttl) || nt3, h4 = mt2(n2), u3 = (n2 == null ? void 0 : n2.prompt) || false, d4 = (n2 == null ? void 0 : n2.tag) || 0, p4 = (n2 == null ? void 0 : n2.id) || getBigIntRpcId().toString(), y4 = { topic: i2, message: s, opts: { ttl: o2, relay: h4, prompt: u3, tag: d4, id: p4 } }, M4 = setTimeout(() => this.queue.set(p4, y4), this.publishTimeout);
        try {
          await await it2(this.rpcPublish(i2, s, o2, h4, u3, d4, p4), this.publishTimeout, "Failed to publish payload, please try again."), this.removeRequestFromQueue(p4), this.relayer.events.emit(D3.publish, y4);
        } catch (c2) {
          if (this.logger.debug("Publishing Payload stalled"), this.needsTransportRestart = true, (a2 = n2 == null ? void 0 : n2.internal) != null && a2.throwOnFailedPublish)
            throw this.removeRequestFromQueue(p4), c2;
          return;
        } finally {
          clearTimeout(M4);
        }
        this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i2, message: s, opts: n2 } });
      } catch (o2) {
        throw this.logger.debug("Failed to Publish Payload"), this.logger.error(o2), o2;
      }
    }, this.on = (i2, s) => {
      this.events.on(i2, s);
    }, this.once = (i2, s) => {
      this.events.once(i2, s);
    }, this.off = (i2, s) => {
      this.events.off(i2, s);
    }, this.removeListener = (i2, s) => {
      this.events.removeListener(i2, s);
    }, this.relayer = e, this.logger = (0, import_logger2.generateChildLogger)(t, this.name), this.registerEventListeners();
  }
  get context() {
    return (0, import_logger2.getLoggerContext)(this.logger);
  }
  rpcPublish(e, t, i2, s, n2, a2, o2) {
    var h4, u3, d4, p4;
    const y4 = { method: yt2(s.protocol).publish, params: { topic: e, message: t, ttl: i2, prompt: n2, tag: a2 }, id: o2 };
    return w((h4 = y4.params) == null ? void 0 : h4.prompt) && ((u3 = y4.params) == null || delete u3.prompt), w((d4 = y4.params) == null ? void 0 : d4.tag) && ((p4 = y4.params) == null || delete p4.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: y4 }), this.relayer.request(y4);
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e) => {
      const { topic: t, message: i2, opts: s } = e;
      await this.publish(t, i2, s);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(D3.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(D3.message_ack, (e) => {
      this.removeRequestFromQueue(e.id.toString());
    });
  }
};
var mr2 = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (e, t) => {
      const i2 = this.get(e);
      this.exists(e, t) || this.map.set(e, [...i2, t]);
    }, this.get = (e) => this.map.get(e) || [], this.exists = (e, t) => this.get(e).includes(t), this.delete = (e, t) => {
      if (typeof t > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e))
        return;
      const i2 = this.get(e);
      if (!this.exists(e, t))
        return;
      const s = i2.filter((n2) => n2 !== t);
      if (!s.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, s);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var br2 = Object.defineProperty;
var fr2 = Object.defineProperties;
var Er2 = Object.getOwnPropertyDescriptors;
var Pt2 = Object.getOwnPropertySymbols;
var wr2 = Object.prototype.hasOwnProperty;
var vr2 = Object.prototype.propertyIsEnumerable;
var xt3 = (r, e, t) => e in r ? br2(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var q3 = (r, e) => {
  for (var t in e || (e = {}))
    wr2.call(e, t) && xt3(r, t, e[t]);
  if (Pt2)
    for (var t of Pt2(e))
      vr2.call(e, t) && xt3(r, t, e[t]);
  return r;
};
var De3 = (r, e) => fr2(r, Er2(e));
var Ot2 = class extends d2 {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new mr2(), this.events = new import_events4.EventEmitter(), this.name = yt3, this.version = mt3, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = false, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = O3, this.subscribeTimeout = 1e4, this.restartInProgress = false, this.batchSubscribeTopicsLimit = 500, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId());
    }, this.subscribe = async (i2, s) => {
      await this.restartToComplete(), this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i2, opts: s } });
      try {
        const n2 = mt2(s), a2 = { topic: i2, relay: n2 };
        this.pending.set(i2, a2);
        const o2 = await this.rpcSubscribe(i2, n2);
        return this.onSubscribe(o2, a2), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i2, opts: s } }), o2;
      } catch (n2) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(n2), n2;
      }
    }, this.unsubscribe = async (i2, s) => {
      await this.restartToComplete(), this.isInitialized(), typeof (s == null ? void 0 : s.id) < "u" ? await this.unsubscribeById(i2, s.id, s) : await this.unsubscribeByTopic(i2, s);
    }, this.isSubscribed = async (i2) => this.topics.includes(i2) ? true : await new Promise((s, n2) => {
      const a2 = new import_time3.Watch();
      a2.start(this.pendingSubscriptionWatchLabel);
      const o2 = setInterval(() => {
        !this.pending.has(i2) && this.topics.includes(i2) && (clearInterval(o2), a2.stop(this.pendingSubscriptionWatchLabel), s(true)), a2.elapsed(this.pendingSubscriptionWatchLabel) >= bt3 && (clearInterval(o2), a2.stop(this.pendingSubscriptionWatchLabel), n2(new Error("Subscription resolution timeout")));
      }, this.pollingInterval);
    }).catch(() => false), this.on = (i2, s) => {
      this.events.on(i2, s);
    }, this.once = (i2, s) => {
      this.events.once(i2, s);
    }, this.off = (i2, s) => {
      this.events.off(i2, s);
    }, this.removeListener = (i2, s) => {
      this.events.removeListener(i2, s);
    }, this.restart = async () => {
      this.restartInProgress = true, await this.restore(), await this.reset(), this.restartInProgress = false;
    }, this.relayer = e, this.logger = (0, import_logger2.generateChildLogger)(t, this.name), this.clientId = "";
  }
  get context() {
    return (0, import_logger2.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e, t) {
    let i2 = false;
    try {
      i2 = this.getSubscription(e).topic === t;
    } catch {
    }
    return i2;
  }
  onEnable() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, t) {
    const i2 = this.topicMap.get(e);
    await Promise.all(i2.map(async (s) => await this.unsubscribeById(e, s, t)));
  }
  async unsubscribeById(e, t, i2) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: i2 } });
    try {
      const s = mt2(i2);
      await this.rpcUnsubscribe(e, t, s);
      const n2 = U2("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, t, n2), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: i2 } });
    } catch (s) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(s), s;
    }
  }
  async rpcSubscribe(e, t) {
    const i2 = { method: yt2(t.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i2 });
    try {
      await await it2(this.relayer.request(i2), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(D3.connection_stalled);
    }
    return Mn(e + this.clientId);
  }
  async rpcBatchSubscribe(e) {
    if (!e.length)
      return;
    const t = e[0].relay, i2 = { method: yt2(t.protocol).batchSubscribe, params: { topics: e.map((s) => s.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i2 });
    try {
      return await await it2(this.relayer.request(i2), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Payload stalled"), this.relayer.events.emit(D3.connection_stalled);
    }
  }
  rpcUnsubscribe(e, t, i2) {
    const s = { method: yt2(i2.protocol).unsubscribe, params: { topic: e, id: t } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s }), this.relayer.request(s);
  }
  onSubscribe(e, t) {
    this.setSubscription(e, De3(q3({}, t), { id: e })), this.pending.delete(t.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((t) => {
      this.setSubscription(t.id, q3({}, t)), this.pending.delete(t.topic);
    });
  }
  async onUnsubscribe(e, t, i2) {
    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, i2), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, t) {
    this.subscriptions.has(e) || (this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: t }), this.addSubscription(e, t));
  }
  addSubscription(e, t) {
    this.subscriptions.set(e, q3({}, t)), this.topicMap.set(t.topic, e), this.events.emit(w2.created, t);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const t = this.subscriptions.get(e);
    if (!t) {
      const { message: i2 } = N3("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(i2);
    }
    return t;
  }
  deleteSubscription(e, t) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: t });
    const i2 = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(i2.topic, e), this.events.emit(w2.deleted, De3(q3({}, i2), { reason: t }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(w2.sync);
  }
  async reset() {
    if (this.cached.length) {
      const e = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let t = 0; t < e; t++) {
        const i2 = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(i2);
      }
    }
    this.events.emit(w2.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length)
        return;
      if (this.subscriptions.size) {
        const { message: t } = N3("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    if (!e.length)
      return;
    const t = await this.rpcBatchSubscribe(e);
    D2(t) && this.onBatchSubscribe(t.map((i2, s) => De3(q3({}, e[s]), { id: i2 })));
  }
  async onConnect() {
    this.restartInProgress || (await this.restart(), this.onEnable());
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (!this.initialized || this.relayer.transportExplicitlyClosed)
      return;
    const e = [];
    this.pending.forEach((t) => {
      e.push(t);
    }), await this.batchSubscribe(e);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, async () => {
      await this.checkPending();
    }), this.relayer.on(D3.connect, async () => {
      await this.onConnect();
    }), this.relayer.on(D3.disconnect, () => {
      this.onDisconnect();
    }), this.events.on(w2.created, async (e) => {
      const t = w2.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), await this.persist();
    }), this.events.on(w2.deleted, async (e) => {
      const t = w2.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N3("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete() {
    this.restartInProgress && await new Promise((e) => {
      const t = setInterval(() => {
        this.restartInProgress || (clearInterval(t), e());
      }, this.pollingInterval);
    });
  }
};
var Ir = Object.defineProperty;
var At3 = Object.getOwnPropertySymbols;
var Cr2 = Object.prototype.hasOwnProperty;
var Rr2 = Object.prototype.propertyIsEnumerable;
var zt3 = (r, e, t) => e in r ? Ir(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var _r2 = (r, e) => {
  for (var t in e || (e = {}))
    Cr2.call(e, t) && zt3(r, t, e[t]);
  if (At3)
    for (var t of At3(e))
      Rr2.call(e, t) && zt3(r, t, e[t]);
  return r;
};
var Nt3 = class extends g {
  constructor(e) {
    super(e), this.protocol = "wc", this.version = 2, this.events = new import_events4.EventEmitter(), this.name = ct3, this.transportExplicitlyClosed = false, this.initialized = false, this.connectionAttemptInProgress = false, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "socket stalled"], this.hasExperiencedNetworkDisruption = false, this.request = async (t) => {
      this.logger.debug("Publishing Request Payload");
      try {
        return await this.toEstablishConnection(), await this.provider.request(t);
      } catch (i2) {
        throw this.logger.debug("Failed to Publish Request"), this.logger.error(i2), i2;
      }
    }, this.onPayloadHandler = (t) => {
      this.onProviderPayload(t);
    }, this.onConnectHandler = () => {
      this.events.emit(D3.connect);
    }, this.onDisconnectHandler = () => {
      this.onProviderDisconnect();
    }, this.onProviderErrorHandler = (t) => {
      this.logger.error(t), this.events.emit(D3.error, t), this.logger.info("Fatal socket error received, closing transport"), this.transportClose();
    }, this.registerProviderListeners = () => {
      this.provider.on(P.payload, this.onPayloadHandler), this.provider.on(P.connect, this.onConnectHandler), this.provider.on(P.disconnect, this.onDisconnectHandler), this.provider.on(P.error, this.onProviderErrorHandler);
    }, this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? (0, import_logger2.generateChildLogger)(e.logger, this.name) : (0, import_logger2.pino)((0, import_logger2.getDefaultLoggerOptions)({ level: e.logger || ht3 })), this.messages = new Tt2(this.logger, e.core), this.subscriber = new Ot2(this, this.logger), this.publisher = new yr2(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || ge2, this.projectId = e.projectId, this.provider = {};
  }
  async init() {
    this.logger.trace("Initialized"), this.registerEventListeners(), await this.createProvider(), await Promise.all([this.messages.init(), this.subscriber.init()]);
    try {
      await this.transportOpen();
    } catch {
      this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${pe2}...`), await this.restartTransport(pe2);
    }
    this.initialized = true, setTimeout(async () => {
      this.subscriber.topics.length === 0 && (this.logger.info("No topics subscribed to after init, closing transport"), await this.transportClose(), this.transportExplicitlyClosed = false);
    }, gt3);
  }
  get context() {
    return (0, import_logger2.getLoggerContext)(this.logger);
  }
  get connected() {
    return this.provider.connection.connected;
  }
  get connecting() {
    return this.provider.connection.connecting;
  }
  async publish(e, t, i2) {
    this.isInitialized(), await this.publisher.publish(e, t, i2), await this.recordMessageEvent({ topic: e, message: t, publishedAt: Date.now() });
  }
  async subscribe(e, t) {
    var i2;
    this.isInitialized();
    let s = ((i2 = this.subscriber.topicMap.get(e)) == null ? void 0 : i2[0]) || "";
    if (s)
      return s;
    let n2;
    const a2 = (o2) => {
      o2.topic === e && (this.subscriber.off(w2.created, a2), n2());
    };
    return await Promise.all([new Promise((o2) => {
      n2 = o2, this.subscriber.on(w2.created, a2);
    }), new Promise(async (o2) => {
      s = await this.subscriber.subscribe(e, t), o2();
    })]), s;
  }
  async unsubscribe(e, t) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, t);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, this.hasExperiencedNetworkDisruption && this.connected ? await it2(this.provider.disconnect(), 1e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.connected && await this.provider.disconnect();
  }
  async transportOpen(e) {
    if (this.transportExplicitlyClosed = false, await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress) {
      e && e !== this.relayUrl && (this.relayUrl = e, await this.transportClose(), await this.createProvider()), this.connectionAttemptInProgress = true;
      try {
        await Promise.all([new Promise((t) => {
          if (!this.initialized)
            return t();
          this.subscriber.once(w2.resubscribed, () => {
            t();
          });
        }), new Promise(async (t, i2) => {
          try {
            await it2(this.provider.connect(), 1e4, `Socket stalled when trying to connect to ${this.relayUrl}`);
          } catch (s) {
            i2(s);
            return;
          }
          t();
        })]);
      } catch (t) {
        this.logger.error(t);
        const i2 = t;
        if (!this.isConnectionStalled(i2.message))
          throw t;
        this.provider.events.emit(P.disconnect);
      } finally {
        this.connectionAttemptInProgress = false, this.hasExperiencedNetworkDisruption = false;
      }
    }
  }
  async restartTransport(e) {
    await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.transportClose(), await this.createProvider(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await Zt2())
      throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  isConnectionStalled(e) {
    return this.staleConnectionErrors.some((t) => e.includes(t));
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new JsonRpcProvider(new esm_default(Jn({ sdkVersion: dt3, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: true }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e) {
    const { topic: t, message: i2 } = e;
    await this.messages.set(t, i2);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: t, message: i2 } = e;
    if (!i2 || i2.length === 0)
      return this.logger.debug(`Ignoring invalid/empty message: ${i2}`), true;
    if (!await this.subscriber.isSubscribed(t))
      return this.logger.debug(`Ignoring message for non-subscribed topic ${t}`), true;
    const s = this.messages.has(t, i2);
    return s && this.logger.debug(`Ignoring duplicate message: ${i2}`), s;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), isJsonRpcRequest(e)) {
      if (!e.method.endsWith(ut3))
        return;
      const t = e.params, { topic: i2, message: s, publishedAt: n2 } = t.data, a2 = { topic: i2, message: s, publishedAt: n2 };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(_r2({ type: "event", event: t.id }, a2)), this.events.emit(t.id, a2), await this.acknowledgePayload(e), await this.onMessageEvent(a2);
    } else
      isJsonRpcResponse(e) && this.events.emit(D3.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (this.events.emit(D3.message, e), await this.recordMessageEvent(e));
  }
  async acknowledgePayload(e) {
    const t = formatJsonRpcResult(e.id, true);
    await this.provider.connection.send(t);
  }
  unregisterProviderListeners() {
    this.provider.off(P.payload, this.onPayloadHandler), this.provider.off(P.connect, this.onConnectHandler), this.provider.off(P.disconnect, this.onDisconnectHandler), this.provider.off(P.error, this.onProviderErrorHandler);
  }
  async registerEventListeners() {
    this.events.on(D3.connection_stalled, () => {
      this.restartTransport().catch((t) => this.logger.error(t));
    });
    let e = await Zt2();
    Xt2(async (t) => {
      this.initialized && e !== t && (e = t, t ? await this.restartTransport().catch((i2) => this.logger.error(i2)) : (this.hasExperiencedNetworkDisruption = true, await this.transportClose().catch((i2) => this.logger.error(i2))));
    });
  }
  onProviderDisconnect() {
    this.events.emit(D3.disconnect), this.attemptToReconnect();
  }
  attemptToReconnect() {
    this.transportExplicitlyClosed || (this.logger.info("attemptToReconnect called. Connecting..."), setTimeout(async () => {
      await this.restartTransport().catch((e) => this.logger.error(e));
    }, (0, import_time3.toMiliseconds)(lt3)));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N3("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    if (await this.confirmOnlineStateOrThrow(), !this.connected) {
      if (this.connectionAttemptInProgress)
        return await new Promise((e) => {
          const t = setInterval(() => {
            this.connected && (clearInterval(t), e());
          }, this.connectionStatusPollingInterval);
        });
      await this.restartTransport();
    }
  }
};
var Sr2 = Object.defineProperty;
var Ut2 = Object.getOwnPropertySymbols;
var Tr2 = Object.prototype.hasOwnProperty;
var Pr2 = Object.prototype.propertyIsEnumerable;
var Lt3 = (r, e, t) => e in r ? Sr2(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var Ft3 = (r, e) => {
  for (var t in e || (e = {}))
    Tr2.call(e, t) && Lt3(r, t, e[t]);
  if (Ut2)
    for (var t of Ut2(e))
      Pr2.call(e, t) && Lt3(r, t, e[t]);
  return r;
};
var $t4 = class extends p {
  constructor(e, t, i2, s = O3, n2 = void 0) {
    super(e, t, i2, s), this.core = e, this.logger = t, this.name = i2, this.map = /* @__PURE__ */ new Map(), this.version = pt3, this.cached = [], this.initialized = false, this.storagePrefix = O3, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((a2) => {
        this.getKey && a2 !== null && !w(a2) ? this.map.set(this.getKey(a2), a2) : Dt2(a2) ? this.map.set(a2.id, a2) : kt2(a2) && this.map.set(a2.topic, a2);
      }), this.cached = [], this.initialized = true);
    }, this.set = async (a2, o2) => {
      this.isInitialized(), this.map.has(a2) ? await this.update(a2, o2) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: a2, value: o2 }), this.map.set(a2, o2), await this.persist());
    }, this.get = (a2) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: a2 }), this.getData(a2)), this.getAll = (a2) => (this.isInitialized(), a2 ? this.values.filter((o2) => Object.keys(a2).every((h4) => (0, import_lodash.default)(o2[h4], a2[h4]))) : this.values), this.update = async (a2, o2) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: a2, update: o2 });
      const h4 = Ft3(Ft3({}, this.getData(a2)), o2);
      this.map.set(a2, h4), await this.persist();
    }, this.delete = async (a2, o2) => {
      this.isInitialized(), this.map.has(a2) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: a2, reason: o2 }), this.map.delete(a2), await this.persist());
    }, this.logger = (0, import_logger2.generateChildLogger)(t, this.name), this.storagePrefix = s, this.getKey = n2;
  }
  get context() {
    return (0, import_logger2.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const t = this.map.get(e);
    if (!t) {
      const { message: i2 } = N3("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(i2), new Error(i2);
    }
    return t;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length)
        return;
      if (this.map.size) {
        const { message: t } = N3("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N3("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Mt3 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, this.name = ft3, this.version = Et3, this.events = new import_events4.default(), this.initialized = false, this.storagePrefix = O3, this.ignoredPayloadTypes = [_2], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }, this.register = ({ methods: i2 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...i2])];
    }, this.create = async () => {
      this.isInitialized();
      const i2 = Dn(), s = await this.core.crypto.setSymKey(i2), n2 = lt2(import_time3.FIVE_MINUTES), a2 = { protocol: ot2 }, o2 = { topic: s, expiry: n2, relay: a2, active: false }, h4 = Nt2({ protocol: this.core.protocol, version: this.core.version, topic: s, symKey: i2, relay: a2 });
      return await this.pairings.set(s, o2), await this.core.relayer.subscribe(s), this.core.expirer.set(s, n2), { topic: s, uri: h4 };
    }, this.pair = async (i2) => {
      this.isInitialized(), this.isValidPair(i2);
      const { topic: s, symKey: n2, relay: a2 } = bt2(i2.uri);
      let o2;
      if (this.pairings.keys.includes(s) && (o2 = this.pairings.get(s), o2.active))
        throw new Error(`Pairing already exists: ${s}. Please try again with a new connection URI.`);
      this.core.crypto.keychain.has(s) || (await this.core.crypto.setSymKey(n2, s), await this.core.relayer.subscribe(s, { relay: a2 }));
      const h4 = lt2(import_time3.FIVE_MINUTES), u3 = { topic: s, relay: a2, expiry: h4, active: false };
      return await this.pairings.set(s, u3), this.core.expirer.set(s, h4), i2.activatePairing && await this.activate({ topic: s }), this.events.emit(V4.create, u3), u3;
    }, this.activate = async ({ topic: i2 }) => {
      this.isInitialized();
      const s = lt2(import_time3.THIRTY_DAYS);
      await this.pairings.update(i2, { active: true, expiry: s }), this.core.expirer.set(i2, s);
    }, this.ping = async (i2) => {
      this.isInitialized(), await this.isValidPing(i2);
      const { topic: s } = i2;
      if (this.pairings.keys.includes(s)) {
        const n2 = await this.sendRequest(s, "wc_pairingPing", {}), { done: a2, resolve: o2, reject: h4 } = st2();
        this.events.once(ft2("pairing_ping", n2), ({ error: u3 }) => {
          u3 ? h4(u3) : o2();
        }), await a2();
      }
    }, this.updateExpiry = async ({ topic: i2, expiry: s }) => {
      this.isInitialized(), await this.pairings.update(i2, { expiry: s });
    }, this.updateMetadata = async ({ topic: i2, metadata: s }) => {
      this.isInitialized(), await this.pairings.update(i2, { peerMetadata: s });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (i2) => {
      this.isInitialized(), await this.isValidDisconnect(i2);
      const { topic: s } = i2;
      this.pairings.keys.includes(s) && (await this.sendRequest(s, "wc_pairingDelete", U2("USER_DISCONNECTED")), await this.deletePairing(s));
    }, this.sendRequest = async (i2, s, n2) => {
      const a2 = formatJsonRpcRequest(s, n2), o2 = await this.core.crypto.encode(i2, a2), h4 = F3[s].req;
      return this.core.history.set(i2, a2), this.core.relayer.publish(i2, o2, h4), a2.id;
    }, this.sendResult = async (i2, s, n2) => {
      const a2 = formatJsonRpcResult(i2, n2), o2 = await this.core.crypto.encode(s, a2), h4 = await this.core.history.get(s, i2), u3 = F3[h4.request.method].res;
      await this.core.relayer.publish(s, o2, u3), await this.core.history.resolve(a2);
    }, this.sendError = async (i2, s, n2) => {
      const a2 = formatJsonRpcError(i2, n2), o2 = await this.core.crypto.encode(s, a2), h4 = await this.core.history.get(s, i2), u3 = F3[h4.request.method] ? F3[h4.request.method].res : F3.unregistered_method.res;
      await this.core.relayer.publish(s, o2, u3), await this.core.history.resolve(a2);
    }, this.deletePairing = async (i2, s) => {
      await this.core.relayer.unsubscribe(i2), await Promise.all([this.pairings.delete(i2, U2("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(i2), s ? Promise.resolve() : this.core.expirer.del(i2)]);
    }, this.cleanup = async () => {
      const i2 = this.pairings.getAll().filter((s) => dt2(s.expiry));
      await Promise.all(i2.map((s) => this.deletePairing(s.topic)));
    }, this.onRelayEventRequest = (i2) => {
      const { topic: s, payload: n2 } = i2;
      switch (n2.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(s, n2);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(s, n2);
        default:
          return this.onUnknownRpcMethodRequest(s, n2);
      }
    }, this.onRelayEventResponse = async (i2) => {
      const { topic: s, payload: n2 } = i2, a2 = (await this.core.history.get(s, n2.id)).request.method;
      switch (a2) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(s, n2);
        default:
          return this.onUnknownRpcMethodResponse(a2);
      }
    }, this.onPairingPingRequest = async (i2, s) => {
      const { id: n2 } = s;
      try {
        this.isValidPing({ topic: i2 }), await this.sendResult(n2, i2, true), this.events.emit(V4.ping, { id: n2, topic: i2 });
      } catch (a2) {
        await this.sendError(n2, i2, a2), this.logger.error(a2);
      }
    }, this.onPairingPingResponse = (i2, s) => {
      const { id: n2 } = s;
      setTimeout(() => {
        isJsonRpcResult(s) ? this.events.emit(ft2("pairing_ping", n2), {}) : isJsonRpcError(s) && this.events.emit(ft2("pairing_ping", n2), { error: s.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (i2, s) => {
      const { id: n2 } = s;
      try {
        this.isValidDisconnect({ topic: i2 }), await this.deletePairing(i2), this.events.emit(V4.delete, { id: n2, topic: i2 });
      } catch (a2) {
        await this.sendError(n2, i2, a2), this.logger.error(a2);
      }
    }, this.onUnknownRpcMethodRequest = async (i2, s) => {
      const { id: n2, method: a2 } = s;
      try {
        if (this.registeredMethods.includes(a2))
          return;
        const o2 = U2("WC_METHOD_UNSUPPORTED", a2);
        await this.sendError(n2, i2, o2), this.logger.error(o2);
      } catch (o2) {
        await this.sendError(n2, i2, o2), this.logger.error(o2);
      }
    }, this.onUnknownRpcMethodResponse = (i2) => {
      this.registeredMethods.includes(i2) || this.logger.error(U2("WC_METHOD_UNSUPPORTED", i2));
    }, this.isValidPair = (i2) => {
      if (!xt2(i2)) {
        const { message: s } = N3("MISSING_OR_INVALID", `pair() params: ${i2}`);
        throw new Error(s);
      }
      if (!jt3(i2.uri)) {
        const { message: s } = N3("MISSING_OR_INVALID", `pair() uri: ${i2.uri}`);
        throw new Error(s);
      }
    }, this.isValidPing = async (i2) => {
      if (!xt2(i2)) {
        const { message: n2 } = N3("MISSING_OR_INVALID", `ping() params: ${i2}`);
        throw new Error(n2);
      }
      const { topic: s } = i2;
      await this.isValidPairingTopic(s);
    }, this.isValidDisconnect = async (i2) => {
      if (!xt2(i2)) {
        const { message: n2 } = N3("MISSING_OR_INVALID", `disconnect() params: ${i2}`);
        throw new Error(n2);
      }
      const { topic: s } = i2;
      await this.isValidPairingTopic(s);
    }, this.isValidPairingTopic = async (i2) => {
      if (!h3(i2, false)) {
        const { message: s } = N3("MISSING_OR_INVALID", `pairing topic should be a string: ${i2}`);
        throw new Error(s);
      }
      if (!this.pairings.keys.includes(i2)) {
        const { message: s } = N3("NO_MATCHING_KEY", `pairing topic doesn't exist: ${i2}`);
        throw new Error(s);
      }
      if (dt2(this.pairings.get(i2).expiry)) {
        await this.deletePairing(i2);
        const { message: s } = N3("EXPIRED", `pairing topic: ${i2}`);
        throw new Error(s);
      }
    }, this.core = e, this.logger = (0, import_logger2.generateChildLogger)(t, this.name), this.pairings = new $t4(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return (0, import_logger2.getLoggerContext)(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N3("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(D3.message, async (e) => {
      const { topic: t, message: i2 } = e;
      if (!this.pairings.keys.includes(t) || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i2)))
        return;
      const s = await this.core.crypto.decode(t, i2);
      try {
        isJsonRpcRequest(s) ? (this.core.history.set(t, s), this.onRelayEventRequest({ topic: t, payload: s })) : isJsonRpcResponse(s) && (await this.core.history.resolve(s), await this.onRelayEventResponse({ topic: t, payload: s }), this.core.history.delete(t, s.id));
      } catch (n2) {
        this.logger.error(n2);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(v.expired, async (e) => {
      const { topic: t } = ut2(e.target);
      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, true), this.events.emit(V4.expire, { topic: t }));
    });
  }
};
var kt3 = class extends h2 {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, this.records = /* @__PURE__ */ new Map(), this.events = new import_events4.EventEmitter(), this.name = wt2, this.version = vt3, this.cached = [], this.initialized = false, this.storagePrefix = O3, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i2) => this.records.set(i2.id, i2)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.set = (i2, s, n2) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: i2, request: s, chainId: n2 }), this.records.has(s.id))
        return;
      const a2 = { id: s.id, topic: i2, request: { method: s.method, params: s.params || null }, chainId: n2, expiry: lt2(import_time3.THIRTY_DAYS) };
      this.records.set(a2.id, a2), this.events.emit(R3.created, a2);
    }, this.resolve = async (i2) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: i2 }), !this.records.has(i2.id))
        return;
      const s = await this.getRecord(i2.id);
      typeof s.response > "u" && (s.response = isJsonRpcError(i2) ? { error: i2.error } : { result: i2.result }, this.records.set(s.id, s), this.events.emit(R3.updated, s));
    }, this.get = async (i2, s) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: i2, id: s }), await this.getRecord(s)), this.delete = (i2, s) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: s }), this.values.forEach((n2) => {
        if (n2.topic === i2) {
          if (typeof s < "u" && n2.id !== s)
            return;
          this.records.delete(n2.id), this.events.emit(R3.deleted, n2);
        }
      });
    }, this.exists = async (i2, s) => (this.isInitialized(), this.records.has(s) ? (await this.getRecord(s)).topic === i2 : false), this.on = (i2, s) => {
      this.events.on(i2, s);
    }, this.once = (i2, s) => {
      this.events.once(i2, s);
    }, this.off = (i2, s) => {
      this.events.off(i2, s);
    }, this.removeListener = (i2, s) => {
      this.events.removeListener(i2, s);
    }, this.logger = (0, import_logger2.generateChildLogger)(t, this.name);
  }
  get context() {
    return (0, import_logger2.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((t) => {
      if (typeof t.response < "u")
        return;
      const i2 = { topic: t.topic, request: formatJsonRpcRequest(t.request.method, t.request.params, t.id), chainId: t.chainId };
      return e.push(i2);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const t = this.records.get(e);
    if (!t) {
      const { message: i2 } = N3("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(i2);
    }
    return t;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(R3.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length)
        return;
      if (this.records.size) {
        const { message: t } = N3("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(R3.created, (e) => {
      const t = R3.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e }), this.persist();
    }), this.events.on(R3.updated, (e) => {
      const t = R3.updated;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e }), this.persist();
    }), this.events.on(R3.deleted, (e) => {
      const t = R3.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e }), this.persist();
    }), this.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.records.forEach((e) => {
        (0, import_time3.toMiliseconds)(e.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${e.id}`), this.delete(e.topic, e.id));
      });
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N3("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Kt3 = class extends E {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, this.expirations = /* @__PURE__ */ new Map(), this.events = new import_events4.EventEmitter(), this.name = It2, this.version = Ct3, this.cached = [], this.initialized = false, this.storagePrefix = O3, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i2) => this.expirations.set(i2.target, i2)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.has = (i2) => {
      try {
        const s = this.formatTarget(i2);
        return typeof this.getExpiration(s) < "u";
      } catch {
        return false;
      }
    }, this.set = (i2, s) => {
      this.isInitialized();
      const n2 = this.formatTarget(i2), a2 = { target: n2, expiry: s };
      this.expirations.set(n2, a2), this.checkExpiry(n2, a2), this.events.emit(v.created, { target: n2, expiration: a2 });
    }, this.get = (i2) => {
      this.isInitialized();
      const s = this.formatTarget(i2);
      return this.getExpiration(s);
    }, this.del = (i2) => {
      if (this.isInitialized(), this.has(i2)) {
        const s = this.formatTarget(i2), n2 = this.getExpiration(s);
        this.expirations.delete(s), this.events.emit(v.deleted, { target: s, expiration: n2 });
      }
    }, this.on = (i2, s) => {
      this.events.on(i2, s);
    }, this.once = (i2, s) => {
      this.events.once(i2, s);
    }, this.off = (i2, s) => {
      this.events.off(i2, s);
    }, this.removeListener = (i2, s) => {
      this.events.removeListener(i2, s);
    }, this.logger = (0, import_logger2.generateChildLogger)(t, this.name);
  }
  get context() {
    return (0, import_logger2.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string")
      return ct2(e);
    if (typeof e == "number")
      return at2(e);
    const { message: t } = N3("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(t);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(v.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length)
        return;
      if (this.expirations.size) {
        const { message: t } = N3("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const t = this.expirations.get(e);
    if (!t) {
      const { message: i2 } = N3("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(i2), new Error(i2);
    }
    return t;
  }
  checkExpiry(e, t) {
    const { expiry: i2 } = t;
    (0, import_time3.toMiliseconds)(i2) - Date.now() <= 0 && this.expire(e, t);
  }
  expire(e, t) {
    this.expirations.delete(e), this.events.emit(v.expired, { target: e, expiration: t });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()), this.events.on(v.created, (e) => {
      const t = v.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(v.expired, (e) => {
      const t = v.expired;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(v.deleted, (e) => {
      const t = v.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N3("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Bt3 = class extends y {
  constructor(e, t) {
    super(e, t), this.projectId = e, this.logger = t, this.name = Z3, this.initialized = false, this.queue = [], this.verifyDisabled = false, this.init = async (i2) => {
      if (this.verifyDisabled || j2() || !q2())
        return;
      const s = this.getVerifyUrl(i2 == null ? void 0 : i2.verifyUrl);
      this.verifyUrl !== s && this.removeIframe(), this.verifyUrl = s;
      try {
        await this.createIframe();
      } catch (n2) {
        this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(n2);
      }
      if (!this.initialized) {
        this.removeIframe(), this.verifyUrl = ee3;
        try {
          await this.createIframe();
        } catch (n2) {
          this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(n2), this.verifyDisabled = true;
        }
      }
    }, this.register = async (i2) => {
      this.initialized ? this.sendPost(i2.attestationId) : (this.addToQueue(i2.attestationId), await this.init());
    }, this.resolve = async (i2) => {
      if (this.isDevEnv)
        return "";
      const s = this.getVerifyUrl(i2 == null ? void 0 : i2.verifyUrl);
      let n2;
      try {
        n2 = await this.fetchAttestation(i2.attestationId, s);
      } catch (a2) {
        this.logger.info(`failed to resolve attestation: ${i2.attestationId} from url: ${s}`), this.logger.info(a2), n2 = await this.fetchAttestation(i2.attestationId, ee3);
      }
      return n2;
    }, this.fetchAttestation = async (i2, s) => {
      this.logger.info(`resolving attestation: ${i2} from url: ${s}`);
      const n2 = this.startAbortTimer(import_time3.ONE_SECOND * 2), a2 = await fetch(`${s}/attestation/${i2}`, { signal: this.abortController.signal });
      return clearTimeout(n2), a2.status === 200 ? await a2.json() : void 0;
    }, this.addToQueue = (i2) => {
      this.queue.push(i2);
    }, this.processQueue = () => {
      this.queue.length !== 0 && (this.queue.forEach((i2) => this.sendPost(i2)), this.queue = []);
    }, this.sendPost = (i2) => {
      var s;
      try {
        if (!this.iframe)
          return;
        (s = this.iframe.contentWindow) == null || s.postMessage(i2, "*"), this.logger.info(`postMessage sent: ${i2} ${this.verifyUrl}`);
      } catch {
      }
    }, this.createIframe = async () => {
      let i2;
      const s = (n2) => {
        n2.data === "verify_ready" && (this.initialized = true, this.processQueue(), window.removeEventListener("message", s), i2());
      };
      await Promise.race([new Promise((n2) => {
        if (document.getElementById(Z3))
          return n2();
        window.addEventListener("message", s);
        const a2 = document.createElement("iframe");
        a2.id = Z3, a2.src = `${this.verifyUrl}/${this.projectId}`, a2.style.display = "none", document.body.append(a2), this.iframe = a2, i2 = n2;
      }), new Promise((n2, a2) => setTimeout(() => {
        window.removeEventListener("message", s), a2("verify iframe load timeout");
      }, (0, import_time3.toMiliseconds)(import_time3.FIVE_SECONDS)))]);
    }, this.removeIframe = () => {
      this.iframe && (this.iframe.remove(), this.iframe = void 0, this.initialized = false);
    }, this.getVerifyUrl = (i2) => {
      let s = i2 || $3;
      return Rt2.includes(s) || (this.logger.info(`verify url: ${s}, not included in trusted list, assigning default: ${$3}`), s = $3), s;
    }, this.logger = (0, import_logger2.generateChildLogger)(t, this.name), this.verifyUrl = $3, this.abortController = new AbortController(), this.isDevEnv = te2() && import_process.default.env.IS_VITEST;
  }
  get context() {
    return (0, import_logger2.getLoggerContext)(this.logger);
  }
  startAbortTimer(e) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_time3.toMiliseconds)(e));
  }
};
var xr2 = Object.defineProperty;
var Vt3 = Object.getOwnPropertySymbols;
var Or2 = Object.prototype.hasOwnProperty;
var Ar2 = Object.prototype.propertyIsEnumerable;
var qt3 = (r, e, t) => e in r ? xr2(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var jt4 = (r, e) => {
  for (var t in e || (e = {}))
    Or2.call(e, t) && qt3(r, t, e[t]);
  if (Vt3)
    for (var t of Vt3(e))
      Ar2.call(e, t) && qt3(r, t, e[t]);
  return r;
};
var te3 = class extends n {
  constructor(e) {
    super(e), this.protocol = le3, this.version = We3, this.name = Q3, this.events = new import_events4.EventEmitter(), this.initialized = false, this.on = (i2, s) => this.events.on(i2, s), this.once = (i2, s) => this.events.once(i2, s), this.off = (i2, s) => this.events.off(i2, s), this.removeListener = (i2, s) => this.events.removeListener(i2, s), this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || ge2, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
    const t = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : (0, import_logger2.pino)((0, import_logger2.getDefaultLoggerOptions)({ level: (e == null ? void 0 : e.logger) || Xe2.logger }));
    this.logger = (0, import_logger2.generateChildLogger)(t, this.name), this.heartbeat = new import_heartbeat.HeartBeat(), this.crypto = new St2(this, this.logger, e == null ? void 0 : e.keychain), this.history = new kt3(this, this.logger), this.expirer = new Kt3(this, this.logger), this.storage = e != null && e.storage ? e.storage : new h(jt4(jt4({}, Qe2), e == null ? void 0 : e.storageOptions)), this.relayer = new Nt3({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new Mt3(this, this.logger), this.verify = new Bt3(this.projectId || "", this.logger);
  }
  static async init(e) {
    const t = new te3(e);
    await t.initialize();
    const i2 = await t.crypto.getClientId();
    return await t.storage.setItem(Dt3, i2), t;
  }
  get context() {
    return (0, import_logger2.getLoggerContext)(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
};
var zr3 = te3;

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/sign-client/dist/index.es.js
var import_logger3 = __toESM(require_cjs3());
var import_events5 = __toESM(require_events());
var import_time4 = __toESM(require_cjs());
var X3 = "wc";
var F4 = 2;
var H2 = "client";
var G3 = `${X3}@${F4}:${H2}:`;
var M2 = { name: H2, logger: "error", controller: false, relayUrl: "wss://relay.walletconnect.com" };
var W4 = "WALLETCONNECT_DEEPLINK_CHOICE";
var ne2 = "proposal";
var oe2 = "Proposal expired";
var ae3 = "session";
var A2 = import_time4.SEVEN_DAYS;
var ce4 = "engine";
var V5 = { wc_sessionPropose: { req: { ttl: import_time4.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1101 } }, wc_sessionSettle: { req: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: import_time4.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: import_time4.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: import_time4.THIRTY_SECONDS, prompt: false, tag: 1114 }, res: { ttl: import_time4.THIRTY_SECONDS, prompt: false, tag: 1115 } } };
var U4 = { min: import_time4.FIVE_MINUTES, max: import_time4.SEVEN_DAYS };
var I2 = { idle: "IDLE", active: "ACTIVE" };
var le4 = "request";
var pe3 = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest"];
var ns2 = Object.defineProperty;
var os2 = Object.defineProperties;
var as2 = Object.getOwnPropertyDescriptors;
var he4 = Object.getOwnPropertySymbols;
var cs2 = Object.prototype.hasOwnProperty;
var ls2 = Object.prototype.propertyIsEnumerable;
var de4 = (m3, r, e) => r in m3 ? ns2(m3, r, { enumerable: true, configurable: true, writable: true, value: e }) : m3[r] = e;
var g3 = (m3, r) => {
  for (var e in r || (r = {}))
    cs2.call(r, e) && de4(m3, e, r[e]);
  if (he4)
    for (var e of he4(r))
      ls2.call(r, e) && de4(m3, e, r[e]);
  return m3;
};
var b2 = (m3, r) => os2(m3, as2(r));
var ps2 = class extends S2 {
  constructor(r) {
    super(r), this.name = ce4, this.events = new import_events5.default(), this.initialized = false, this.ignoredPayloadTypes = [_2], this.requestQueue = { state: I2.idle, queue: [] }, this.sessionRequestQueue = { state: I2.idle, queue: [] }, this.requestQueueDelay = import_time4.ONE_SECOND, this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({ methods: Object.keys(V5) }), this.initialized = true, setTimeout(() => {
        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, (0, import_time4.toMiliseconds)(this.requestQueueDelay)));
    }, this.connect = async (e) => {
      await this.isInitialized();
      const s = b2(g3({}, e), { requiredNamespaces: e.requiredNamespaces || {}, optionalNamespaces: e.optionalNamespaces || {} });
      await this.isValidConnect(s);
      const { pairingTopic: t, requiredNamespaces: i2, optionalNamespaces: n2, sessionProperties: o2, relays: a2 } = s;
      let c2 = t, p4, d4 = false;
      if (c2 && (d4 = this.client.core.pairing.pairings.get(c2).active), !c2 || !d4) {
        const { topic: v2, uri: S4 } = await this.client.core.pairing.create();
        c2 = v2, p4 = S4;
      }
      const h4 = await this.client.core.crypto.generateKeyPair(), R5 = g3({ requiredNamespaces: i2, optionalNamespaces: n2, relays: a2 != null ? a2 : [{ protocol: ot2 }], proposer: { publicKey: h4, metadata: this.client.metadata } }, o2 && { sessionProperties: o2 }), { reject: w4, resolve: T3, done: K4 } = st2(import_time4.FIVE_MINUTES, oe2);
      if (this.events.once(ft2("session_connect"), async ({ error: v2, session: S4 }) => {
        if (v2)
          w4(v2);
        else if (S4) {
          S4.self.publicKey = h4;
          const B4 = b2(g3({}, S4), { requiredNamespaces: S4.requiredNamespaces, optionalNamespaces: S4.optionalNamespaces });
          await this.client.session.set(S4.topic, B4), await this.setExpiry(S4.topic, S4.expiry), c2 && await this.client.core.pairing.updateMetadata({ topic: c2, metadata: S4.peer.metadata }), T3(B4);
        }
      }), !c2) {
        const { message: v2 } = N3("NO_MATCHING_KEY", `connect() pairing topic: ${c2}`);
        throw new Error(v2);
      }
      const L4 = await this.sendRequest({ topic: c2, method: "wc_sessionPropose", params: R5 }), ue4 = lt2(import_time4.FIVE_MINUTES);
      return await this.setProposal(L4, g3({ id: L4, expiry: ue4 }, R5)), { uri: p4, approval: K4 };
    }, this.pair = async (e) => (await this.isInitialized(), await this.client.core.pairing.pair(e)), this.approve = async (e) => {
      await this.isInitialized(), await this.isValidApprove(e);
      const { id: s, relayProtocol: t, namespaces: i2, sessionProperties: n2 } = e, o2 = this.client.proposal.get(s);
      let { pairingTopic: a2, proposer: c2, requiredNamespaces: p4, optionalNamespaces: d4 } = o2;
      a2 = a2 || "", B2(p4) || (p4 = At2(i2, "approve()"));
      const h4 = await this.client.core.crypto.generateKeyPair(), R5 = c2.publicKey, w4 = await this.client.core.crypto.generateSharedKey(h4, R5);
      a2 && s && (await this.client.core.pairing.updateMetadata({ topic: a2, metadata: c2.metadata }), await this.sendResult({ id: s, topic: a2, result: { relay: { protocol: t != null ? t : "irn" }, responderPublicKey: h4 } }), await this.client.proposal.delete(s, U2("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: a2 }));
      const T3 = g3({ relay: { protocol: t != null ? t : "irn" }, namespaces: i2, requiredNamespaces: p4, optionalNamespaces: d4, pairingTopic: a2, controller: { publicKey: h4, metadata: this.client.metadata }, expiry: lt2(A2) }, n2 && { sessionProperties: n2 });
      await this.client.core.relayer.subscribe(w4), await this.sendRequest({ topic: w4, method: "wc_sessionSettle", params: T3, throwOnFailedPublish: true });
      const K4 = b2(g3({}, T3), { topic: w4, pairingTopic: a2, acknowledged: false, self: T3.controller, peer: { publicKey: c2.publicKey, metadata: c2.metadata }, controller: h4 });
      return await this.client.session.set(w4, K4), await this.setExpiry(w4, lt2(A2)), { topic: w4, acknowledged: () => new Promise((L4) => setTimeout(() => L4(this.client.session.get(w4)), 500)) };
    }, this.reject = async (e) => {
      await this.isInitialized(), await this.isValidReject(e);
      const { id: s, reason: t } = e, { pairingTopic: i2 } = this.client.proposal.get(s);
      i2 && (await this.sendError(s, i2, t), await this.client.proposal.delete(s, U2("USER_DISCONNECTED")));
    }, this.update = async (e) => {
      await this.isInitialized(), await this.isValidUpdate(e);
      const { topic: s, namespaces: t } = e, i2 = await this.sendRequest({ topic: s, method: "wc_sessionUpdate", params: { namespaces: t } }), { done: n2, resolve: o2, reject: a2 } = st2();
      return this.events.once(ft2("session_update", i2), ({ error: c2 }) => {
        c2 ? a2(c2) : o2();
      }), await this.client.session.update(s, { namespaces: t }), { acknowledged: n2 };
    }, this.extend = async (e) => {
      await this.isInitialized(), await this.isValidExtend(e);
      const { topic: s } = e, t = await this.sendRequest({ topic: s, method: "wc_sessionExtend", params: {} }), { done: i2, resolve: n2, reject: o2 } = st2();
      return this.events.once(ft2("session_extend", t), ({ error: a2 }) => {
        a2 ? o2(a2) : n2();
      }), await this.setExpiry(s, lt2(A2)), { acknowledged: i2 };
    }, this.request = async (e) => {
      await this.isInitialized(), await this.isValidRequest(e);
      const { chainId: s, request: t, topic: i2, expiry: n2 } = e, o2 = payloadId(), { done: a2, resolve: c2, reject: p4 } = st2(n2, "Request expired. Please try again.");
      return this.events.once(ft2("session_request", o2), ({ error: d4, result: h4 }) => {
        d4 ? p4(d4) : c2(h4);
      }), await Promise.all([new Promise(async (d4) => {
        await this.sendRequest({ clientRpcId: o2, topic: i2, method: "wc_sessionRequest", params: { request: t, chainId: s }, expiry: n2, throwOnFailedPublish: true }).catch((h4) => p4(h4)), this.client.events.emit("session_request_sent", { topic: i2, request: t, chainId: s, id: o2 }), d4();
      }), new Promise(async (d4) => {
        const h4 = await this.client.core.storage.getItem(W4);
        pt2({ id: o2, topic: i2, wcDeepLink: h4 }), d4();
      }), a2()]).then((d4) => d4[2]);
    }, this.respond = async (e) => {
      await this.isInitialized(), await this.isValidRespond(e);
      const { topic: s, response: t } = e, { id: i2 } = t;
      isJsonRpcResult(t) ? await this.sendResult({ id: i2, topic: s, result: t.result, throwOnFailedPublish: true }) : isJsonRpcError(t) && await this.sendError(i2, s, t.error), this.cleanupAfterResponse(e);
    }, this.ping = async (e) => {
      await this.isInitialized(), await this.isValidPing(e);
      const { topic: s } = e;
      if (this.client.session.keys.includes(s)) {
        const t = await this.sendRequest({ topic: s, method: "wc_sessionPing", params: {} }), { done: i2, resolve: n2, reject: o2 } = st2();
        this.events.once(ft2("session_ping", t), ({ error: a2 }) => {
          a2 ? o2(a2) : n2();
        }), await i2();
      } else
        this.client.core.pairing.pairings.keys.includes(s) && await this.client.core.pairing.ping({ topic: s });
    }, this.emit = async (e) => {
      await this.isInitialized(), await this.isValidEmit(e);
      const { topic: s, event: t, chainId: i2 } = e;
      await this.sendRequest({ topic: s, method: "wc_sessionEvent", params: { event: t, chainId: i2 } });
    }, this.disconnect = async (e) => {
      await this.isInitialized(), await this.isValidDisconnect(e);
      const { topic: s } = e;
      this.client.session.keys.includes(s) ? (await this.sendRequest({ topic: s, method: "wc_sessionDelete", params: U2("USER_DISCONNECTED"), throwOnFailedPublish: true }), await this.deleteSession(s)) : await this.client.core.pairing.disconnect({ topic: s });
    }, this.find = (e) => (this.isInitialized(), this.client.session.getAll().filter((s) => $t3(s, e))), this.getPendingSessionRequests = () => (this.isInitialized(), this.client.pendingRequest.getAll()), this.cleanupDuplicatePairings = async (e) => {
      if (e.pairingTopic)
        try {
          const s = this.client.core.pairing.pairings.get(e.pairingTopic), t = this.client.core.pairing.pairings.getAll().filter((i2) => {
            var n2, o2;
            return ((n2 = i2.peerMetadata) == null ? void 0 : n2.url) && ((o2 = i2.peerMetadata) == null ? void 0 : o2.url) === e.peer.metadata.url && i2.topic && i2.topic !== s.topic;
          });
          if (t.length === 0)
            return;
          this.client.logger.info(`Cleaning up ${t.length} duplicate pairing(s)`), await Promise.all(t.map((i2) => this.client.core.pairing.disconnect({ topic: i2.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
        } catch (s) {
          this.client.logger.error(s);
        }
    }, this.deleteSession = async (e, s) => {
      const { self: t } = this.client.session.get(e);
      await this.client.core.relayer.unsubscribe(e), this.client.session.delete(e, U2("USER_DISCONNECTED")), this.client.core.crypto.keychain.has(t.publicKey) && await this.client.core.crypto.deleteKeyPair(t.publicKey), this.client.core.crypto.keychain.has(e) && await this.client.core.crypto.deleteSymKey(e), s || this.client.core.expirer.del(e), this.client.core.storage.removeItem(W4).catch((i2) => this.client.logger.warn(i2));
    }, this.deleteProposal = async (e, s) => {
      await Promise.all([this.client.proposal.delete(e, U2("USER_DISCONNECTED")), s ? Promise.resolve() : this.client.core.expirer.del(e)]);
    }, this.deletePendingSessionRequest = async (e, s, t = false) => {
      await Promise.all([this.client.pendingRequest.delete(e, s), t ? Promise.resolve() : this.client.core.expirer.del(e)]), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i2) => i2.id !== e), t && (this.sessionRequestQueue.state = I2.idle);
    }, this.setExpiry = async (e, s) => {
      this.client.session.keys.includes(e) && await this.client.session.update(e, { expiry: s }), this.client.core.expirer.set(e, s);
    }, this.setProposal = async (e, s) => {
      await this.client.proposal.set(e, s), this.client.core.expirer.set(e, s.expiry);
    }, this.setPendingSessionRequest = async (e) => {
      const s = V5.wc_sessionRequest.req.ttl, { id: t, topic: i2, params: n2, verifyContext: o2 } = e;
      await this.client.pendingRequest.set(t, { id: t, topic: i2, params: n2, verifyContext: o2 }), s && this.client.core.expirer.set(t, lt2(s));
    }, this.sendRequest = async (e) => {
      const { topic: s, method: t, params: i2, expiry: n2, relayRpcId: o2, clientRpcId: a2, throwOnFailedPublish: c2 } = e, p4 = formatJsonRpcRequest(t, i2, a2);
      if (q2() && pe3.includes(t)) {
        const R5 = Mn(JSON.stringify(p4));
        this.client.core.verify.register({ attestationId: R5 });
      }
      const d4 = await this.client.core.crypto.encode(s, p4), h4 = V5[t].req;
      return n2 && (h4.ttl = n2), o2 && (h4.id = o2), this.client.core.history.set(s, p4), c2 ? (h4.internal = b2(g3({}, h4.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(s, d4, h4)) : this.client.core.relayer.publish(s, d4, h4).catch((R5) => this.client.logger.error(R5)), p4.id;
    }, this.sendResult = async (e) => {
      const { id: s, topic: t, result: i2, throwOnFailedPublish: n2 } = e, o2 = formatJsonRpcResult(s, i2), a2 = await this.client.core.crypto.encode(t, o2), c2 = await this.client.core.history.get(t, s), p4 = V5[c2.request.method].res;
      n2 ? (p4.internal = b2(g3({}, p4.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(t, a2, p4)) : this.client.core.relayer.publish(t, a2, p4).catch((d4) => this.client.logger.error(d4)), await this.client.core.history.resolve(o2);
    }, this.sendError = async (e, s, t) => {
      const i2 = formatJsonRpcError(e, t), n2 = await this.client.core.crypto.encode(s, i2), o2 = await this.client.core.history.get(s, e), a2 = V5[o2.request.method].res;
      this.client.core.relayer.publish(s, n2, a2), await this.client.core.history.resolve(i2);
    }, this.cleanup = async () => {
      const e = [], s = [];
      this.client.session.getAll().forEach((t) => {
        dt2(t.expiry) && e.push(t.topic);
      }), this.client.proposal.getAll().forEach((t) => {
        dt2(t.expiry) && s.push(t.id);
      }), await Promise.all([...e.map((t) => this.deleteSession(t)), ...s.map((t) => this.deleteProposal(t))]);
    }, this.onRelayEventRequest = async (e) => {
      this.requestQueue.queue.push(e), await this.processRequestsQueue();
    }, this.processRequestsQueue = async () => {
      if (this.requestQueue.state === I2.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = I2.active;
        const e = this.requestQueue.queue.shift();
        if (e)
          try {
            this.processRequest(e), await new Promise((s) => setTimeout(s, 300));
          } catch (s) {
            this.client.logger.warn(s);
          }
      }
      this.requestQueue.state = I2.idle;
    }, this.processRequest = (e) => {
      const { topic: s, payload: t } = e, i2 = t.method;
      switch (i2) {
        case "wc_sessionPropose":
          return this.onSessionProposeRequest(s, t);
        case "wc_sessionSettle":
          return this.onSessionSettleRequest(s, t);
        case "wc_sessionUpdate":
          return this.onSessionUpdateRequest(s, t);
        case "wc_sessionExtend":
          return this.onSessionExtendRequest(s, t);
        case "wc_sessionPing":
          return this.onSessionPingRequest(s, t);
        case "wc_sessionDelete":
          return this.onSessionDeleteRequest(s, t);
        case "wc_sessionRequest":
          return this.onSessionRequest(s, t);
        case "wc_sessionEvent":
          return this.onSessionEventRequest(s, t);
        default:
          return this.client.logger.info(`Unsupported request method ${i2}`);
      }
    }, this.onRelayEventResponse = async (e) => {
      const { topic: s, payload: t } = e, i2 = (await this.client.core.history.get(s, t.id)).request.method;
      switch (i2) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(s, t);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(s, t);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(s, t);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(s, t);
        case "wc_sessionPing":
          return this.onSessionPingResponse(s, t);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(s, t);
        default:
          return this.client.logger.info(`Unsupported response method ${i2}`);
      }
    }, this.onRelayEventUnknownPayload = (e) => {
      const { topic: s } = e, { message: t } = N3("MISSING_OR_INVALID", `Decoded payload on topic ${s} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(t);
    }, this.onSessionProposeRequest = async (e, s) => {
      const { params: t, id: i2 } = s;
      try {
        this.isValidConnect(g3({}, s.params));
        const n2 = lt2(import_time4.FIVE_MINUTES), o2 = g3({ id: i2, pairingTopic: e, expiry: n2 }, t);
        await this.setProposal(i2, o2);
        const a2 = Mn(JSON.stringify(s)), c2 = await this.getVerifyContext(a2, o2.proposer.metadata);
        this.client.events.emit("session_proposal", { id: i2, params: o2, verifyContext: c2 });
      } catch (n2) {
        await this.sendError(i2, e, n2), this.client.logger.error(n2);
      }
    }, this.onSessionProposeResponse = async (e, s) => {
      const { id: t } = s;
      if (isJsonRpcResult(s)) {
        const { result: i2 } = s;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: i2 });
        const n2 = this.client.proposal.get(t);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: n2 });
        const o2 = n2.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: o2 });
        const a2 = i2.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: a2 });
        const c2 = await this.client.core.crypto.generateSharedKey(o2, a2);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: c2 });
        const p4 = await this.client.core.relayer.subscribe(c2);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: p4 }), await this.client.core.pairing.activate({ topic: e });
      } else
        isJsonRpcError(s) && (await this.client.proposal.delete(t, U2("USER_DISCONNECTED")), this.events.emit(ft2("session_connect"), { error: s.error }));
    }, this.onSessionSettleRequest = async (e, s) => {
      const { id: t, params: i2 } = s;
      try {
        this.isValidSessionSettleRequest(i2);
        const { relay: n2, controller: o2, expiry: a2, namespaces: c2, requiredNamespaces: p4, optionalNamespaces: d4, sessionProperties: h4, pairingTopic: R5 } = s.params, w4 = g3({ topic: e, relay: n2, expiry: a2, namespaces: c2, acknowledged: true, pairingTopic: R5, requiredNamespaces: p4, optionalNamespaces: d4, controller: o2.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: o2.publicKey, metadata: o2.metadata } }, h4 && { sessionProperties: h4 });
        await this.sendResult({ id: s.id, topic: e, result: true }), this.events.emit(ft2("session_connect"), { session: w4 }), this.cleanupDuplicatePairings(w4);
      } catch (n2) {
        await this.sendError(t, e, n2), this.client.logger.error(n2);
      }
    }, this.onSessionSettleResponse = async (e, s) => {
      const { id: t } = s;
      isJsonRpcResult(s) ? (await this.client.session.update(e, { acknowledged: true }), this.events.emit(ft2("session_approve", t), {})) : isJsonRpcError(s) && (await this.client.session.delete(e, U2("USER_DISCONNECTED")), this.events.emit(ft2("session_approve", t), { error: s.error }));
    }, this.onSessionUpdateRequest = async (e, s) => {
      const { params: t, id: i2 } = s;
      try {
        const n2 = `${e}_session_update`, o2 = er2.get(n2);
        if (o2 && this.isRequestOutOfSync(o2, i2)) {
          this.client.logger.info(`Discarding out of sync request - ${i2}`);
          return;
        }
        this.isValidUpdate(g3({ topic: e }, t)), await this.client.session.update(e, { namespaces: t.namespaces }), await this.sendResult({ id: i2, topic: e, result: true }), this.client.events.emit("session_update", { id: i2, topic: e, params: t }), er2.set(n2, i2);
      } catch (n2) {
        await this.sendError(i2, e, n2), this.client.logger.error(n2);
      }
    }, this.isRequestOutOfSync = (e, s) => parseInt(s.toString().slice(0, -3)) <= parseInt(e.toString().slice(0, -3)), this.onSessionUpdateResponse = (e, s) => {
      const { id: t } = s;
      isJsonRpcResult(s) ? this.events.emit(ft2("session_update", t), {}) : isJsonRpcError(s) && this.events.emit(ft2("session_update", t), { error: s.error });
    }, this.onSessionExtendRequest = async (e, s) => {
      const { id: t } = s;
      try {
        this.isValidExtend({ topic: e }), await this.setExpiry(e, lt2(A2)), await this.sendResult({ id: t, topic: e, result: true }), this.client.events.emit("session_extend", { id: t, topic: e });
      } catch (i2) {
        await this.sendError(t, e, i2), this.client.logger.error(i2);
      }
    }, this.onSessionExtendResponse = (e, s) => {
      const { id: t } = s;
      isJsonRpcResult(s) ? this.events.emit(ft2("session_extend", t), {}) : isJsonRpcError(s) && this.events.emit(ft2("session_extend", t), { error: s.error });
    }, this.onSessionPingRequest = async (e, s) => {
      const { id: t } = s;
      try {
        this.isValidPing({ topic: e }), await this.sendResult({ id: t, topic: e, result: true }), this.client.events.emit("session_ping", { id: t, topic: e });
      } catch (i2) {
        await this.sendError(t, e, i2), this.client.logger.error(i2);
      }
    }, this.onSessionPingResponse = (e, s) => {
      const { id: t } = s;
      setTimeout(() => {
        isJsonRpcResult(s) ? this.events.emit(ft2("session_ping", t), {}) : isJsonRpcError(s) && this.events.emit(ft2("session_ping", t), { error: s.error });
      }, 500);
    }, this.onSessionDeleteRequest = async (e, s) => {
      const { id: t } = s;
      try {
        this.isValidDisconnect({ topic: e, reason: s.params }), await Promise.all([new Promise((i2) => {
          this.client.core.relayer.once(D3.publish, async () => {
            i2(await this.deleteSession(e));
          });
        }), this.sendResult({ id: t, topic: e, result: true })]), this.client.events.emit("session_delete", { id: t, topic: e });
      } catch (i2) {
        this.client.logger.error(i2);
      }
    }, this.onSessionRequest = async (e, s) => {
      const { id: t, params: i2 } = s;
      try {
        this.isValidRequest(g3({ topic: e }, i2));
        const n2 = Mn(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", i2, t))), o2 = this.client.session.get(e), a2 = await this.getVerifyContext(n2, o2.peer.metadata), c2 = { id: t, topic: e, params: i2, verifyContext: a2 };
        await this.setPendingSessionRequest(c2), this.addSessionRequestToSessionRequestQueue(c2), this.processSessionRequestQueue();
      } catch (n2) {
        await this.sendError(t, e, n2), this.client.logger.error(n2);
      }
    }, this.onSessionRequestResponse = (e, s) => {
      const { id: t } = s;
      isJsonRpcResult(s) ? this.events.emit(ft2("session_request", t), { result: s.result }) : isJsonRpcError(s) && this.events.emit(ft2("session_request", t), { error: s.error });
    }, this.onSessionEventRequest = async (e, s) => {
      const { id: t, params: i2 } = s;
      try {
        const n2 = `${e}_session_event_${i2.event.name}`, o2 = er2.get(n2);
        if (o2 && this.isRequestOutOfSync(o2, t)) {
          this.client.logger.info(`Discarding out of sync request - ${t}`);
          return;
        }
        this.isValidEmit(g3({ topic: e }, i2)), this.client.events.emit("session_event", { id: t, topic: e, params: i2 }), er2.set(n2, t);
      } catch (n2) {
        await this.sendError(t, e, n2), this.client.logger.error(n2);
      }
    }, this.addSessionRequestToSessionRequestQueue = (e) => {
      this.sessionRequestQueue.queue.push(e);
    }, this.cleanupAfterResponse = (e) => {
      this.deletePendingSessionRequest(e.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = I2.idle, this.processSessionRequestQueue();
      }, (0, import_time4.toMiliseconds)(this.requestQueueDelay));
    }, this.processSessionRequestQueue = () => {
      if (this.sessionRequestQueue.state === I2.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const e = this.sessionRequestQueue.queue[0];
      if (!e) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = I2.active, this.client.events.emit("session_request", e);
      } catch (s) {
        this.client.logger.error(s);
      }
    }, this.onPairingCreated = (e) => {
      if (e.active)
        return;
      const s = this.client.proposal.getAll().find((t) => t.pairingTopic === e.topic);
      s && this.onSessionProposeRequest(e.topic, formatJsonRpcRequest("wc_sessionPropose", { requiredNamespaces: s.requiredNamespaces, optionalNamespaces: s.optionalNamespaces, relays: s.relays, proposer: s.proposer }, s.id));
    }, this.isValidConnect = async (e) => {
      if (!xt2(e)) {
        const { message: a2 } = N3("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(e)}`);
        throw new Error(a2);
      }
      const { pairingTopic: s, requiredNamespaces: t, optionalNamespaces: i2, sessionProperties: n2, relays: o2 } = e;
      if (w(s) || await this.isValidPairingTopic(s), !Kt2(o2, true)) {
        const { message: a2 } = N3("MISSING_OR_INVALID", `connect() relays: ${o2}`);
        throw new Error(a2);
      }
      !w(t) && B2(t) !== 0 && this.validateNamespaces(t, "requiredNamespaces"), !w(i2) && B2(i2) !== 0 && this.validateNamespaces(i2, "optionalNamespaces"), w(n2) || this.validateSessionProps(n2, "sessionProperties");
    }, this.validateNamespaces = (e, s) => {
      const t = Mt2(e, "connect()", s);
      if (t)
        throw new Error(t.message);
    }, this.isValidApprove = async (e) => {
      if (!xt2(e))
        throw new Error(N3("MISSING_OR_INVALID", `approve() params: ${e}`).message);
      const { id: s, namespaces: t, relayProtocol: i2, sessionProperties: n2 } = e;
      await this.isValidProposalId(s);
      const o2 = this.client.proposal.get(s), a2 = cn(t, "approve()");
      if (a2)
        throw new Error(a2.message);
      const c2 = un(o2.requiredNamespaces, t, "approve()");
      if (c2)
        throw new Error(c2.message);
      if (!h3(i2, true)) {
        const { message: p4 } = N3("MISSING_OR_INVALID", `approve() relayProtocol: ${i2}`);
        throw new Error(p4);
      }
      w(n2) || this.validateSessionProps(n2, "sessionProperties");
    }, this.isValidReject = async (e) => {
      if (!xt2(e)) {
        const { message: i2 } = N3("MISSING_OR_INVALID", `reject() params: ${e}`);
        throw new Error(i2);
      }
      const { id: s, reason: t } = e;
      if (await this.isValidProposalId(s), !Ft2(t)) {
        const { message: i2 } = N3("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(t)}`);
        throw new Error(i2);
      }
    }, this.isValidSessionSettleRequest = (e) => {
      if (!xt2(e)) {
        const { message: c2 } = N3("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${e}`);
        throw new Error(c2);
      }
      const { relay: s, controller: t, namespaces: i2, expiry: n2 } = e;
      if (!an(s)) {
        const { message: c2 } = N3("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(c2);
      }
      const o2 = Vt2(t, "onSessionSettleRequest()");
      if (o2)
        throw new Error(o2.message);
      const a2 = cn(i2, "onSessionSettleRequest()");
      if (a2)
        throw new Error(a2.message);
      if (dt2(n2)) {
        const { message: c2 } = N3("EXPIRED", "onSessionSettleRequest()");
        throw new Error(c2);
      }
    }, this.isValidUpdate = async (e) => {
      if (!xt2(e)) {
        const { message: a2 } = N3("MISSING_OR_INVALID", `update() params: ${e}`);
        throw new Error(a2);
      }
      const { topic: s, namespaces: t } = e;
      await this.isValidSessionTopic(s);
      const i2 = this.client.session.get(s), n2 = cn(t, "update()");
      if (n2)
        throw new Error(n2.message);
      const o2 = un(i2.requiredNamespaces, t, "update()");
      if (o2)
        throw new Error(o2.message);
    }, this.isValidExtend = async (e) => {
      if (!xt2(e)) {
        const { message: t } = N3("MISSING_OR_INVALID", `extend() params: ${e}`);
        throw new Error(t);
      }
      const { topic: s } = e;
      await this.isValidSessionTopic(s);
    }, this.isValidRequest = async (e) => {
      if (!xt2(e)) {
        const { message: a2 } = N3("MISSING_OR_INVALID", `request() params: ${e}`);
        throw new Error(a2);
      }
      const { topic: s, request: t, chainId: i2, expiry: n2 } = e;
      await this.isValidSessionTopic(s);
      const { namespaces: o2 } = this.client.session.get(s);
      if (!Gt2(o2, i2)) {
        const { message: a2 } = N3("MISSING_OR_INVALID", `request() chainId: ${i2}`);
        throw new Error(a2);
      }
      if (!Ht2(t)) {
        const { message: a2 } = N3("MISSING_OR_INVALID", `request() ${JSON.stringify(t)}`);
        throw new Error(a2);
      }
      if (!Wt2(o2, i2, t.method)) {
        const { message: a2 } = N3("MISSING_OR_INVALID", `request() method: ${t.method}`);
        throw new Error(a2);
      }
      if (n2 && !Qt3(n2, U4)) {
        const { message: a2 } = N3("MISSING_OR_INVALID", `request() expiry: ${n2}. Expiry must be a number (in seconds) between ${U4.min} and ${U4.max}`);
        throw new Error(a2);
      }
    }, this.isValidRespond = async (e) => {
      if (!xt2(e)) {
        const { message: i2 } = N3("MISSING_OR_INVALID", `respond() params: ${e}`);
        throw new Error(i2);
      }
      const { topic: s, response: t } = e;
      if (await this.isValidSessionTopic(s), !qt2(t)) {
        const { message: i2 } = N3("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(t)}`);
        throw new Error(i2);
      }
    }, this.isValidPing = async (e) => {
      if (!xt2(e)) {
        const { message: t } = N3("MISSING_OR_INVALID", `ping() params: ${e}`);
        throw new Error(t);
      }
      const { topic: s } = e;
      await this.isValidSessionOrPairingTopic(s);
    }, this.isValidEmit = async (e) => {
      if (!xt2(e)) {
        const { message: o2 } = N3("MISSING_OR_INVALID", `emit() params: ${e}`);
        throw new Error(o2);
      }
      const { topic: s, event: t, chainId: i2 } = e;
      await this.isValidSessionTopic(s);
      const { namespaces: n2 } = this.client.session.get(s);
      if (!Gt2(n2, i2)) {
        const { message: o2 } = N3("MISSING_OR_INVALID", `emit() chainId: ${i2}`);
        throw new Error(o2);
      }
      if (!Bt2(t)) {
        const { message: o2 } = N3("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(t)}`);
        throw new Error(o2);
      }
      if (!zt2(n2, i2, t.name)) {
        const { message: o2 } = N3("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(t)}`);
        throw new Error(o2);
      }
    }, this.isValidDisconnect = async (e) => {
      if (!xt2(e)) {
        const { message: t } = N3("MISSING_OR_INVALID", `disconnect() params: ${e}`);
        throw new Error(t);
      }
      const { topic: s } = e;
      await this.isValidSessionOrPairingTopic(s);
    }, this.getVerifyContext = async (e, s) => {
      const t = { verified: { verifyUrl: s.verifyUrl || $3, validation: "UNKNOWN", origin: s.url || "" } };
      try {
        const i2 = await this.client.core.verify.resolve({ attestationId: e, verifyUrl: s.verifyUrl });
        i2 && (t.verified.origin = i2.origin, t.verified.isScam = i2.isScam, t.verified.validation = i2.origin === new URL(s.url).origin ? "VALID" : "INVALID");
      } catch (i2) {
        this.client.logger.info(i2);
      }
      return this.client.logger.info(`Verify context: ${JSON.stringify(t)}`), t;
    }, this.validateSessionProps = (e, s) => {
      Object.values(e).forEach((t) => {
        if (!h3(t, false)) {
          const { message: i2 } = N3("MISSING_OR_INVALID", `${s} must be in Record<string, string> format. Received: ${JSON.stringify(t)}`);
          throw new Error(i2);
        }
      });
    };
  }
  async isInitialized() {
    if (!this.initialized) {
      const { message: r } = N3("NOT_INITIALIZED", this.name);
      throw new Error(r);
    }
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(D3.message, async (r) => {
      const { topic: e, message: s } = r;
      if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(s)))
        return;
      const t = await this.client.core.crypto.decode(e, s);
      try {
        isJsonRpcRequest(t) ? (this.client.core.history.set(e, t), this.onRelayEventRequest({ topic: e, payload: t })) : isJsonRpcResponse(t) ? (await this.client.core.history.resolve(t), await this.onRelayEventResponse({ topic: e, payload: t }), this.client.core.history.delete(e, t.id)) : this.onRelayEventUnknownPayload({ topic: e, payload: t });
      } catch (i2) {
        this.client.logger.error(i2);
      }
    });
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(v.expired, async (r) => {
      const { topic: e, id: s } = ut2(r.target);
      if (s && this.client.pendingRequest.keys.includes(s))
        return await this.deletePendingSessionRequest(s, N3("EXPIRED"), true);
      e ? this.client.session.keys.includes(e) && (await this.deleteSession(e, true), this.client.events.emit("session_expire", { topic: e })) : s && (await this.deleteProposal(s, true), this.client.events.emit("proposal_expire", { id: s }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(V4.create, (r) => this.onPairingCreated(r));
  }
  isValidPairingTopic(r) {
    if (!h3(r, false)) {
      const { message: e } = N3("MISSING_OR_INVALID", `pairing topic should be a string: ${r}`);
      throw new Error(e);
    }
    if (!this.client.core.pairing.pairings.keys.includes(r)) {
      const { message: e } = N3("NO_MATCHING_KEY", `pairing topic doesn't exist: ${r}`);
      throw new Error(e);
    }
    if (dt2(this.client.core.pairing.pairings.get(r).expiry)) {
      const { message: e } = N3("EXPIRED", `pairing topic: ${r}`);
      throw new Error(e);
    }
  }
  async isValidSessionTopic(r) {
    if (!h3(r, false)) {
      const { message: e } = N3("MISSING_OR_INVALID", `session topic should be a string: ${r}`);
      throw new Error(e);
    }
    if (!this.client.session.keys.includes(r)) {
      const { message: e } = N3("NO_MATCHING_KEY", `session topic doesn't exist: ${r}`);
      throw new Error(e);
    }
    if (dt2(this.client.session.get(r).expiry)) {
      await this.deleteSession(r);
      const { message: e } = N3("EXPIRED", `session topic: ${r}`);
      throw new Error(e);
    }
  }
  async isValidSessionOrPairingTopic(r) {
    if (this.client.session.keys.includes(r))
      await this.isValidSessionTopic(r);
    else if (this.client.core.pairing.pairings.keys.includes(r))
      this.isValidPairingTopic(r);
    else if (h3(r, false)) {
      const { message: e } = N3("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${r}`);
      throw new Error(e);
    } else {
      const { message: e } = N3("MISSING_OR_INVALID", `session or pairing topic should be a string: ${r}`);
      throw new Error(e);
    }
  }
  async isValidProposalId(r) {
    if (!Lt2(r)) {
      const { message: e } = N3("MISSING_OR_INVALID", `proposal id should be a number: ${r}`);
      throw new Error(e);
    }
    if (!this.client.proposal.keys.includes(r)) {
      const { message: e } = N3("NO_MATCHING_KEY", `proposal id doesn't exist: ${r}`);
      throw new Error(e);
    }
    if (dt2(this.client.proposal.get(r).expiry)) {
      await this.deleteProposal(r);
      const { message: e } = N3("EXPIRED", `proposal id: ${r}`);
      throw new Error(e);
    }
  }
};
var hs2 = class extends $t4 {
  constructor(r, e) {
    super(r, e, ne2, G3), this.core = r, this.logger = e;
  }
};
var ds2 = class extends $t4 {
  constructor(r, e) {
    super(r, e, ae3, G3), this.core = r, this.logger = e;
  }
};
var us2 = class extends $t4 {
  constructor(r, e) {
    super(r, e, le4, G3, (s) => s.id), this.core = r, this.logger = e;
  }
};
var Q4 = class extends b {
  constructor(r) {
    super(r), this.protocol = X3, this.version = F4, this.name = M2.name, this.events = new import_events5.EventEmitter(), this.on = (s, t) => this.events.on(s, t), this.once = (s, t) => this.events.once(s, t), this.off = (s, t) => this.events.off(s, t), this.removeListener = (s, t) => this.events.removeListener(s, t), this.removeAllListeners = (s) => this.events.removeAllListeners(s), this.connect = async (s) => {
      try {
        return await this.engine.connect(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.pair = async (s) => {
      try {
        return await this.engine.pair(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.approve = async (s) => {
      try {
        return await this.engine.approve(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.reject = async (s) => {
      try {
        return await this.engine.reject(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.update = async (s) => {
      try {
        return await this.engine.update(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.extend = async (s) => {
      try {
        return await this.engine.extend(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.request = async (s) => {
      try {
        return await this.engine.request(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.respond = async (s) => {
      try {
        return await this.engine.respond(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.ping = async (s) => {
      try {
        return await this.engine.ping(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.emit = async (s) => {
      try {
        return await this.engine.emit(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.disconnect = async (s) => {
      try {
        return await this.engine.disconnect(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.find = (s) => {
      try {
        return this.engine.find(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.name = (r == null ? void 0 : r.name) || M2.name, this.metadata = (r == null ? void 0 : r.metadata) || zn();
    const e = typeof (r == null ? void 0 : r.logger) < "u" && typeof (r == null ? void 0 : r.logger) != "string" ? r.logger : (0, import_logger3.pino)((0, import_logger3.getDefaultLoggerOptions)({ level: (r == null ? void 0 : r.logger) || M2.logger }));
    this.core = (r == null ? void 0 : r.core) || new zr3(r), this.logger = (0, import_logger3.generateChildLogger)(e, this.name), this.session = new ds2(this.core, this.logger), this.proposal = new hs2(this.core, this.logger), this.pendingRequest = new us2(this.core, this.logger), this.engine = new ps2(this);
  }
  static async init(r) {
    const e = new Q4(r);
    return await e.initialize(), e;
  }
  get context() {
    return (0, import_logger3.getLoggerContext)(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.core.verify.init({ verifyUrl: this.metadata.verifyUrl }), this.logger.info("SignClient Initialization Success");
    } catch (r) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(r.message), r;
    }
  }
};
var gs2 = Q4;

// node_modules/@walletconnect/web3wallet/dist/index.es.js
var l = { exports: {} };
var u2 = typeof Reflect == "object" ? Reflect : null;
var m2 = u2 && typeof u2.apply == "function" ? u2.apply : function(t, e, n2) {
  return Function.prototype.apply.call(t, e, n2);
};
var f2;
u2 && typeof u2.ownKeys == "function" ? f2 = u2.ownKeys : Object.getOwnPropertySymbols ? f2 = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : f2 = function(t) {
  return Object.getOwnPropertyNames(t);
};
function T2(s) {
  console && console.warn && console.warn(s);
}
var y3 = Number.isNaN || function(t) {
  return t !== t;
};
function o() {
  o.init.call(this);
}
l.exports = o, l.exports.once = M3, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;
var w3 = 10;
function g4(s) {
  if (typeof s != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof s);
}
Object.defineProperty(o, "defaultMaxListeners", { enumerable: true, get: function() {
  return w3;
}, set: function(s) {
  if (typeof s != "number" || s < 0 || y3(s))
    throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + s + ".");
  w3 = s;
} }), o.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, o.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || y3(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function L3(s) {
  return s._maxListeners === void 0 ? o.defaultMaxListeners : s._maxListeners;
}
o.prototype.getMaxListeners = function() {
  return L3(this);
}, o.prototype.emit = function(t) {
  for (var e = [], n2 = 1; n2 < arguments.length; n2++)
    e.push(arguments[n2]);
  var i2 = t === "error", a2 = this._events;
  if (a2 !== void 0)
    i2 = i2 && a2.error === void 0;
  else if (!i2)
    return false;
  if (i2) {
    var r;
    if (e.length > 0 && (r = e[0]), r instanceof Error)
      throw r;
    var h4 = new Error("Unhandled error." + (r ? " (" + r.message + ")" : ""));
    throw h4.context = r, h4;
  }
  var c2 = a2[t];
  if (c2 === void 0)
    return false;
  if (typeof c2 == "function")
    m2(c2, this, e);
  else
    for (var v2 = c2.length, A3 = b3(c2, v2), n2 = 0; n2 < v2; ++n2)
      m2(A3[n2], this, e);
  return true;
};
function _3(s, t, e, n2) {
  var i2, a2, r;
  if (g4(e), a2 = s._events, a2 === void 0 ? (a2 = s._events = /* @__PURE__ */ Object.create(null), s._eventsCount = 0) : (a2.newListener !== void 0 && (s.emit("newListener", t, e.listener ? e.listener : e), a2 = s._events), r = a2[t]), r === void 0)
    r = a2[t] = e, ++s._eventsCount;
  else if (typeof r == "function" ? r = a2[t] = n2 ? [e, r] : [r, e] : n2 ? r.unshift(e) : r.push(e), i2 = L3(s), i2 > 0 && r.length > i2 && !r.warned) {
    r.warned = true;
    var h4 = new Error("Possible EventEmitter memory leak detected. " + r.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    h4.name = "MaxListenersExceededWarning", h4.emitter = s, h4.type = t, h4.count = r.length, T2(h4);
  }
  return s;
}
o.prototype.addListener = function(t, e) {
  return _3(this, t, e, false);
}, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function(t, e) {
  return _3(this, t, e, true);
};
function j3() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function S3(s, t, e) {
  var n2 = { fired: false, wrapFn: void 0, target: s, type: t, listener: e }, i2 = j3.bind(n2);
  return i2.listener = e, n2.wrapFn = i2, i2;
}
o.prototype.once = function(t, e) {
  return g4(e), this.on(t, S3(this, t, e)), this;
}, o.prototype.prependOnceListener = function(t, e) {
  return g4(e), this.prependListener(t, S3(this, t, e)), this;
}, o.prototype.removeListener = function(t, e) {
  var n2, i2, a2, r, h4;
  if (g4(e), i2 = this._events, i2 === void 0)
    return this;
  if (n2 = i2[t], n2 === void 0)
    return this;
  if (n2 === e || n2.listener === e)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i2[t], i2.removeListener && this.emit("removeListener", t, n2.listener || e));
  else if (typeof n2 != "function") {
    for (a2 = -1, r = n2.length - 1; r >= 0; r--)
      if (n2[r] === e || n2[r].listener === e) {
        h4 = n2[r].listener, a2 = r;
        break;
      }
    if (a2 < 0)
      return this;
    a2 === 0 ? n2.shift() : I3(n2, a2), n2.length === 1 && (i2[t] = n2[0]), i2.removeListener !== void 0 && this.emit("removeListener", t, h4 || e);
  }
  return this;
}, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function(t) {
  var e, n2, i2;
  if (n2 = this._events, n2 === void 0)
    return this;
  if (n2.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n2[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n2[t]), this;
  if (arguments.length === 0) {
    var a2 = Object.keys(n2), r;
    for (i2 = 0; i2 < a2.length; ++i2)
      r = a2[i2], r !== "removeListener" && this.removeAllListeners(r);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (e = n2[t], typeof e == "function")
    this.removeListener(t, e);
  else if (e !== void 0)
    for (i2 = e.length - 1; i2 >= 0; i2--)
      this.removeListener(t, e[i2]);
  return this;
};
function C(s, t, e) {
  var n2 = s._events;
  if (n2 === void 0)
    return [];
  var i2 = n2[t];
  return i2 === void 0 ? [] : typeof i2 == "function" ? e ? [i2.listener || i2] : [i2] : e ? W5(i2) : b3(i2, i2.length);
}
o.prototype.listeners = function(t) {
  return C(this, t, true);
}, o.prototype.rawListeners = function(t) {
  return C(this, t, false);
}, o.listenerCount = function(s, t) {
  return typeof s.listenerCount == "function" ? s.listenerCount(t) : E3.call(s, t);
}, o.prototype.listenerCount = E3;
function E3(s) {
  var t = this._events;
  if (t !== void 0) {
    var e = t[s];
    if (typeof e == "function")
      return 1;
    if (e !== void 0)
      return e.length;
  }
  return 0;
}
o.prototype.eventNames = function() {
  return this._eventsCount > 0 ? f2(this._events) : [];
};
function b3(s, t) {
  for (var e = new Array(t), n2 = 0; n2 < t; ++n2)
    e[n2] = s[n2];
  return e;
}
function I3(s, t) {
  for (; t + 1 < s.length; t++)
    s[t] = s[t + 1];
  s.pop();
}
function W5(s) {
  for (var t = new Array(s.length), e = 0; e < t.length; ++e)
    t[e] = s[e].listener || s[e];
  return t;
}
function M3(s, t) {
  return new Promise(function(e, n2) {
    function i2(r) {
      s.removeListener(t, a2), n2(r);
    }
    function a2() {
      typeof s.removeListener == "function" && s.removeListener("error", i2), e([].slice.call(arguments));
    }
    R4(s, t, a2, { once: true }), t !== "error" && z2(s, i2, { once: true });
  });
}
function z2(s, t, e) {
  typeof s.on == "function" && R4(s, "error", t, e);
}
function R4(s, t, e, n2) {
  if (typeof s.on == "function")
    n2.once ? s.once(t, e) : s.on(t, e);
  else if (typeof s.addEventListener == "function")
    s.addEventListener(t, function i2(a2) {
      n2.once && s.removeEventListener(t, i2), e(a2);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof s);
}
var O5 = "wc";
var d3 = "Web3Wallet";
var K3 = `${O5}@2:${d3}:`;
var X4 = class extends l.exports {
  constructor() {
    super();
  }
};
var x3 = class {
  constructor(t) {
    this.opts = t;
  }
};
var P2 = class {
  constructor(t) {
    this.client = t;
  }
};
var D4 = class extends P2 {
  constructor(t) {
    super(t), this.init = async () => {
      this.signClient = await gs2.init({ core: this.client.core, metadata: this.client.metadata }), this.authClient = await zr2.init({ core: this.client.core, projectId: "", metadata: this.client.metadata }), this.initializeEventListeners();
    }, this.pair = async (e) => {
      await this.client.core.pairing.pair(e);
    }, this.approveSession = async (e) => {
      const { topic: n2, acknowledged: i2 } = await this.signClient.approve({ id: e.id, namespaces: e.namespaces });
      return await i2(), this.signClient.session.get(n2);
    }, this.rejectSession = async (e) => await this.signClient.reject(e), this.updateSession = async (e) => await (await this.signClient.update(e)).acknowledged(), this.extendSession = async (e) => await (await this.signClient.extend(e)).acknowledged(), this.respondSessionRequest = async (e) => await this.signClient.respond(e), this.disconnectSession = async (e) => await this.signClient.disconnect(e), this.emitSessionEvent = async (e) => await this.signClient.emit(e), this.getActiveSessions = () => this.signClient.session.getAll().reduce((e, n2) => (e[n2.topic] = n2, e), {}), this.getPendingSessionProposals = () => this.signClient.proposal.getAll(), this.getPendingSessionRequests = () => this.signClient.getPendingSessionRequests(), this.respondAuthRequest = async (e, n2) => await this.authClient.respond(e, n2), this.getPendingAuthRequests = () => this.authClient.requests.getAll().filter((e) => "requester" in e), this.formatMessage = (e, n2) => this.authClient.formatMessage(e, n2), this.onSessionRequest = (e) => {
      this.client.events.emit("session_request", e);
    }, this.onSessionProposal = (e) => {
      this.client.events.emit("session_proposal", e);
    }, this.onSessionDelete = (e) => {
      this.client.events.emit("session_delete", e);
    }, this.onAuthRequest = (e) => {
      this.client.events.emit("auth_request", e);
    }, this.initializeEventListeners = () => {
      this.signClient.events.on("session_proposal", this.onSessionProposal), this.signClient.events.on("session_request", this.onSessionRequest), this.signClient.events.on("session_delete", this.onSessionDelete), this.authClient.on("auth_request", this.onAuthRequest);
    }, this.signClient = {}, this.authClient = {};
  }
};
var p3 = class extends x3 {
  constructor(t) {
    super(t), this.events = new l.exports(), this.on = (e, n2) => this.events.on(e, n2), this.once = (e, n2) => this.events.once(e, n2), this.off = (e, n2) => this.events.off(e, n2), this.removeListener = (e, n2) => this.events.removeListener(e, n2), this.pair = async (e) => {
      try {
        return await this.engine.pair(e);
      } catch (n2) {
        throw this.logger.error(n2.message), n2;
      }
    }, this.approveSession = async (e) => {
      try {
        return await this.engine.approveSession(e);
      } catch (n2) {
        throw this.logger.error(n2.message), n2;
      }
    }, this.rejectSession = async (e) => {
      try {
        return await this.engine.rejectSession(e);
      } catch (n2) {
        throw this.logger.error(n2.message), n2;
      }
    }, this.updateSession = async (e) => {
      try {
        return await this.engine.updateSession(e);
      } catch (n2) {
        throw this.logger.error(n2.message), n2;
      }
    }, this.extendSession = async (e) => {
      try {
        return await this.engine.extendSession(e);
      } catch (n2) {
        throw this.logger.error(n2.message), n2;
      }
    }, this.respondSessionRequest = async (e) => {
      try {
        return await this.engine.respondSessionRequest(e);
      } catch (n2) {
        throw this.logger.error(n2.message), n2;
      }
    }, this.disconnectSession = async (e) => {
      try {
        return await this.engine.disconnectSession(e);
      } catch (n2) {
        throw this.logger.error(n2.message), n2;
      }
    }, this.emitSessionEvent = async (e) => {
      try {
        return await this.engine.emitSessionEvent(e);
      } catch (n2) {
        throw this.logger.error(n2.message), n2;
      }
    }, this.getActiveSessions = () => {
      try {
        return this.engine.getActiveSessions();
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.getPendingSessionProposals = () => {
      try {
        return this.engine.getPendingSessionProposals();
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.respondAuthRequest = async (e, n2) => {
      try {
        return await this.engine.respondAuthRequest(e, n2);
      } catch (i2) {
        throw this.logger.error(i2.message), i2;
      }
    }, this.getPendingAuthRequests = () => {
      try {
        return this.engine.getPendingAuthRequests();
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.formatMessage = (e, n2) => {
      try {
        return this.engine.formatMessage(e, n2);
      } catch (i2) {
        throw this.logger.error(i2.message), i2;
      }
    }, this.metadata = t.metadata, this.name = t.name || d3, this.core = t.core, this.logger = this.core.logger, this.engine = new D4(this);
  }
  static async init(t) {
    const e = new p3(t);
    return await e.initialize(), e;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.engine.init(), this.logger.info("Web3Wallet Initialization Success");
    } catch (t) {
      throw this.logger.info("Web3Wallet Initialization Failure"), this.logger.error(t.message), t;
    }
  }
};
var G4 = p3;

// node_modules/@thirdweb-dev/wallets/dist/thirdweb-dev-wallets.browser.esm.js
init_lib3();

// node_modules/@thirdweb-dev/wallets/dist/wc-c6a6a61c.browser.esm.js
init_shim();
var TW_WC_PROJECT_ID = "145769e410f16970a79ff77b2d89a1e0";
var WC_RELAY_URL = "wss://relay.walletconnect.com";
var EIP155_SIGNING_METHODS = {
  PERSONAL_SIGN: "personal_sign",
  ETH_SIGN: "eth_sign",
  ETH_SIGN_TRANSACTION: "eth_signTransaction",
  ETH_SIGN_TYPED_DATA: "eth_signTypedData",
  ETH_SIGN_TYPED_DATA_V3: "eth_signTypedData_v3",
  ETH_SIGN_TYPED_DATA_V4: "eth_signTypedData_v4",
  ETH_SEND_TRANSACTION: "eth_sendTransaction",
  SWITCH_CHAIN: "wallet_switchEthereumChain"
};

// node_modules/@thirdweb-dev/wallets/dist/base-514419e3.browser.esm.js
init_shim();

// node_modules/@thirdweb-dev/wallets/evm/wallets/abstract/dist/thirdweb-dev-wallets-evm-wallets-abstract.browser.esm.js
init_shim();
init_lib3();
var ERC20WithDecimalsAbi = [{
  anonymous: false,
  inputs: [{
    indexed: true,
    internalType: "address",
    name: "owner",
    type: "address"
  }, {
    indexed: true,
    internalType: "address",
    name: "spender",
    type: "address"
  }, {
    indexed: false,
    internalType: "uint256",
    name: "value",
    type: "uint256"
  }],
  name: "Approval",
  type: "event"
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    internalType: "address",
    name: "from",
    type: "address"
  }, {
    indexed: true,
    internalType: "address",
    name: "to",
    type: "address"
  }, {
    indexed: false,
    internalType: "uint256",
    name: "value",
    type: "uint256"
  }],
  name: "Transfer",
  type: "event"
}, {
  inputs: [{
    internalType: "address",
    name: "owner",
    type: "address"
  }, {
    internalType: "address",
    name: "spender",
    type: "address"
  }],
  name: "allowance",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "spender",
    type: "address"
  }, {
    internalType: "uint256",
    name: "value",
    type: "uint256"
  }],
  name: "approve",
  outputs: [{
    internalType: "bool",
    name: "",
    type: "bool"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "who",
    type: "address"
  }],
  name: "balanceOf",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "totalSupply",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "to",
    type: "address"
  }, {
    internalType: "uint256",
    name: "value",
    type: "uint256"
  }],
  name: "transfer",
  outputs: [{
    internalType: "bool",
    name: "",
    type: "bool"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "from",
    type: "address"
  }, {
    internalType: "address",
    name: "to",
    type: "address"
  }, {
    internalType: "uint256",
    name: "value",
    type: "uint256"
  }],
  name: "transferFrom",
  outputs: [{
    internalType: "bool",
    name: "",
    type: "bool"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [],
  name: "decimals",
  outputs: [{
    internalType: "uint8",
    name: "",
    type: "uint8"
  }],
  stateMutability: "view",
  type: "function"
}];
function createErc20(provider, currencyAddress) {
  return new Contract(currencyAddress, ERC20WithDecimalsAbi, provider);
}
function chainIdToThirdwebRpc(chainId, clientId) {
  return `https://${chainId}.rpc.thirdweb.com${clientId ? `/${clientId}` : ""}${typeof globalThis !== "undefined" && "APP_BUNDLE_ID" in globalThis ? `?bundleId=${globalThis.APP_BUNDLE_ID}` : ""}`;
}
var EIP1271_ABI = ["function isValidSignature(bytes32 _message, bytes _signature) public view returns (bytes4)"];
var EIP1271_MAGICVALUE = "0x1626ba7e";
async function checkContractWalletSignature(message, signature, address, chainId) {
  const provider = new lib_exports.JsonRpcProvider(chainIdToThirdwebRpc(chainId));
  const walletContract = new Contract(address, EIP1271_ABI, provider);
  const _hashMessage = utils_exports.hashMessage(message);
  try {
    const res = await walletContract.isValidSignature(_hashMessage, signature);
    return res === EIP1271_MAGICVALUE;
  } catch {
    return false;
  }
}
var AbstractWallet = class extends eventemitter3_default {
  constructor() {
    super(...arguments);
    _defineProperty(this, "type", "evm");
  }
  async getAddress() {
    const signer = await this.getSigner();
    return signer.getAddress();
  }
  async getBalance() {
    let currencyAddress = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : NATIVE_TOKEN_ADDRESS;
    const signer = await this.getSigner();
    const address = await this.getAddress();
    if (!signer.provider) {
      throw new Error("Please connect a provider");
    }
    let balance;
    if (isNativeToken(currencyAddress)) {
      balance = await signer.provider.getBalance(address);
    } else {
      const erc20 = createErc20(signer, currencyAddress);
      balance = await erc20.balanceOf(address);
    }
    return await fetchCurrencyValue(signer.provider, currencyAddress, balance);
  }
  async getChainId() {
    const signer = await this.getSigner();
    return signer.getChainId();
  }
  async transfer(to, amount) {
    let currencyAddress = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NATIVE_TOKEN_ADDRESS;
    const signer = await this.getSigner();
    const from = await this.getAddress();
    if (!signer.provider) {
      throw new Error("Please connect a provider");
    }
    const value = await normalizePriceValue(signer.provider, amount, currencyAddress);
    if (isNativeToken(currencyAddress)) {
      const tx = await signer.sendTransaction({
        from,
        to,
        value
      });
      return {
        receipt: await tx.wait()
      };
    } else {
      const erc20 = createErc20(signer, currencyAddress);
      const tx = await erc20.transfer(to, value);
      return {
        receipt: await tx.wait()
      };
    }
  }
  async signMessage(message) {
    const signer = await this.getSigner();
    return await signer.signMessage(message);
  }
  async verifySignature(message, signature, address, chainId) {
    try {
      const messageHash = utils_exports.hashMessage(message);
      const messageHashBytes = utils_exports.arrayify(messageHash);
      const recoveredAddress = utils_exports.recoverAddress(messageHashBytes, signature);
      if (recoveredAddress === address) {
        return true;
      }
    } catch {
    }
    if (chainId !== void 0) {
      try {
        const isValid = await checkContractWalletSignature(message, signature, address, chainId || 1);
        return isValid;
      } catch {
      }
    }
    return false;
  }
};

// node_modules/@thirdweb-dev/wallets/dist/base-514419e3.browser.esm.js
var PREFIX = "__TW__";
var AsyncLocalStorage = class {
  constructor(name) {
    this.name = name;
  }
  getItem(key) {
    return new Promise((res) => {
      res(localStorage.getItem(`${PREFIX}/${this.name}/${key}`));
    });
  }
  setItem(key, value) {
    return new Promise((res, rej) => {
      try {
        localStorage.setItem(`${PREFIX}/${this.name}/${key}`, value);
        res();
      } catch (e) {
        rej(e);
      }
    });
  }
  removeItem(key) {
    return new Promise((res) => {
      localStorage.removeItem(`${PREFIX}/${this.name}/${key}`);
      res();
    });
  }
};
function createAsyncLocalStorage(name) {
  return new AsyncLocalStorage(name);
}
var DEFAULT_DAPP_META = {
  name: "thirdweb powered dApp",
  url: "https://thirdweb.com",
  description: "thirdweb powered dApp",
  logoUrl: "https://thirdweb.com/favicon.ico",
  isDarkMode: true
};
var walletAnalyticsEnabled = true;
function isWalletAnalyticsEnabled() {
  return walletAnalyticsEnabled;
}
function setWalletAnalyticsEnabled(enabled) {
  walletAnalyticsEnabled = enabled;
}
var ANALYTICS_ENDPOINT = "https://c.thirdweb.com/event";
function track(args) {
  if (!isWalletAnalyticsEnabled()) {
    return;
  }
  const {
    clientId,
    walletType,
    walletAddress,
    source,
    action
  } = args;
  const body = {
    source,
    action,
    walletAddress,
    walletType
  };
  fetch(ANALYTICS_ENDPOINT, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "x-client-id": clientId
    },
    body: JSON.stringify(body)
  });
}
var _connectParams = /* @__PURE__ */ new WeakMap();
var _connect = /* @__PURE__ */ new WeakSet();
var _trackConnection = /* @__PURE__ */ new WeakSet();
var _subscribeToEvents = /* @__PURE__ */ new WeakSet();
var AbstractClientWallet = class extends AbstractWallet {
  getMeta() {
    return this.constructor.meta;
  }
  constructor(walletId, options) {
    super();
    _classPrivateMethodInitSpec(this, _subscribeToEvents);
    _classPrivateMethodInitSpec(this, _trackConnection);
    _classPrivateMethodInitSpec(this, _connect);
    _classPrivateFieldInitSpec(this, _connectParams, {
      writable: true,
      value: void 0
    });
    this.walletId = walletId;
    this.options = options;
    this.chains = ((options == null ? void 0 : options.chains) || defaultChains).map((c2) => updateChainRPCs(c2, options == null ? void 0 : options.clientId));
    this.dappMetadata = (options == null ? void 0 : options.dappMetadata) || DEFAULT_DAPP_META;
    this.walletStorage = (options == null ? void 0 : options.walletStorage) || createAsyncLocalStorage(this.walletId);
  }
  async autoConnect(connectOptions) {
    const options = connectOptions ? {
      ...connectOptions,
      chainId: void 0
    } : void 0;
    return _classPrivateMethodGet(this, _connect, _connect2).call(this, true, options);
  }
  async connect(connectOptions) {
    _classPrivateFieldSet(this, _connectParams, connectOptions);
    const address = await _classPrivateMethodGet(this, _connect, _connect2).call(this, false, connectOptions);
    if (!address) {
      throw new Error("Failed to connect to the wallet.");
    }
    return address;
  }
  getConnectParams() {
    return _classPrivateFieldGet(this, _connectParams);
  }
  getOptions() {
    return this.options;
  }
  async getSigner() {
    const connector = await this.getConnector();
    if (!connector) {
      throw new Error("Wallet not connected");
    }
    return await connector.getSigner();
  }
  async disconnect() {
    const connector = await this.getConnector();
    if (connector) {
      await connector.disconnect();
      this.emit("disconnect");
      connector.removeAllListeners();
    }
  }
  async switchChain(chainId) {
    const connector = await this.getConnector();
    if (!connector) {
      throw new Error("Wallet not connected");
    }
    if (!connector.switchChain) {
      throw new Error("Wallet does not support switching chains");
    }
    return await connector.switchChain(chainId);
  }
  async updateChains(chains) {
    this.chains = chains.map((c2) => {
      var _a;
      return updateChainRPCs(c2, (_a = this.options) == null ? void 0 : _a.clientId);
    });
    const connector = await this.getConnector();
    connector.updateChains(this.chains);
  }
  getPersonalWallet() {
    return void 0;
  }
};
async function _connect2(isAutoConnect, connectOptions) {
  const connector = await this.getConnector();
  _classPrivateMethodGet(this, _subscribeToEvents, _subscribeToEvents2).call(this, connector);
  const isConnected = await connector.isConnected();
  if (isConnected) {
    const address = await connector.getAddress();
    connector.setupListeners();
    if (connectOptions == null ? void 0 : connectOptions.chainId) {
      await connector.switchChain(connectOptions == null ? void 0 : connectOptions.chainId);
    }
    this.emit("connect", {
      address,
      chainId: await this.getChainId()
    });
    _classPrivateMethodGet(this, _trackConnection, _trackConnection2).call(this, address);
    return address;
  }
  if (isAutoConnect) {
    throw new Error("Failed to auto connect to the wallet.");
  }
  try {
    const address = await connector.connect(connectOptions);
    _classPrivateMethodGet(this, _trackConnection, _trackConnection2).call(this, address);
    return address;
  } catch (error) {
    throw new Error(error.message);
  }
}
function _trackConnection2(address) {
  var _a;
  track({
    clientId: ((_a = this.options) == null ? void 0 : _a.clientId) || "",
    source: "connectWallet",
    action: "connect",
    walletType: this.walletId,
    walletAddress: address
  });
}
async function _subscribeToEvents2(connector) {
  connector.on("connect", (data) => {
    var _a;
    this.emit("connect", {
      address: data.account,
      chainId: (_a = data.chain) == null ? void 0 : _a.id
    });
  });
  connector.on("change", (data) => {
    var _a;
    this.emit("change", {
      address: data.account,
      chainId: (_a = data.chain) == null ? void 0 : _a.id
    });
  });
  connector.on("message", (data) => {
    this.emit("message", data);
  });
  connector.on("disconnect", async () => {
    this.emit("disconnect");
  });
  connector.on("error", (error) => this.emit("error", error));
}

// node_modules/@thirdweb-dev/wallets/evm/wallets/okx/dist/thirdweb-dev-wallets-evm-wallets-okx.browser.esm.js
init_shim();
init_lib3();
var OKXWallet = class extends AbstractClientWallet {
  get walletName() {
    return "OKX";
  }
  constructor(options) {
    super(OKXWallet.id, options);
    this.isInjected = !!getInjectedOKXProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          OKXConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-okx.browser.esm-QFN6XKFI.js");
        this.OKXConnector = new OKXConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.connector = new WagmiAdapter(this.OKXConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-FV443MXD.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
  async switchAccount() {
    if (!this.OKXConnector) {
      throw new Error("Can not switch Account");
    }
    await this.OKXConnector.switchAccount();
  }
};
_defineProperty(OKXWallet, "id", walletIds.okx);

// node_modules/@thirdweb-dev/wallets/evm/wallets/core-wallet/dist/thirdweb-dev-wallets-evm-wallets-core-wallet.browser.esm.js
init_shim();
init_lib3();
var CoreWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Core wallet";
  }
  constructor(options) {
    super(CoreWallet.id, options);
    this.isInjected = !!getInjectedCoreWalletProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          CoreWalletConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-core-wallet.browser.esm-SYMMMJG5.js");
        this.CoreWalletConnector = new CoreWalletConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.connector = new WagmiAdapter(this.CoreWalletConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-FV443MXD.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
  async switchAccount() {
    if (!this.CoreWalletConnector) {
      throw new Error("Can not switch Account");
    }
    await this.CoreWalletConnector.switchAccount();
  }
};
_defineProperty(CoreWallet, "id", walletIds.coreWallet);

// node_modules/@thirdweb-dev/wallets/dist/getInjectedCoinbaseProvider-980f40a9.browser.esm.js
init_shim();
function getInjectedCoinbaseProvider() {
  var _a;
  function getReady(ethereum) {
    const isCoinbaseWallet = !!(ethereum == null ? void 0 : ethereum.isCoinbaseWallet);
    if (isCoinbaseWallet) {
      return ethereum;
    }
    if (ethereum && "overrideIsMetaMask" in ethereum) {
      if ("providerMap" in ethereum) {
        if (ethereum.providerMap instanceof Map) {
          if (ethereum.providerMap.has("CoinbaseWallet")) {
            return ethereum;
          }
        }
      }
    }
  }
  if (assertWindowEthereum(globalThis.window)) {
    if ((_a = globalThis.window.ethereum) == null ? void 0 : _a.providers) {
      return globalThis.window.ethereum.providers.find(getReady);
    }
    return getReady(globalThis.window.ethereum);
  }
}

// node_modules/@thirdweb-dev/wallets/evm/wallets/paper-wallet/dist/thirdweb-dev-wallets-evm-wallets-paper-wallet.browser.esm.js
init_shim();
init_lib3();
var PaperWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Paper Wallet";
  }
  constructor(options) {
    var _a, _b;
    super(PaperWallet.id, {
      ...options
    });
    try {
      this.chain = {
        ...options.chain,
        rpc: getValidChainRPCs(options.chain, options.clientId)
      };
    } catch {
      this.chain = options.chain;
    }
    if (options.paperClientId && options.paperClientId === "uninitialized") {
      this.paperClientId = "00000000-0000-0000-0000-000000000000";
      return;
    }
    if (options.advancedOptions && ((_a = options.advancedOptions) == null ? void 0 : _a.recoveryShareManagement) === "USER_MANAGED") {
      if (options.paperClientId && !this.isClientIdLegacyPaper(options.paperClientId) || !options.paperClientId && options.clientId && !this.isClientIdLegacyPaper(options.clientId)) {
        throw new Error('RecoveryShareManagement option "USER_MANAGED" is not supported with thirdweb client ID');
      }
    }
    if (!options.clientId && !options.paperClientId) {
      throw new Error("clientId or paperClientId is required");
    }
    if (options.paperClientId && !this.isClientIdLegacyPaper(options.paperClientId)) {
      throw new Error("paperClientId must be a legacy paper client ID");
    }
    if (options.clientId && this.isClientIdLegacyPaper(options.clientId)) {
      throw new Error("clientId must be a thirdweb client ID");
    }
    this.paperClientId = (_b = options.paperClientId) != null ? _b : options.clientId;
    this.onAuthSuccess = options.onAuthSuccess;
  }
  isClientIdLegacyPaper(clientId) {
    return clientId.indexOf("-") > 0 && clientId.length === 36;
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      const {
        PaperWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-paper.browser.esm-62DTCHGY.js");
      this.connector = new PaperWalletConnector({
        clientId: this.paperClientId,
        chain: this.chain,
        chains: this.chains,
        onAuthSuccess: this.onAuthSuccess,
        advancedOptions: {
          recoveryShareManagement: (_b = (_a = this.options) == null ? void 0 : _a.advancedOptions) == null ? void 0 : _b.recoveryShareManagement
        },
        styles: (_c = this.options) == null ? void 0 : _c.styles
      });
    }
    return this.connector;
  }
  getConnectParams() {
    const connectParams = super.getConnectParams();
    if (!connectParams) {
      return void 0;
    }
    if (typeof connectParams.googleLogin === "object") {
      return {
        ...connectParams,
        googleLogin: true
      };
    }
    return connectParams;
  }
  async getEmail() {
    const connector = await this.getConnector();
    return connector.getEmail();
  }
  async getPaperSDK() {
    const connector = await this.getConnector();
    return connector.getPaperSDK();
  }
};
_defineProperty(PaperWallet, "id", walletIds.paper);
_defineProperty(PaperWallet, "meta", {
  name: "Paper Wallet",
  iconURL: "ipfs://QmNrLXtPoFrh4yjZbXui39zUMozS1oetpgU8dvZhFAxfRa/paper-logo-icon.svg"
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/blocto/dist/thirdweb-dev-wallets-evm-wallets-blocto.browser.esm.js
init_shim();
init_lib3();
var BloctoWallet = class extends AbstractClientWallet {
  constructor(options) {
    if ((options == null ? void 0 : options.chain) && options.clientId) {
      options.chain = updateChainRPCs(options.chain, options.clientId);
    }
    super(BloctoWallet.id, options);
    _defineProperty(this, "name", "Blocto");
  }
  async initConnector() {
    var _a, _b, _c;
    const {
      BloctoConnector
    } = await import("./thirdweb-dev-wallets-evm-connectors-blocto.browser.esm-7TIMPOWY.js");
    const bloctoConnector = new BloctoConnector({
      chains: this.chains,
      options: {
        appId: (_a = this.options) == null ? void 0 : _a.appId,
        chainId: (_c = (_b = this.options) == null ? void 0 : _b.chain) == null ? void 0 : _c.chainId
      }
    });
    this.connector = new WagmiAdapter(bloctoConnector);
    return this.connector;
  }
  async getConnector() {
    if (!this.connector) {
      return await this.initConnector();
    }
    return Promise.resolve(this.connector);
  }
};
_defineProperty(BloctoWallet, "id", walletIds.blocto);
_defineProperty(BloctoWallet, "meta", {
  name: "Blocto",
  iconURL: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA2MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzIyMzNfMjM4NykiPgo8cmVjdCB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIHJ4PSIxMiIgZmlsbD0id2hpdGUiLz4KPHBhdGggZD0iTTMyLjkwMjggMTguMzA2M0MyOC4zOTExIDE4LjMwNjMgMjMuOTg3MyAyMC4wNDU5IDIwLjY5NTIgMjMuMTMxOUMxNy4wODQzIDI2LjUxNzYgMTQuNzk5MiAzMS41MTc3IDEzLjQ4OTMgMzYuMjIxMkMxMi42MzE0IDM5LjI5OTIgMTIuMjAxNiA0Mi40OTE1IDEyLjIwMTYgNDUuNjg1M0MxMi4yMDE2IDQ2LjY1MTEgMTIuMjQxMiA0Ny42MDg5IDEyLjMxNzQgNDguNTU1NkMxMi40MTA5IDQ5LjcwNjkgMTMuNTMyMSA1MC41MDQ2IDE0LjY0ODUgNTAuMjAzM0MxNS42MjIyIDQ5Ljk0MTYgMTYuNjQ2NiA0OS44MDA1IDE3LjcwMjggNDkuODAwNUMxOS44NzIyIDQ5LjgwMDUgMjEuOTA1MiA1MC4zOTA0IDIzLjY0OCA1MS40MjEyQzIzLjY5MDggNTEuNDQ2NiAyMy43MzIgNTEuNDcxOSAyMy43NzQ4IDUxLjQ5NTdDMjYuNjA3MSA1My4xODQ2IDI5Ljk0ODQgNTQuMTEyMyAzMy41MTE3IDUzLjk5MzRDNDIuODA2MiA1My42ODU3IDUwLjM5OSA0Ni4xMjMgNTAuNzQxNiAzNi44MzAxQzUxLjExNTggMjYuNjYzNSA0Mi45ODY5IDE4LjMwNDcgMzIuOTA0NCAxOC4zMDQ3TDMyLjkwMjggMTguMzA2M1pNMzIuOTAyOCA0NC4zMTJDMjguMzk3NSA0NC4zMTIgMjQuNzQ1NCA0MC42NTk5IDI0Ljc0NTQgMzYuMTU2MkMyNC43NDU0IDMxLjY1MjUgMjguMzk3NSAyNy45OTg3IDMyLjkwMjggMjcuOTk4N0MzNy40MDgxIDI3Ljk5ODcgNDEuMDYwMiAzMS42NTA5IDQxLjA2MDIgMzYuMTU2MkM0MS4wNjAyIDQwLjY2MTQgMzcuNDA4MSA0NC4zMTIgMzIuOTAyOCA0NC4zMTJaIiBmaWxsPSIjMTRBQUZGIi8+CjxwYXRoIGQ9Ik0yNS41NjM2IDEyLjY4MjZDMjUuNTYzNiAxNS4wMzQ0IDI0LjMzMTUgMTcuMjE2NCAyMi4zMDggMTguNDE1M0MyMS4wMzc3IDE5LjE2ODYgMTkuODQ2OCAyMC4wNTgyIDE4Ljc2ODQgMjEuMDcxNUMxNi4zNzU1IDIzLjMxMzkgMTQuNTg5OCAyNi4wNjUzIDEzLjI2NzMgMjguNzkyOUMxMy4wMDcyIDI5LjMzMDQgMTIuMiAyOS4xNDAyIDEyLjIgMjguNTQyM1YxMi42ODI2QzEyLjIgOC45OTI0MiAxNS4xOTI0IDYgMTguODgyNiA2QzIyLjU3MjggNiAyNS41NjUyIDguOTkyNDIgMjUuNTY1MiAxMi42ODI2SDI1LjU2MzZaIiBmaWxsPSIjMDA3NUZGIi8+CjwvZz4KPGRlZnM+CjxjbGlwUGF0aCBpZD0iY2xpcDBfMjIzM18yMzg3Ij4KPHJlY3Qgd2lkdGg9IjYwIiBoZWlnaHQ9IjYwIiBmaWxsPSJ3aGl0ZSIvPgo8L2NsaXBQYXRoPgo8L2RlZnM+Cjwvc3ZnPgo=",
  urls: {
    android: "https://play.google.com/store/apps/details?id=com.portto.blocto",
    ios: "https://apps.apple.com/app/blocto/id1481181682"
  }
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/coinbase-wallet/dist/thirdweb-dev-wallets-evm-wallets-coinbase-wallet.browser.esm.js
init_shim();
var import_buffer = __toESM(require_buffer());
init_lib3();
{
  window.Buffer = import_buffer.Buffer;
}
var CoinbaseWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Coinbase Wallet";
  }
  constructor(options) {
    super(CoinbaseWallet.id, options);
    this.headlessMode = (options == null ? void 0 : options.headlessMode) || false;
    this.theme = (options == null ? void 0 : options.theme) || this.dappMetadata.isDarkMode === false ? "light" : "dark";
  }
  async getConnector() {
    if (!this.connector) {
      const {
        CoinbaseWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-coinbase-wallet.browser.esm-H3NR4K55.js");
      const cbConnector = new CoinbaseWalletConnector({
        chains: this.chains,
        options: {
          appName: this.dappMetadata.name,
          reloadOnDisconnect: false,
          darkMode: this.theme === "dark",
          headlessMode: this.headlessMode
        }
      });
      cbConnector.on("connect", () => {
      });
      this.coinbaseConnector = cbConnector;
      this.connector = new WagmiAdapter(cbConnector);
    }
    return this.connector;
  }
  async getQrUrl() {
    await this.getConnector();
    if (!this.coinbaseConnector) {
      throw new Error("Coinbase connector not initialized");
    }
    return this.coinbaseConnector.getQrUrl();
  }
};
_defineProperty(CoinbaseWallet, "meta", {
  iconURL: "ipfs://QmcJBHopbwfJcLqJpX2xEufSS84aLbF7bHavYhaXUcrLaH/coinbase.svg",
  name: "Coinbase Wallet",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/coinbase-wallet-extension/hnfanknocfeofbddgcijnmhnfnkdnaad",
    android: "https://play.google.com/store/apps/details?id=org.toshi",
    ios: "https://apps.apple.com/us/app/coinbase-wallet-nfts-crypto/id1278383455"
  }
});
_defineProperty(CoinbaseWallet, "id", walletIds.coinbase);

// node_modules/@thirdweb-dev/wallets/evm/wallets/embedded-wallet/dist/thirdweb-dev-wallets-evm-wallets-embedded-wallet.browser.esm.js
init_shim();
init_lib3();
var EmbeddedWallet = class extends AbstractClientWallet {
  static async sendVerificationEmail(options) {
    const wallet = new EmbeddedWallet({
      chain: c1,
      clientId: options.clientId
    });
    return wallet.sendVerificationEmail({
      email: options.email
    });
  }
  get walletName() {
    return "Embedded Wallet";
  }
  constructor(options) {
    super(EmbeddedWallet.id, {
      ...options
    });
    try {
      this.chain = {
        ...options.chain,
        rpc: getValidChainRPCs(options.chain, options.clientId)
      };
    } catch {
      this.chain = options.chain;
    }
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      const {
        EmbeddedWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-embedded-wallet.browser.esm-WY5A3GXZ.js");
      this.connector = new EmbeddedWalletConnector({
        clientId: (_b = (_a = this.options) == null ? void 0 : _a.clientId) != null ? _b : "",
        chain: this.chain,
        chains: this.chains,
        onAuthSuccess: (_c = this.options) == null ? void 0 : _c.onAuthSuccess
      });
    }
    return this.connector;
  }
  autoConnect(connectOptions) {
    if (!connectOptions) {
      throw new Error("Can't autoconnect embedded wallet");
    }
    return this.connect(connectOptions);
  }
  getConnectParams() {
    const connectParams = super.getConnectParams();
    if (!connectParams) {
      return void 0;
    }
    return {
      chainId: connectParams.chainId,
      authResult: {
        user: connectParams.authResult.user
      }
    };
  }
  async getEmail() {
    const connector = await this.getConnector();
    return connector.getEmail();
  }
  async getEmbeddedWalletSDK() {
    const connector = await this.getConnector();
    return connector.getEmbeddedWalletSDK();
  }
  async getRecoveryInformation() {
    const connector = await this.getConnector();
    return connector.getRecoveryInformation();
  }
  async sendVerificationEmail(_ref) {
    let {
      email
    } = _ref;
    const connector = await this.getConnector();
    return connector.sendVerificationEmail({
      email
    });
  }
  async authenticate(params) {
    const connector = await this.getConnector();
    return connector.authenticate(params);
  }
};
_defineProperty(EmbeddedWallet, "id", walletIds.embeddedWallet);
_defineProperty(EmbeddedWallet, "meta", {
  name: "Embedded Wallet",
  iconURL: "ipfs://QmNx2evQa6tcQs9VTd3YaDm31ckfStvgRGKFGELahUmrbV/emailIcon.svg"
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/ethers/dist/thirdweb-dev-wallets-evm-wallets-ethers.browser.esm.js
init_shim();
init_lib3();
var _signer = /* @__PURE__ */ new WeakMap();
var EthersWallet = class extends AbstractWallet {
  constructor(signer) {
    super();
    _classPrivateFieldInitSpec(this, _signer, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _signer, signer);
  }
  async getSigner() {
    return _classPrivateFieldGet(this, _signer);
  }
};

// node_modules/@thirdweb-dev/wallets/evm/wallets/frame/dist/thirdweb-dev-wallets-evm-wallets-frame.browser.esm.js
init_shim();
init_lib3();
var FrameWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Frame Wallet";
  }
  constructor(options) {
    super(FrameWallet.id, options);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        FrameConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-frame.browser.esm-QTKC6GMI.js");
      this.connector = new WagmiAdapter(new FrameConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      }));
    }
    return this.connector;
  }
};
_defineProperty(FrameWallet, "id", walletIds.frame);

// node_modules/@thirdweb-dev/wallets/evm/wallets/injected/dist/thirdweb-dev-wallets-evm-wallets-injected.browser.esm.js
init_shim();
init_lib3();
var InjectedWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Injected Wallet";
  }
  constructor(options) {
    super(InjectedWallet.id, options);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        InjectedConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-injected.browser.esm-LHCDDDBU.js");
      this.connector = new WagmiAdapter(new InjectedConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      }));
    }
    return this.connector;
  }
};
_defineProperty(InjectedWallet, "id", "injected");

// node_modules/@thirdweb-dev/wallets/evm/wallets/local-wallet/dist/thirdweb-dev-wallets-evm-wallets-local-wallet.browser.esm.js
init_shim();
init_lib3();
var STORAGE_KEY_WALLET_DATA = "localWalletData";
var _storage2 = /* @__PURE__ */ new WeakMap();
var _saveData = /* @__PURE__ */ new WeakSet();
var LocalWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Local Wallet";
  }
  constructor(options) {
    super(LocalWallet.id, options);
    _classPrivateMethodInitSpec(this, _saveData);
    _classPrivateFieldInitSpec(this, _storage2, {
      writable: true,
      value: void 0
    });
    if ((options == null ? void 0 : options.chain) && options.clientId) {
      options.chain = updateChainRPCs(options.chain, options.clientId);
    }
    this.options = options || {};
    _classPrivateFieldSet(this, _storage2, (options == null ? void 0 : options.storage) || createAsyncLocalStorage(walletIds.localWallet));
  }
  async getConnector() {
    if (!this.connector) {
      const {
        LocalWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-local-wallet.browser.esm-7SSOQAUK.js");
      if (!this.ethersWallet) {
        throw new Error("wallet is not initialized");
      }
      const defaults = (this.options.chain ? [...defaultChains, this.options.chain] : defaultChains).map((c2) => updateChainRPCs(c2, this.options.clientId));
      this.connector = new LocalWalletConnector({
        chain: this.options.chain || updateChainRPCs(c1, this.options.clientId),
        ethersWallet: this.ethersWallet,
        chains: this.chains || defaults,
        clientId: this.options.clientId,
        secretKey: this.options.secretKey
      });
    }
    return this.connector;
  }
  async loadOrCreate(options) {
    if (await this.getSavedData(options.storage)) {
      await this.load(options);
    } else {
      await this.generate();
      await this.save(options);
    }
  }
  async generate() {
    if (this.ethersWallet) {
      throw new Error("wallet is already initialized");
    }
    const random = utils_exports.randomBytes(32);
    this.ethersWallet = new Wallet(random);
    return this.ethersWallet.address;
  }
  async import(options) {
    if (this.ethersWallet) {
      throw new Error("wallet is already initialized");
    }
    if ("encryptedJson" in options) {
      this.ethersWallet = await Wallet.fromEncryptedJson(options.encryptedJson, options.password);
      return this.ethersWallet.address;
    }
    if ("privateKey" in options) {
      if (!options.encryption && !isValidPrivateKey(options.privateKey)) {
        throw new Error("invalid private key");
      }
      const privateKey = await getDecryptor(options.encryption)(options.privateKey);
      if (options.encryption && (privateKey === "" || !isValidPrivateKey(privateKey))) {
        throw new Error("invalid password");
      }
      this.ethersWallet = new Wallet(privateKey);
      return this.ethersWallet.address;
    }
    if ("mnemonic" in options) {
      if (!options.encryption && !utils_exports.isValidMnemonic(options.mnemonic)) {
        throw new Error("invalid mnemonic");
      }
      const mnemonic = await getDecryptor(options.encryption)(options.mnemonic);
      if (options.encryption && (mnemonic === "" || !utils_exports.isValidMnemonic(mnemonic))) {
        throw new Error("invalid password");
      }
      this.ethersWallet = Wallet.fromMnemonic(mnemonic);
      return this.ethersWallet.address;
    }
    throw new Error("invalid import strategy");
  }
  async load(options) {
    if (this.ethersWallet) {
      throw new Error("wallet is already initialized");
    }
    const walletData = await this.getSavedData(options.storage);
    if (!walletData) {
      throw new Error("No Saved wallet found in storage");
    }
    if (walletData.strategy !== options.strategy) {
      throw new Error(`Saved wallet data is not ${options.strategy}, it is ${walletData.strategy}`);
    }
    if (options.strategy === "encryptedJson") {
      return this.import({
        encryptedJson: walletData.data,
        password: options.password
      });
    }
    if (walletData.isEncrypted && !options.encryption) {
      throw new Error("Saved wallet data is encrypted, but no password is provided");
    }
    if (!walletData.isEncrypted && options.encryption) {
      throw new Error("Saved wallet data is not encrypted, but encryption config is provided");
    }
    if (options.strategy === "privateKey") {
      return this.import({
        privateKey: walletData.data,
        encryption: options.encryption
      });
    }
    if (options.strategy === "mnemonic") {
      return this.import({
        mnemonic: walletData.data,
        encryption: options.encryption
      });
    }
    throw new Error("invalid load strategy");
  }
  async save(options) {
    const wallet = this.ethersWallet;
    if (!wallet) {
      throw new Error("Wallet is not initialized");
    }
    if (options.strategy === "encryptedJson") {
      const encryptedData = await wallet.encrypt(options.password, {
        scrypt: {
          N: 1 << 32
        }
      });
      await _classPrivateMethodGet(this, _saveData, _saveData2).call(this, {
        address: wallet.address,
        data: encryptedData,
        strategy: "encryptedJson",
        isEncrypted: true
      }, options.storage);
    }
    if (options.strategy === "privateKey") {
      const privateKey = await getEncryptor(options.encryption)(wallet.privateKey);
      await _classPrivateMethodGet(this, _saveData, _saveData2).call(this, {
        address: wallet.address,
        data: privateKey,
        strategy: "privateKey",
        isEncrypted: !!options.encryption
      }, options.storage);
    }
    if (options.strategy === "mnemonic") {
      if (!wallet.mnemonic) {
        throw new Error("mnemonic can not be computed if wallet is created from a private key or generated using generate()");
      }
      const mnemonic = await getEncryptor(options.encryption)(wallet.mnemonic.phrase);
      await _classPrivateMethodGet(this, _saveData, _saveData2).call(this, {
        address: wallet.address,
        data: mnemonic,
        strategy: "mnemonic",
        isEncrypted: !!options.encryption
      }, options.storage);
    }
  }
  async isSaved() {
    try {
      const data = await this.getSavedData();
      const address = await this.getAddress();
      if ((data == null ? void 0 : data.address) === address) {
        return true;
      }
      return false;
    } catch (e) {
      return false;
    }
  }
  async deleteSaved() {
    await _classPrivateFieldGet(this, _storage2).removeItem(STORAGE_KEY_WALLET_DATA);
  }
  async export(options) {
    const wallet = this.ethersWallet;
    if (!wallet) {
      throw new Error("Wallet is not initialized");
    }
    if (options.strategy === "encryptedJson") {
      return wallet.encrypt(options.password, {
        scrypt: {
          N: 1 << 32
        }
      });
    }
    if (options.strategy === "privateKey") {
      return getEncryptor(options.encryption)(wallet.privateKey);
    }
    if (options.strategy === "mnemonic") {
      if (!wallet.mnemonic) {
        throw new Error("mnemonic can not be computed if wallet is created from a private key or generated using generate()");
      }
      return getEncryptor(options.encryption)(wallet.mnemonic.phrase);
    }
    throw new Error("Invalid export strategy");
  }
  async getSavedData(storage) {
    const _storage3 = storage || _classPrivateFieldGet(this, _storage2);
    try {
      const savedDataStr = await _storage3.getItem(STORAGE_KEY_WALLET_DATA);
      if (!savedDataStr) {
        return null;
      }
      const savedData = JSON.parse(savedDataStr);
      if (!savedData) {
        return null;
      }
      return savedData;
    } catch (e) {
      return null;
    }
  }
  async disconnect() {
    await super.disconnect();
    this.ethersWallet = void 0;
  }
};
async function _saveData2(data, storage) {
  const _storage3 = storage || _classPrivateFieldGet(this, _storage2);
  await _storage3.setItem(STORAGE_KEY_WALLET_DATA, JSON.stringify(data));
}
_defineProperty(LocalWallet, "id", walletIds.localWallet);
_defineProperty(LocalWallet, "meta", {
  name: "Local Wallet",
  iconURL: "ipfs://QmbQzSNGvmNYZzem9jZRuYeLe9K2W4pqbdnVUp7Y6edQ8Y/local-wallet.svg"
});
async function defaultEncrypt(message, password) {
  const cryptoJS = (await import("./crypto-js-FGOUOEKO.js")).default;
  return cryptoJS.AES.encrypt(message, password).toString();
}
async function defaultDecrypt(message, password) {
  const cryptoJS = (await import("./crypto-js-FGOUOEKO.js")).default;
  return cryptoJS.AES.decrypt(message, password).toString(cryptoJS.enc.Utf8);
}
function getDecryptor(encryption) {
  const noop = async (msg) => msg;
  return encryption ? (msg) => (encryption.decrypt || defaultDecrypt)(msg, encryption.password) : noop;
}
function getEncryptor(encryption) {
  const noop = async (msg) => msg;
  return encryption ? (msg) => (encryption.encrypt || defaultEncrypt)(msg, encryption.password) : noop;
}
function isValidPrivateKey(value) {
  return !!value.match(/^(0x)?[0-9a-f]{64}$/i);
}

// node_modules/@thirdweb-dev/wallets/evm/wallets/signer/dist/thirdweb-dev-wallets-evm-wallets-signer.browser.esm.js
init_shim();
init_lib3();
var _storage = /* @__PURE__ */ new WeakMap();
var SignerWallet = class extends AbstractClientWallet {
  constructor(options) {
    super("signerWallet", options);
    _classPrivateFieldInitSpec(this, _storage, {
      writable: true,
      value: void 0
    });
    if (options.clientId && options.chain) {
      options.chain = updateChainRPCs(options.chain, options.clientId);
    }
    this.options = options;
    this.signer = options.signer;
    _classPrivateFieldSet(this, _storage, (options == null ? void 0 : options.storage) || createAsyncLocalStorage(walletIds.localWallet));
  }
  async getConnector() {
    if (!this.connector) {
      const {
        SignerConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-signer.browser.esm-4TCR64HY.js");
      if (!this.signer) {
        this.signer = this.options.signer;
      }
      const defaults = (this.options.chain ? [...defaultChains, this.options.chain] : defaultChains).map((c2) => updateChainRPCs(c2, this.options.clientId));
      this.connector = new SignerConnector({
        chain: this.options.chain || updateChainRPCs(c1, this.options.clientId),
        signer: this.signer,
        chains: this.chains || defaults,
        clientId: this.options.clientId,
        secretKey: this.options.secretKey
      });
    }
    return this.connector;
  }
};

// node_modules/@thirdweb-dev/wallets/evm/wallets/magic/dist/thirdweb-dev-wallets-evm-wallets-magic.browser.esm.js
init_shim();
init_lib3();
var MagicLink = class extends AbstractClientWallet {
  get walletName() {
    return "Magic Link";
  }
  constructor(options) {
    super(MagicLink.id, options);
    this.options = options;
  }
  async initializeConnector() {
    const {
      MagicAuthConnector
    } = await import("./thirdweb-dev-wallets-evm-connectors-magic.browser.esm-3KXZQGAY.js");
    const magicConnector = new MagicAuthConnector({
      chains: this.chains,
      options: this.options
    });
    this.magicConnector = magicConnector;
    this.connector = new WagmiAdapter(magicConnector);
    return this.connector;
  }
  async getConnector() {
    if (!this.connector) {
      return await this.initializeConnector();
    }
    return this.connector;
  }
  getMagic() {
    if (!this.magicConnector) {
      throw new Error("Magic connector is not initialized");
    }
    return this.magicConnector.getMagicSDK();
  }
  async autoConnect(options) {
    var _a;
    await this.initializeConnector();
    await ((_a = this.magicConnector) == null ? void 0 : _a.initializeMagicSDK(options));
    const magic = this.getMagic();
    {
      const url = new URL(window.location.href);
      const isMagicRedirect = url.searchParams.get("magic_credential");
      if (isMagicRedirect) {
        try {
          this.oAuthRedirectResult = await magic.oauth.getRedirectResult();
        } catch {
        }
      }
    }
    const isLoggedIn = await magic.user.isLoggedIn();
    if (isLoggedIn) {
      return super.autoConnect(options);
    }
    throw new Error("Magic user is not logged in");
  }
  async disconnect() {
    this.oAuthRedirectResult = void 0;
    const magic = this.getMagic();
    await magic.user.logout();
    return super.disconnect();
  }
  async connect(options) {
    if ("email" in options && this.options.emailLogin === false) {
      throw new Error("Email login is disabled");
    }
    if ("phoneNumber" in options && this.options.smsLogin === false) {
      throw new Error("SMS login is disabled");
    }
    return super.connect(options);
  }
};
_defineProperty(MagicLink, "meta", {
  iconURL: "ipfs://QmUMBFZGXxBpgDmZzZAHhbcCL5nYvZnVaYLTajsNjLcxMU/1-Icon_Magic_Color.svg",
  name: "Magic Link"
});
_defineProperty(MagicLink, "id", walletIds.magicLink);

// node_modules/@thirdweb-dev/wallets/evm/wallets/metamask/dist/thirdweb-dev-wallets-evm-wallets-metamask.browser.esm.js
init_shim();
init_lib3();
var MetaMaskWallet = class extends AbstractClientWallet {
  get walletName() {
    return "MetaMask";
  }
  constructor(options) {
    super(MetaMaskWallet.id, options);
    this.isInjected = !!getInjectedMetamaskProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          MetaMaskConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-metamask.browser.esm-HNPHXEFU.js");
        const metamaskConnector = new MetaMaskConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.metamaskConnector = metamaskConnector;
        this.connector = new WagmiAdapter(metamaskConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-FV443MXD.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
  async switchAccount() {
    if (!this.metamaskConnector) {
      throw new Error("Can not switch Account");
    }
    await this.metamaskConnector.switchAccount();
  }
};
_defineProperty(MetaMaskWallet, "meta", {
  name: "MetaMask",
  iconURL: "ipfs://QmZZHcw7zcXursywnLDAyY6Hfxzqop5GKgwoq8NB9jjrkN/metamask.svg",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn",
    android: "https://play.google.com/store/apps/details?id=io.metamask",
    ios: "https://apps.apple.com/us/app/metamask-blockchain-wallet/id1438144202"
  }
});
_defineProperty(MetaMaskWallet, "id", walletIds.metamask);

// node_modules/@thirdweb-dev/wallets/evm/wallets/phantom/dist/thirdweb-dev-wallets-evm-wallets-phantom.browser.esm.js
init_shim();
init_lib3();
var PhantomWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Phantom";
  }
  constructor(options) {
    super(PhantomWallet.id, options);
    this.isInjected = !!getInjectedPhantomProvider();
  }
  async getConnector() {
    if (!this.connector) {
      const {
        PhantomConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-phantom.browser.esm-7SENFDGL.js");
      const phantomConnector = new PhantomConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      });
      this.phantomConnector = phantomConnector;
      this.connector = new WagmiAdapter(phantomConnector);
    }
    return this.connector;
  }
};
_defineProperty(PhantomWallet, "meta", {
  name: "Phantom",
  iconURL: "ipfs://bafybeibkpca5nwxpsjrtuxmz2ckb5lyc2sl2abg5f7dnvxku637vvffjti",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/phantom/bfnaelmomeimhlpmgjnjophhpkkoljpa"
  }
});
_defineProperty(PhantomWallet, "id", walletIds.phantom);

// node_modules/@thirdweb-dev/wallets/evm/wallets/private-key/dist/thirdweb-dev-wallets-evm-wallets-private-key.browser.esm.js
init_shim();
init_lib3();
var _signer2 = /* @__PURE__ */ new WeakMap();
var PrivateKeyWallet = class extends AbstractWallet {
  constructor(privateKey, chain, secretKey) {
    super();
    _classPrivateFieldInitSpec(this, _signer2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _signer2, new ethers_exports.Wallet(privateKey, chain ? getChainProvider(chain, {
      secretKey
    }) : void 0));
  }
  async getSigner() {
    return _classPrivateFieldGet(this, _signer2);
  }
};

// node_modules/@thirdweb-dev/wallets/evm/wallets/rainbow-wallet/dist/thirdweb-dev-wallets-evm-wallets-rainbow-wallet.browser.esm.js
init_shim();
init_lib3();
var RainbowWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Rainbow Wallet";
  }
  constructor(options) {
    super(RainbowWallet.id, options);
    this.isInjected = !!getInjectedRainbowProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          RainbowConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-rainbow.browser.esm-PKIDEW2Z.js");
        const rainbowConnector = new RainbowConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.rainbowConnector = rainbowConnector;
        this.connector = new WagmiAdapter(rainbowConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-FV443MXD.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(RainbowWallet, "meta", {
  name: "Rainbow Wallet",
  iconURL: "ipfs://QmSZn47p4DVVBfzvg9BAX2EqwnPxkT1YAE7rUnrtd9CybQ/rainbow-logo.png",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/rainbow/opfgelmcmbiajamepnmloijbpoleiama",
    android: "https://rnbwapp.com/e/Va41HWS6Oxb",
    ios: "https://rnbwapp.com/e/OeMdmkJ6Oxb"
  }
});
_defineProperty(RainbowWallet, "id", walletIds.rainbow);

// node_modules/@thirdweb-dev/wallets/evm/wallets/safe/dist/thirdweb-dev-wallets-evm-wallets-safe.browser.esm.js
init_shim();
init_lib3();
var SafeWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Safe Wallet";
  }
  constructor(options) {
    super(SafeWallet.id, {
      ...options
    });
  }
  async getConnector() {
    if (!this.connector) {
      const {
        SafeConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-safe.browser.esm-UOY4GS77.js");
      this.connector = new SafeConnector();
    }
    return this.connector;
  }
  async updateChains(chains) {
  }
  getPersonalWallet() {
    var _a;
    return (_a = this.connector) == null ? void 0 : _a.personalWallet;
  }
  autoConnect(params) {
    return this.connect(params);
  }
};
_defineProperty(SafeWallet, "meta", {
  name: "Safe",
  iconURL: "ipfs://QmbbyxDDmmLQh8DzzeUR6X6B75bESsNUFmbdvS3ZsQ2pN1/SafeToken.svg"
});
_defineProperty(SafeWallet, "id", walletIds.safe);

// node_modules/@thirdweb-dev/wallets/evm/wallets/smart-wallet/dist/thirdweb-dev-wallets-evm-wallets-smart-wallet.browser.esm.js
init_shim();
init_lib3();
var sdkCache = /* @__PURE__ */ new Map();
function getSDK(chain) {
  const cached = sdkCache.get(chain);
  if (cached) {
    return cached;
  }
  const sdk = new ThirdwebSDK(chain);
  sdkCache.set(chain, sdk);
  return sdk;
}
async function getAllSigners(chain, factoryAddress, smartWalletAddress) {
  const readOnlySDK = getSDK(chain);
  const factoryContract = await readOnlySDK.getContract(factoryAddress);
  const signers = await factoryContract.call("getSignersOfAccount", [smartWalletAddress]);
  return signers;
}
async function getAllSmartWallets(chain, factoryAddress, personalWalletAddress) {
  const readOnlySDK = getSDK(chain);
  const factoryContract = await readOnlySDK.getContract(factoryAddress);
  const ownedAccount = await getSmartWalletAddress(chain, factoryAddress, personalWalletAddress);
  const accessibleAccounts = await factoryContract.call("getAccountsOfSigner", [personalWalletAddress]);
  return {
    owned: ownedAccount,
    hasSignerRole: accessibleAccounts
  };
}
async function isSmartWalletDeployed(chain, factoryAddress, personalWalletAddress) {
  let data = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "0x";
  const readOnlySDK = getSDK(chain);
  const factoryContract = await readOnlySDK.getContract(factoryAddress);
  const accountAddress = await factoryContract.call("getAddress", [personalWalletAddress, data]);
  const isDeployed = await isContractDeployed(accountAddress, readOnlySDK.getProvider());
  return isDeployed;
}
async function getSmartWalletAddress(chain, factoryAddress, personalWalletAddress) {
  let data = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "0x";
  const readOnlySDK = getSDK(chain);
  const factoryContract = await readOnlySDK.getContract(factoryAddress);
  const accountAddress = await factoryContract.call("getAddress", [personalWalletAddress, data]);
  return accountAddress;
}
var SmartWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Smart Wallet";
  }
  constructor(options) {
    if (options.clientId && typeof options.chain === "object") {
      try {
        options.chain = {
          ...options.chain,
          rpc: getValidChainRPCs(options.chain, options.clientId)
        };
      } catch {
      }
    }
    super(SmartWallet.id, {
      ...options
    });
  }
  async getConnector() {
    if (!this.connector) {
      const {
        SmartWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-smart-wallet.browser.esm-MKPQVSDN.js");
      this.connector = new SmartWalletConnector(this.options);
    }
    return this.connector;
  }
  getPersonalWallet() {
    var _a;
    return (_a = this.connector) == null ? void 0 : _a.personalWallet;
  }
  async hasPermissionToExecute(transaction) {
    const connector = await this.getConnector();
    return connector.hasPermissionToExecute(transaction);
  }
  async send(transaction) {
    const connector = await this.getConnector();
    return connector.send(transaction);
  }
  async execute(transaction) {
    const connector = await this.getConnector();
    return connector.execute(transaction);
  }
  async sendBatch(transactions) {
    const connector = await this.getConnector();
    return connector.sendBatch(transactions);
  }
  async executeBatch(transactions) {
    const connector = await this.getConnector();
    return connector.executeBatch(transactions);
  }
  async sendRaw(transaction) {
    const connector = await this.getConnector();
    return connector.sendRaw(transaction);
  }
  async executeRaw(transaction) {
    const connector = await this.getConnector();
    return connector.executeRaw(transaction);
  }
  async estimate(transaction) {
    const connector = await this.getConnector();
    return connector.estimate(transaction);
  }
  async estimateBatch(transactions) {
    const connector = await this.getConnector();
    return connector.estimateBatch(transactions);
  }
  async estimateRaw(transactions) {
    const connector = await this.getConnector();
    return connector.estimateRaw(transactions);
  }
  async estimateBatchRaw(transactions) {
    const connector = await this.getConnector();
    return connector.estimateBatchRaw(transactions);
  }
  async sendBatchRaw(transactions) {
    const connector = await this.getConnector();
    return connector.sendBatchRaw(transactions);
  }
  async executeBatchRaw(transactions) {
    const connector = await this.getConnector();
    return connector.executeBatchRaw(transactions);
  }
  async deploy() {
    const connector = await this.getConnector();
    return connector.deploy();
  }
  async deployIfNeeded() {
    const connector = await this.getConnector();
    return connector.deployIfNeeded();
  }
  async isDeployed() {
    const connector = await this.getConnector();
    return connector.isDeployed();
  }
  async createSessionKey(keyAddress, permissions) {
    const connector = await this.getConnector();
    return connector.grantPermissions(keyAddress, permissions);
  }
  async revokeSessionKey(keyAddress) {
    const connector = await this.getConnector();
    return connector.revokePermissions(keyAddress);
  }
  async addAdmin(adminAddress) {
    const connector = await this.getConnector();
    return connector.addAdmin(adminAddress);
  }
  async removeAdmin(adminAddress) {
    const connector = await this.getConnector();
    return connector.removeAdmin(adminAddress);
  }
  async getAllActiveSigners() {
    const connector = await this.getConnector();
    return connector.getAllActiveSigners();
  }
  async getAccountContract() {
    const connector = await this.getConnector();
    return connector.getAccountContract();
  }
  async getFactoryContract() {
    const connector = await this.getConnector();
    return connector.getFactoryContract();
  }
  autoConnect(params) {
    return this.connect(params);
  }
};
_defineProperty(SmartWallet, "meta", {
  name: "Smart Wallet",
  iconURL: "ipfs://QmeAJVqn17aDNQhjEU3kcWVZCFBrfta8LzaDGkS8Egdiyk/smart-wallet.svg"
});
_defineProperty(SmartWallet, "id", walletIds.smartWallet);

// node_modules/@thirdweb-dev/wallets/evm/wallets/trust/dist/thirdweb-dev-wallets-evm-wallets-trust.browser.esm.js
init_shim();
init_lib3();
var TrustWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Trust Wallet";
  }
  constructor(options) {
    var _a;
    super(TrustWallet.id, options);
    if (assertWindowEthereum(globalThis.window)) {
      this.isInjected = !!((_a = globalThis.window.ethereum) == null ? void 0 : _a.isTrust);
    } else {
      this.isInjected = false;
    }
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          TrustConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-trust.browser.esm-5EHTQZ3P.js");
        const trustConnector = new TrustConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.trustConnector = trustConnector;
        this.connector = new WagmiAdapter(trustConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-FV443MXD.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(TrustWallet, "meta", {
  name: "Trust Wallet",
  iconURL: "ipfs://QmNigQbXk7wKZwDcgN38Znj1ZZQ3JEG3DD6fUKLBU8SUTP/trust%20wallet.svg",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/trust-wallet/egjidjbpglichdcondbcbdnbeeppgdph",
    android: "https://play.google.com/store/apps/details?id=com.wallet.crypto.trustapp",
    ios: "https://apps.apple.com/us/app/trust-crypto-bitcoin-wallet/id1288339409"
  }
});
_defineProperty(TrustWallet, "id", walletIds.trust);

// node_modules/@thirdweb-dev/wallets/evm/wallets/wallet-connect/dist/thirdweb-dev-wallets-evm-wallets-wallet-connect.browser.esm.js
init_shim();
init_lib3();
var _walletConnectConnector = /* @__PURE__ */ new WeakMap();
var _provider = /* @__PURE__ */ new WeakMap();
var _maybeThrowError = /* @__PURE__ */ new WeakMap();
var _onConnect = /* @__PURE__ */ new WeakMap();
var _onDisconnect = /* @__PURE__ */ new WeakMap();
var _onChange = /* @__PURE__ */ new WeakMap();
var _onMessage = /* @__PURE__ */ new WeakMap();
var _onSessionRequestSent = /* @__PURE__ */ new WeakMap();
var _setupListeners = /* @__PURE__ */ new WeakSet();
var _removeListeners = /* @__PURE__ */ new WeakSet();
var WalletConnect = class extends AbstractClientWallet {
  get walletName() {
    return "WalletConnect";
  }
  constructor(options) {
    super((options == null ? void 0 : options.walletId) || WalletConnect.id, options);
    _classPrivateMethodInitSpec(this, _removeListeners);
    _classPrivateMethodInitSpec(this, _setupListeners);
    _classPrivateFieldInitSpec(this, _walletConnectConnector, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _provider, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _maybeThrowError, {
      writable: true,
      value: (error) => {
        if (error) {
          throw error;
        }
      }
    });
    _classPrivateFieldInitSpec(this, _onConnect, {
      writable: true,
      value: (data) => {
        _classPrivateFieldSet(this, _provider, data.provider);
        if (!_classPrivateFieldGet(this, _provider)) {
          throw new Error("WalletConnect provider not found after connecting.");
        }
      }
    });
    _classPrivateFieldInitSpec(this, _onDisconnect, {
      writable: true,
      value: () => {
        _classPrivateMethodGet(this, _removeListeners, _removeListeners2).call(this);
      }
    });
    _classPrivateFieldInitSpec(this, _onChange, {
      writable: true,
      value: async (payload) => {
        if (payload.chain)
          ;
        else if (payload.account)
          ;
      }
    });
    _classPrivateFieldInitSpec(this, _onMessage, {
      writable: true,
      value: (payload) => {
        switch (payload.type) {
          case "display_uri":
            this.emit("display_uri", payload.data);
            break;
        }
      }
    });
    _classPrivateFieldInitSpec(this, _onSessionRequestSent, {
      writable: true,
      value: () => {
        this.emit("wc_session_request_sent");
      }
    });
    this.projectId = (options == null ? void 0 : options.projectId) || TW_WC_PROJECT_ID;
    this.qrcode = (options == null ? void 0 : options.qrcode) === false ? false : true;
  }
  async getConnector() {
    var _a;
    if (!this.connector) {
      const {
        WalletConnectConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-FV443MXD.js");
      _classPrivateFieldSet(this, _walletConnectConnector, new WalletConnectConnector({
        chains: this.chains,
        options: {
          qrcode: this.qrcode,
          projectId: this.projectId,
          dappMetadata: this.dappMetadata,
          storage: this.walletStorage,
          qrModalOptions: (_a = this.options) == null ? void 0 : _a.qrModalOptions
        }
      }));
      this.connector = new WagmiAdapter(_classPrivateFieldGet(this, _walletConnectConnector));
      _classPrivateFieldSet(this, _provider, await _classPrivateFieldGet(this, _walletConnectConnector).getProvider());
      _classPrivateMethodGet(this, _setupListeners, _setupListeners2).call(this);
    }
    return this.connector;
  }
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = _classPrivateFieldGet(this, _walletConnectConnector);
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
function _setupListeners2() {
  var _a;
  if (!_classPrivateFieldGet(this, _walletConnectConnector)) {
    return;
  }
  _classPrivateMethodGet(this, _removeListeners, _removeListeners2).call(this);
  _classPrivateFieldGet(this, _walletConnectConnector).on("connect", _classPrivateFieldGet(this, _onConnect));
  _classPrivateFieldGet(this, _walletConnectConnector).on("disconnect", _classPrivateFieldGet(this, _onDisconnect));
  _classPrivateFieldGet(this, _walletConnectConnector).on("change", _classPrivateFieldGet(this, _onChange));
  _classPrivateFieldGet(this, _walletConnectConnector).on("message", _classPrivateFieldGet(this, _onMessage));
  (_a = _classPrivateFieldGet(this, _provider)) == null ? void 0 : _a.signer.client.on("session_request_sent", _classPrivateFieldGet(this, _onSessionRequestSent));
}
function _removeListeners2() {
  var _a;
  if (!_classPrivateFieldGet(this, _walletConnectConnector)) {
    return;
  }
  _classPrivateFieldGet(this, _walletConnectConnector).removeListener("connect", _classPrivateFieldGet(this, _onConnect));
  _classPrivateFieldGet(this, _walletConnectConnector).removeListener("disconnect", _classPrivateFieldGet(this, _onDisconnect));
  _classPrivateFieldGet(this, _walletConnectConnector).removeListener("change", _classPrivateFieldGet(this, _onChange));
  _classPrivateFieldGet(this, _walletConnectConnector).removeListener("message", _classPrivateFieldGet(this, _onMessage));
  (_a = _classPrivateFieldGet(this, _provider)) == null ? void 0 : _a.signer.client.removeListener("session_request_sent", _classPrivateFieldGet(this, _onSessionRequestSent));
}
_defineProperty(WalletConnect, "id", walletIds.walletConnect);
_defineProperty(WalletConnect, "meta", {
  name: "WalletConnect",
  iconURL: "ipfs://QmX58KPRaTC9JYZ7KriuBzeoEaV2P9eZcA3qbFnTHZazKw/wallet-connect.svg"
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/wallet-connect-v1/dist/thirdweb-dev-wallets-evm-wallets-wallet-connect-v1.browser.esm.js
init_shim();
init_lib3();
var WalletConnectV1 = WalletConnect;

// node_modules/@thirdweb-dev/wallets/evm/wallets/zerion/dist/thirdweb-dev-wallets-evm-wallets-zerion.browser.esm.js
init_shim();
init_lib3();
var ZerionWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Zerion Wallet";
  }
  constructor(options) {
    var _a;
    super(ZerionWallet.id, options);
    if (assertWindowEthereum(globalThis.window)) {
      this.isInjected = !!((_a = globalThis.window.ethereum) == null ? void 0 : _a.isZerion);
    } else {
      this.isInjected = false;
    }
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          ZerionConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-zerion.browser.esm-MKKVTGNR.js");
        const zerionConnector = new ZerionConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.zerionConnector = zerionConnector;
        this.connector = new WagmiAdapter(zerionConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-FV443MXD.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(ZerionWallet, "id", "zerion");
_defineProperty(ZerionWallet, "meta", {
  name: "Zerion Wallet",
  iconURL: "ipfs://Qmb1LhNtMUkzbgk1V8ZiUSRXjMJGRkS5HH3R71KyRgjdBG/zerion.png",
  urls: {
    chrome: "https://zerion.io/extension",
    android: "https://link.zerion.io/901o6IN0jqb",
    ios: "https://link.zerion.io/a11o6IN0jqb"
  }
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/token-bound-smart-wallet/dist/thirdweb-dev-wallets-evm-wallets-token-bound-smart-wallet.browser.esm.js
init_shim();
init_lib3();
var TokenBoundSmartWallet = class extends SmartWallet {
  get walletName() {
    return "Token Bound Smart Wallet";
  }
  constructor(options) {
    super({
      ...options,
      factoryAddress: options.registryAddress || ERC6551_REGISTRY
    });
    this.tbaOptions = options;
  }
  async getConnector() {
    if (!this.tbaConnector) {
      const {
        TokenBoundSmartWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-token-bound-smart-wallet.browser.esm-W4XCBR2Y.js");
      this.tbaConnector = new TokenBoundSmartWalletConnector(this.tbaOptions);
    }
    return this.tbaConnector;
  }
};
_defineProperty(TokenBoundSmartWallet, "meta", {
  name: "Token Bound Smart Wallet",
  iconURL: "ipfs://QmeAJVqn17aDNQhjEU3kcWVZCFBrfta8LzaDGkS8Egdiyk/smart-wallet.svg"
});
_defineProperty(TokenBoundSmartWallet, "id", walletIds.tokenBoundSmartWallet);

// node_modules/@thirdweb-dev/wallets/dist/thirdweb-dev-wallets.browser.esm.js
var import_buffer2 = __toESM(require_buffer());
var import_utils4 = __toESM(require_utils());
var PREFIX2 = "__TW__";
var LocalStorage = class {
  constructor(name) {
    this.name = name;
  }
  getItem(key) {
    return localStorage.getItem(`${PREFIX2}/${this.name}/${key}`);
  }
  setItem(key, value) {
    return localStorage.setItem(`${PREFIX2}/${this.name}/${key}`, value);
  }
  removeItem(key) {
    return localStorage.removeItem(`${PREFIX2}/${this.name}/${key}`);
  }
};
function createLocalStorage(name) {
  return new LocalStorage(name);
}
var CredentialsStorage = class {
  async getItem() {
    const credential = await navigator.credentials.get({
      password: true,
      unmediated: true
    });
    if (credential && "password" in credential) {
      return credential.password;
    }
    return null;
  }
  async setItem(key, value) {
    const credential = await navigator.credentials.create({
      password: {
        id: key,
        name: key,
        password: value
      }
    });
    if (!credential) {
      throw new Error("Credential not created");
    }
    await navigator.credentials.store(credential);
  }
  async removeItem() {
    const credential = await navigator.credentials.get({
      password: true,
      unmediated: true
    });
    if (credential) {
      await navigator.credentials.preventSilentAccess();
    }
  }
};
var WalletConnectHandler = class extends eventemitter3_default {
  constructor(wallet) {
    super();
    this.wallet = wallet;
  }
};
var _core = /* @__PURE__ */ new WeakMap();
var _wcWallet = /* @__PURE__ */ new WeakMap();
var _session = /* @__PURE__ */ new WeakMap();
var _wcMetadata = /* @__PURE__ */ new WeakMap();
var _activeProposal = /* @__PURE__ */ new WeakMap();
var _activeRequestEvent = /* @__PURE__ */ new WeakMap();
var _setupWalletConnectEventsListeners = /* @__PURE__ */ new WeakSet();
var _getSignParamsMessage = /* @__PURE__ */ new WeakSet();
var WalletConnectV2Handler = class extends WalletConnectHandler {
  constructor(options, wallet) {
    super(wallet);
    _classPrivateMethodInitSpec(this, _getSignParamsMessage);
    _classPrivateMethodInitSpec(this, _setupWalletConnectEventsListeners);
    _classPrivateFieldInitSpec(this, _core, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _wcWallet, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _session, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _wcMetadata, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _activeProposal, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _activeRequestEvent, {
      writable: true,
      value: void 0
    });
    const defaultWCReceiverConfig = {
      walletConnectWalletMetadata: {
        name: "Thirdweb Smart Wallet",
        description: "Thirdweb Smart Wallet",
        url: "https://thirdweb.com",
        icons: ["https://thirdweb.com/favicon.ico"]
      },
      walletConnectV2ProjectId: TW_WC_PROJECT_ID,
      walletConnectV2RelayUrl: WC_RELAY_URL,
      ...(options == null ? void 0 : options.walletConnectReceiver) === true ? {} : options == null ? void 0 : options.walletConnectReceiver
    };
    _classPrivateFieldSet(this, _wcMetadata, defaultWCReceiverConfig.walletConnectWalletMetadata);
    _classPrivateFieldSet(this, _core, new zr({
      projectId: defaultWCReceiverConfig.walletConnectV2ProjectId,
      relayUrl: defaultWCReceiverConfig.walletConnectV2RelayUrl
    }));
  }
  async init() {
    _classPrivateFieldSet(this, _wcWallet, await G4.init({
      core: _classPrivateFieldGet(this, _core),
      metadata: _classPrivateFieldGet(this, _wcMetadata)
    }));
    const sessions = _classPrivateFieldGet(this, _wcWallet).getActiveSessions();
    const keys = Object.keys(sessions);
    if (keys[0]) {
      _classPrivateFieldSet(this, _session, sessions[keys[0]]);
    }
    _classPrivateMethodGet(this, _setupWalletConnectEventsListeners, _setupWalletConnectEventsListeners2).call(this);
  }
  async connectApp(wcUri) {
    if (!_classPrivateFieldGet(this, _wcWallet)) {
      throw new Error("Please, init the wallet before connecting an app.");
    }
    await _classPrivateFieldGet(this, _wcWallet).core.pairing.pair({
      uri: wcUri
    });
  }
  async approveSession() {
    var _a;
    if (!_classPrivateFieldGet(this, _wcWallet)) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    if (!_classPrivateFieldGet(this, _activeProposal)) {
      throw new Error("Please, pass a valid proposal.");
    }
    const account = await this.wallet.getAddress();
    const {
      id,
      params
    } = _classPrivateFieldGet(this, _activeProposal);
    const {
      requiredNamespaces,
      relays
    } = params;
    const namespaces = {};
    Object.keys(requiredNamespaces).forEach((key) => {
      var _a2;
      const accounts = [];
      const namespace = requiredNamespaces[key];
      if (namespace) {
        (_a2 = namespace.chains) == null ? void 0 : _a2.map((chain) => {
          accounts.push(`${chain}:${account}`);
        });
        namespaces[key] = {
          accounts,
          methods: namespace.methods,
          events: namespace.events
        };
      }
    });
    _classPrivateFieldSet(this, _session, await _classPrivateFieldGet(this, _wcWallet).approveSession({
      id,
      relayProtocol: (_a = relays[0]) == null ? void 0 : _a.protocol,
      namespaces
    }));
    this.emit("session_approved");
  }
  async rejectSession() {
    if (!_classPrivateFieldGet(this, _wcWallet)) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    if (!_classPrivateFieldGet(this, _activeProposal)) {
      throw new Error("Please, pass a valid proposal.");
    }
    const {
      id
    } = _classPrivateFieldGet(this, _activeProposal);
    await _classPrivateFieldGet(this, _wcWallet).rejectSession({
      id,
      reason: {
        message: "User rejected methods.",
        code: 5002
      }
    });
  }
  async approveEIP155Request() {
    var _a, _b;
    if (!_classPrivateFieldGet(this, _activeRequestEvent)) {
      return;
    }
    const {
      topic,
      params,
      id
    } = _classPrivateFieldGet(this, _activeRequestEvent);
    const {
      request
    } = params;
    let response;
    switch (request.method) {
      case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
      case EIP155_SIGNING_METHODS.ETH_SIGN:
        const message = _classPrivateMethodGet(this, _getSignParamsMessage, _getSignParamsMessage2).call(this, request.params);
        const signedMessage = await this.wallet.signMessage(message || "");
        response = formatJsonRpcResult(id, signedMessage);
        break;
      case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
        const signer = await this.wallet.getSigner();
        const sendTransaction = request.params[0];
        const tx = await signer.sendTransaction(sendTransaction);
        const {
          transactionHash
        } = await tx.wait();
        response = formatJsonRpcResult(id, transactionHash);
        break;
      case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
        const signerSign = await this.wallet.getSigner();
        const signTransaction = request.params[0];
        const signature = await signerSign.signTransaction(signTransaction);
        response = formatJsonRpcResult(id, signature);
        break;
      default:
        const error = {
          id,
          jsonrpc: "2.0",
          error: {
            message: "Invalid event.",
            code: 1002
          }
        };
        return (_a = _classPrivateFieldGet(this, _wcWallet)) == null ? void 0 : _a.respondSessionRequest({
          topic,
          response: error
        });
    }
    return (_b = _classPrivateFieldGet(this, _wcWallet)) == null ? void 0 : _b.respondSessionRequest({
      topic,
      response
    });
  }
  async rejectEIP155Request() {
    var _a;
    if (!_classPrivateFieldGet(this, _activeRequestEvent)) {
      return;
    }
    const {
      topic,
      id
    } = _classPrivateFieldGet(this, _activeRequestEvent);
    const response = {
      id,
      jsonrpc: "2.0",
      error: {
        message: "User rejected methods.",
        code: 5002
      }
    };
    return (_a = _classPrivateFieldGet(this, _wcWallet)) == null ? void 0 : _a.respondSessionRequest({
      topic,
      response
    });
  }
  getActiveSessions() {
    if (!_classPrivateFieldGet(this, _wcWallet)) {
      throw new Error("Please, init the wallet before getting sessions.");
    }
    const sessions = _classPrivateFieldGet(this, _wcWallet).getActiveSessions();
    const sessionKeys = Object.keys(sessions);
    if (!sessions || sessionKeys.length === 0) {
      return [];
    }
    const thisSessions = [];
    for (const sessionKey of sessionKeys) {
      const session = sessions[sessionKey];
      if (session) {
        const topic = session.topic;
        const peerMeta = session.peer.metadata;
        thisSessions.push({
          topic,
          peer: {
            metadata: peerMeta
          }
        });
      }
    }
    return thisSessions;
  }
  disconnectSession() {
    var _a;
    if (!_classPrivateFieldGet(this, _wcWallet)) {
      throw new Error("Please, init the wallet before disconnecting sessions.");
    }
    if (!_classPrivateFieldGet(this, _session)) {
      return Promise.resolve();
    }
    const params = {
      topic: _classPrivateFieldGet(this, _session).topic,
      reason: {
        message: "User disconnected.",
        code: 6e3
      }
    };
    return (_a = _classPrivateFieldGet(this, _wcWallet)) == null ? void 0 : _a.disconnectSession(params);
  }
};
function _setupWalletConnectEventsListeners2() {
  if (!_classPrivateFieldGet(this, _wcWallet)) {
    throw new Error("Please, init the wallet before making session requests.");
  }
  _classPrivateFieldGet(this, _wcWallet).on("session_proposal", (proposal) => {
    _classPrivateFieldSet(this, _activeProposal, proposal);
    this.emit("session_proposal", {
      proposer: {
        metadata: proposal.params.proposer.metadata
      }
    });
  });
  _classPrivateFieldGet(this, _wcWallet).on("session_delete", (session) => {
    _classPrivateFieldSet(this, _session, void 0);
    _classPrivateFieldSet(this, _activeProposal, void 0);
    this.emit("session_delete", {
      topic: session.topic
    });
  });
  _classPrivateFieldGet(this, _wcWallet).on("session_request", async (requestEvent) => {
    if (!_classPrivateFieldGet(this, _session)) {
      return;
    }
    const {
      params: requestParams
    } = requestEvent;
    const {
      request
    } = requestParams;
    const {
      params
    } = request;
    switch (request.method) {
      case EIP155_SIGNING_METHODS.ETH_SIGN:
      case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
        _classPrivateFieldSet(this, _activeRequestEvent, requestEvent);
        const message = params[0];
        const decodedMessage = new TextDecoder().decode(utils_exports.arrayify(message));
        const paramsCopy = [...params];
        paramsCopy[0] = decodedMessage;
        this.emit("session_request", {
          topic: _classPrivateFieldGet(this, _session).topic,
          params: paramsCopy,
          peer: {
            metadata: _classPrivateFieldGet(this, _session).peer.metadata
          },
          method: request.method
        });
        return;
      case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
      case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
        _classPrivateFieldSet(this, _activeRequestEvent, requestEvent);
        this.emit("session_request", {
          topic: _classPrivateFieldGet(this, _session).topic,
          params: requestEvent.params.request.params,
          peer: {
            metadata: _classPrivateFieldGet(this, _session).peer.metadata
          },
          method: request.method
        });
        return;
      default:
        throw new Error(`WCV2.Method not supported: ${request.method}`);
    }
  });
}
function _getSignParamsMessage2(params) {
  const message = params.filter((p4) => !utils_exports.isAddress(p4))[0] || "";
  if (utils_exports.isHexString(message)) {
    return utils_exports.toUtf8String(message);
  }
  return message;
}

export {
  EIP155_SIGNING_METHODS,
  AsyncLocalStorage,
  createAsyncLocalStorage,
  DEFAULT_DAPP_META,
  isWalletAnalyticsEnabled,
  setWalletAnalyticsEnabled,
  AbstractClientWallet,
  OKXWallet,
  CoreWallet,
  getInjectedCoinbaseProvider,
  PaperWallet,
  BloctoWallet,
  CoinbaseWallet,
  EmbeddedWallet,
  EthersWallet,
  FrameWallet,
  InjectedWallet,
  LocalWallet,
  isValidPrivateKey,
  SignerWallet,
  MagicLink,
  MetaMaskWallet,
  PhantomWallet,
  PrivateKeyWallet,
  RainbowWallet,
  SafeWallet,
  getAllSigners,
  getAllSmartWallets,
  isSmartWalletDeployed,
  getSmartWalletAddress,
  SmartWallet,
  TrustWallet,
  WalletConnect,
  WalletConnectV1,
  ZerionWallet,
  TokenBoundSmartWallet,
  LocalStorage,
  createLocalStorage,
  CredentialsStorage,
  WalletConnectHandler,
  WalletConnectV2Handler
};
//# sourceMappingURL=chunk-6JWXQSCU.js.map
