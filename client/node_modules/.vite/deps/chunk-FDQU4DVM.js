import {
  resolveOrGenerateId
} from "./chunk-VQJOYVXP.js";
import {
  EndDateSchema,
  StartDateSchema,
  assertEnabled
} from "./chunk-D3VDM4TG.js";
import {
  ContractEvents,
  detectContractFeature
} from "./chunk-UEMNZHIS.js";
import {
  AbiSchema,
  AddressOrEnsSchema,
  AddressZero,
  AmountSchema,
  DEPLOYER_ABI,
  DEPLOYER_BYTECODE,
  FEATURE_ACCOUNT,
  FEATURE_ACCOUNT_FACTORY,
  FEATURE_ACCOUNT_PERMISSIONS,
  GAS_LIMIT_FOR_DEPLOYER,
  Transaction,
  buildTransactionFunction,
  caches,
  computeDeploymentInfo,
  extractCommentFromMetadata,
  extractFunctionsFromAbi,
  fetchAndCacheDeployMetadata,
  fetchContractMetadataFromAddress,
  fetchPublishedContractFromPolygon,
  fetchSourceFilesFromMetadata,
  getCreate2FactoryAddress,
  invariant,
  isContractDeployed,
  resolveAddress,
  z
} from "./chunk-3RUZ5SWH.js";
import {
  ContractFactory,
  init_lib7 as init_lib,
  utils_exports
} from "./chunk-FA7CNXA4.js";
import {
  BigNumber
} from "./chunk-7GXO2BXT.js";
import {
  init_shim
} from "./chunk-6SWLQQ3Q.js";
import {
  __publicField
} from "./chunk-GN3OLCG2.js";

// node_modules/@thirdweb-dev/sdk/dist/account-factory-f15458e0.browser.esm.js
init_shim();
init_lib();
function extractEventsFromAbi(abi, metadata) {
  const parsedAbi = AbiSchema.parse(abi || []);
  const events = parsedAbi.filter((el) => el.type === "event");
  const parsed = [];
  for (const e of events) {
    const doc = extractCommentFromMetadata(e.name, metadata, "events");
    parsed.push({
      inputs: e.inputs || [],
      outputs: e.outputs || [],
      name: e.name || "unknown",
      comment: doc
    });
  }
  return parsed;
}
var ContractPublishedMetadata = class {
  constructor(contractWrapper, storage) {
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
  async get() {
    if (this._cachedMetadata) {
      return this._cachedMetadata;
    }
    this._cachedMetadata = await fetchContractMetadataFromAddress(this.contractWrapper.address, this.contractWrapper.getProvider(), this.storage, this.contractWrapper.options);
    return this._cachedMetadata;
  }
  async extractSources() {
    const publishedMetadata = await this.get();
    return fetchSourceFilesFromMetadata(publishedMetadata, this.storage);
  }
  async extractFunctions() {
    let publishedMetadata;
    try {
      publishedMetadata = await this.get();
    } catch (e) {
    }
    return extractFunctionsFromAbi(AbiSchema.parse(this.contractWrapper.abi), publishedMetadata == null ? void 0 : publishedMetadata.metadata);
  }
  async extractEvents() {
    let publishedMetadata;
    try {
      publishedMetadata = await this.get();
    } catch (e) {
    }
    return extractEventsFromAbi(AbiSchema.parse(this.contractWrapper.abi), publishedMetadata == null ? void 0 : publishedMetadata.metadata);
  }
};
var AdminFlag = function(AdminFlag2) {
  AdminFlag2[AdminFlag2["None"] = 0] = "None";
  AdminFlag2[AdminFlag2["AddAdmin"] = 1] = "AddAdmin";
  AdminFlag2[AdminFlag2["RemoveAdmin"] = 2] = "RemoveAdmin";
  return AdminFlag2;
}({});
var DEFAULT_PERMISSIONS = {
  startDate: BigNumber.from(0),
  expirationDate: BigNumber.from(0),
  approvedCallTargets: [],
  nativeTokenLimitPerTransaction: "0"
};
var SignerPermissionsSchema = (() => z.object({
  startDate: StartDateSchema,
  expirationDate: EndDateSchema,
  nativeTokenLimitPerTransaction: AmountSchema.default(0),
  approvedCallTargets: z.union([z.array(AddressOrEnsSchema), z.literal("*")])
}))();
var PermissionSnapshotSchema = (() => z.array(z.object({
  signer: AddressOrEnsSchema,
  makeAdmin: z.boolean(),
  permissions: SignerPermissionsSchema
})))();
var SignerPermissionRequestV1 = [{
  name: "signer",
  type: "address"
}, {
  name: "approvedTargets",
  type: "address[]"
}, {
  name: "nativeTokenLimitPerTransaction",
  type: "uint256"
}, {
  name: "permissionStartTimestamp",
  type: "uint128"
}, {
  name: "permissionEndTimestamp",
  type: "uint128"
}, {
  name: "reqValidityStartTimestamp",
  type: "uint128"
}, {
  name: "reqValidityEndTimestamp",
  type: "uint128"
}, {
  name: "uid",
  type: "bytes32"
}];
var SignerPermissionRequest = [{
  name: "signer",
  type: "address"
}, {
  name: "isAdmin",
  type: "uint8"
}, {
  name: "approvedTargets",
  type: "address[]"
}, {
  name: "nativeTokenLimitPerTransaction",
  type: "uint256"
}, {
  name: "permissionStartTimestamp",
  type: "uint128"
}, {
  name: "permissionEndTimestamp",
  type: "uint128"
}, {
  name: "reqValidityStartTimestamp",
  type: "uint128"
}, {
  name: "reqValidityEndTimestamp",
  type: "uint128"
}, {
  name: "uid",
  type: "bytes32"
}];
var AccountPermissions = class {
  constructor(contractWrapper) {
    __publicField(this, "featureName", FEATURE_ACCOUNT_PERMISSIONS.name);
    __publicField(this, "grantAdminPermissions", buildTransactionFunction(async (signerAddress) => {
      const resolvedSignerAddress = await resolveAddress(signerAddress);
      return await this.sendSignerPermissionRequest(resolvedSignerAddress, DEFAULT_PERMISSIONS, AdminFlag.AddAdmin);
    }));
    __publicField(this, "revokeAdminPermissions", buildTransactionFunction(async (signerAddress) => {
      const resolvedSignerAddress = await resolveAddress(signerAddress);
      return await this.sendSignerPermissionRequest(resolvedSignerAddress, DEFAULT_PERMISSIONS, AdminFlag.RemoveAdmin);
    }));
    __publicField(this, "grantPermissions", buildTransactionFunction(async (signerAddress, permissions) => {
      const resolvedSignerAddress = await resolveAddress(signerAddress);
      const resolvedPermissions = await SignerPermissionsSchema.parseAsync(permissions);
      if (await this.isAdmin(resolvedSignerAddress)) {
        throw new Error("Signer is already an admin. Cannot grant permissions to an existing admin.");
      }
      if (await this.isSigner(resolvedSignerAddress)) {
        throw new Error("Signer already has permissions. Cannot grant permissions to an existing signer. You can update permissions using `updatePermissions`.");
      }
      return await this.sendSignerPermissionRequest(resolvedSignerAddress, resolvedPermissions, AdminFlag.None);
    }));
    __publicField(this, "updatePermissions", buildTransactionFunction(async (signerAddress, permissions) => {
      const resolvedSignerAddress = await resolveAddress(signerAddress);
      const resolvedPermissions = await SignerPermissionsSchema.parseAsync(permissions);
      if (await this.isAdmin(resolvedSignerAddress)) {
        throw new Error("Signer is already an admin. Cannot update permissions of an existing admin.");
      }
      if (!await this.isSigner(resolvedSignerAddress)) {
        throw new Error("Signer does not already have permissions. You can grant permissions using `grantPermissions`.");
      }
      return await this.sendSignerPermissionRequest(resolvedSignerAddress, resolvedPermissions, AdminFlag.None);
    }));
    __publicField(this, "revokeAccess", buildTransactionFunction(async (signerAddress) => {
      const resolvedSignerAddress = await resolveAddress(signerAddress);
      if (await this.isAdmin(resolvedSignerAddress)) {
        throw new Error("Signer is already an admin. Cannot revoke permissions of an admin.");
      }
      if (!await this.isSigner(resolvedSignerAddress)) {
        throw new Error("Signer does not already have permissions. You can grant permissions using `grantPermissions`.");
      }
      return await this.sendSignerPermissionRequest(resolvedSignerAddress, {
        startDate: BigNumber.from(0),
        expirationDate: BigNumber.from(0),
        approvedCallTargets: [],
        nativeTokenLimitPerTransaction: "0"
      }, AdminFlag.None);
    }));
    __publicField(this, "approveTargetForSigner", buildTransactionFunction(async (signerAddress, target) => {
      const resolvedSignerAddress = await resolveAddress(signerAddress);
      const resolvedTarget = await resolveAddress(target);
      if (await this.isAdmin(resolvedSignerAddress)) {
        throw new Error("Signer is already an admin. Cannot approve targets for an admin.");
      }
      if (!await this.isSigner(resolvedSignerAddress)) {
        throw new Error("Signer does not already have permissions. You can grant permissions using `grantPermissions`.");
      }
      const permissions = await this.contractWrapper.read("getPermissionsForSigner", [resolvedSignerAddress]);
      if (permissions.approvedTargets.includes(target)) {
        throw new Error("Target is already approved");
      }
      const newTargets = [...permissions.approvedTargets, resolvedTarget];
      return await this.sendSignerPermissionRequest(resolvedSignerAddress, {
        startDate: BigNumber.from(permissions.startTimestamp),
        expirationDate: BigNumber.from(permissions.endTimestamp),
        approvedCallTargets: newTargets,
        nativeTokenLimitPerTransaction: permissions.nativeTokenLimitPerTransaction.toString()
      }, AdminFlag.None);
    }));
    __publicField(this, "disapproveTargetForSigner", buildTransactionFunction(async (signerAddress, target) => {
      const resolvedSignerAddress = await resolveAddress(signerAddress);
      const resolvedTarget = await resolveAddress(target);
      if (await this.isAdmin(resolvedSignerAddress)) {
        throw new Error("Signer is already an admin. Cannot approve targets for an admin.");
      }
      if (!await this.isSigner(resolvedSignerAddress)) {
        throw new Error("Signer does not already have permissions. You can grant permissions using `grantPermissions`.");
      }
      const permissions = await this.contractWrapper.read("getPermissionsForSigner", [resolvedSignerAddress]);
      if (!permissions.approvedTargets.includes(resolvedTarget)) {
        throw new Error("Target is currently not approved");
      }
      const newTargets = permissions.approvedTargets.filter((approvedTarget) => utils_exports.getAddress(approvedTarget) !== utils_exports.getAddress(resolvedTarget));
      return await this.sendSignerPermissionRequest(resolvedSignerAddress, {
        startDate: BigNumber.from(permissions.startTimestamp),
        expirationDate: BigNumber.from(permissions.endTimestamp),
        approvedCallTargets: newTargets,
        nativeTokenLimitPerTransaction: permissions.nativeTokenLimitPerTransaction.toString()
      }, AdminFlag.None);
    }));
    __publicField(this, "resetAllPermissions", buildTransactionFunction(async (permissionSnapshot) => {
      const resolvedSnapshot = await PermissionSnapshotSchema.parseAsync(permissionSnapshot);
      if (this.hasDuplicateSigners(resolvedSnapshot)) {
        throw new Error("Duplicate signers found in input.");
      }
      const removeAdminData = [];
      const addOrUpdateSignerData = [];
      const removeSignerData = [];
      const allAdmins = await this.getAllAdmins();
      const allToMakeAdmin = resolvedSnapshot.filter((item) => item.makeAdmin).map((item) => item.signer);
      allAdmins.forEach(async (admin) => {
        if (!allToMakeAdmin.includes(admin)) {
          const data2 = (await this.sendSignerPermissionRequest(admin, DEFAULT_PERMISSIONS, AdminFlag.RemoveAdmin)).encode();
          removeAdminData.push(data2);
        }
      });
      const allSigners = await this.getAllSigners();
      const allToMakeSigners = resolvedSnapshot.filter((item) => {
        return !item.makeAdmin;
      }).map((item) => item.signer);
      await Promise.all(allSigners.map(async (item) => {
        if (!allToMakeSigners.includes(item.signer)) {
          const data2 = (await this.sendSignerPermissionRequest(item.signer, DEFAULT_PERMISSIONS, AdminFlag.None)).encode();
          removeSignerData.push(data2);
        }
      }));
      for (const member of resolvedSnapshot) {
        if (member.makeAdmin) {
          (await this.sendSignerPermissionRequest(member.signer, DEFAULT_PERMISSIONS, AdminFlag.AddAdmin)).encode();
        } else {
          const data2 = (await this.sendSignerPermissionRequest(member.signer, member.permissions, AdminFlag.None)).encode();
          addOrUpdateSignerData.push(data2);
        }
      }
      const data = [];
      removeAdminData.forEach((item) => {
        data.push(item);
      });
      removeSignerData.forEach((item) => {
        data.push(item);
      });
      addOrUpdateSignerData.forEach((item) => {
        data.push(item);
      });
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "multicall",
        args: [data]
      });
    }));
    this.contractWrapper = contractWrapper;
  }
  getAddress() {
    return this.contractWrapper.address;
  }
  hasDuplicateSigners(snapshot) {
    const checkedSigner = {};
    const signers = snapshot.map((item) => item.signer);
    for (const signer of signers) {
      if (!checkedSigner[signer]) {
        checkedSigner[signer] = true;
      } else {
        return true;
      }
    }
    return false;
  }
  parseSignerPermissionsStruct(permissions) {
    return {
      startDate: new Date(parseInt(permissions.startTimestamp.toString()) * 1e3),
      expirationDate: new Date(parseInt(permissions.endTimestamp.toString()) * 1e3),
      nativeTokenLimitPerTransaction: BigNumber.from(permissions.nativeTokenLimitPerTransaction),
      approvedCallTargets: permissions.approvedTargets
    };
  }
  async sendSignerPermissionRequest(signerAddress, permissions, adminFlag) {
    if (detectContractFeature(this.contractWrapper, "AccountPermissionsV1")) {
      if (adminFlag === AdminFlag.AddAdmin || adminFlag === AdminFlag.RemoveAdmin) {
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "setAdmin",
          args: [signerAddress, adminFlag === AdminFlag.AddAdmin]
        });
      } else {
        const {
          payload: payload2,
          signature: signature2
        } = await this.generateLegacyPayload(signerAddress, permissions);
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "setPermissionsForSigner",
          args: [payload2, signature2]
        });
      }
    }
    const {
      payload,
      signature
    } = await this.generatePayload(signerAddress, permissions, adminFlag);
    return Transaction.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method: "setPermissionsForSigner",
      args: [payload, signature]
    });
  }
  async generatePayload(signerAddress, permissions, isAdmin) {
    const payload = {
      signer: signerAddress,
      isAdmin: isAdmin.valueOf(),
      approvedTargets: permissions.approvedCallTargets === "*" ? [AddressZero] : permissions.approvedCallTargets,
      nativeTokenLimitPerTransaction: utils_exports.parseEther(permissions.nativeTokenLimitPerTransaction),
      permissionStartTimestamp: permissions.startDate,
      permissionEndTimestamp: permissions.expirationDate,
      reqValidityStartTimestamp: 0,
      reqValidityEndTimestamp: BigNumber.from(Math.floor(new Date(Date.now() + 1e3 * 60 * 60 * 24 * 365 * 10).getTime() / 1e3)),
      uid: resolveOrGenerateId(void 0)
    };
    const chainId = await this.contractWrapper.getChainID();
    const connectedSigner = this.contractWrapper.getSigner();
    invariant(connectedSigner, "No signer available");
    const signature = await this.contractWrapper.signTypedData(connectedSigner, {
      name: "Account",
      version: "1",
      chainId,
      verifyingContract: this.getAddress()
    }, {
      SignerPermissionRequest
    }, payload);
    return {
      payload,
      signature
    };
  }
  async generateLegacyPayload(signerAddress, permissions) {
    if (permissions.approvedCallTargets === "*") {
      throw new Error("Wildcard call targets are not supported on legacy account permissions contract, please deploy an updated contract factory.");
    }
    const payload = {
      signer: signerAddress,
      approvedTargets: permissions.approvedCallTargets,
      nativeTokenLimitPerTransaction: utils_exports.parseEther(permissions.nativeTokenLimitPerTransaction),
      permissionStartTimestamp: permissions.startDate,
      permissionEndTimestamp: permissions.expirationDate,
      reqValidityStartTimestamp: 0,
      reqValidityEndTimestamp: BigNumber.from(Math.floor(new Date(Date.now() + 1e3 * 60 * 60 * 24 * 365 * 10).getTime() / 1e3)),
      uid: resolveOrGenerateId(void 0)
    };
    const chainId = await this.contractWrapper.getChainID();
    const connectedSigner = this.contractWrapper.getSigner();
    invariant(connectedSigner, "No signer available");
    const signature = await this.contractWrapper.signTypedData(connectedSigner, {
      name: "Account",
      version: "1",
      chainId,
      verifyingContract: this.getAddress()
    }, {
      SignerPermissionRequest: SignerPermissionRequestV1
    }, payload);
    return {
      payload,
      signature
    };
  }
  async isAdmin(signerAddress) {
    const resolvedSignerAddress = await resolveAddress(signerAddress);
    return await this.contractWrapper.read("isAdmin", [resolvedSignerAddress]);
  }
  async isSigner(signerAddress) {
    const resolvedSignerAddress = await resolveAddress(signerAddress);
    return await this.contractWrapper.read("isActiveSigner", [resolvedSignerAddress]);
  }
  async getAllAdmins() {
    return await this.contractWrapper.read("getAllAdmins", []);
  }
  async getAllSigners() {
    const activeSignersWithPerms = await this.contractWrapper.read("getAllActiveSigners", []);
    return await Promise.all(activeSignersWithPerms.map(async (signerWithPermissions) => {
      const signer = signerWithPermissions.signer;
      const permissions = this.parseSignerPermissionsStruct(signerWithPermissions);
      return {
        signer,
        permissions
      };
    }));
  }
  async getAllAdminsAndSigners() {
    const allAdmins = await this.getAllAdmins();
    const transformedAdmins = allAdmins.map((admin) => {
      return {
        isAdmin: true,
        signer: admin,
        permissions: {
          startDate: new Date(0),
          expirationDate: new Date(0),
          nativeTokenLimitPerTransaction: BigNumber.from(0),
          approvedCallTargets: []
        }
      };
    });
    const allSigners = await this.getAllSigners();
    return [...transformedAdmins, ...allSigners];
  }
};
var Account = class {
  constructor(contractWrapper) {
    __publicField(this, "featureName", FEATURE_ACCOUNT.name);
    __publicField(this, "grantAdminPermissions", buildTransactionFunction(async (signerAddress) => {
      return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).grantAdminPermissions.prepare(signerAddress);
    }));
    __publicField(this, "revokeAdminPermissions", buildTransactionFunction(async (signerAddress) => {
      return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).revokeAdminPermissions.prepare(signerAddress);
    }));
    __publicField(this, "grantPermissions", buildTransactionFunction(async (signerAddress, permissions) => {
      return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).grantPermissions.prepare(signerAddress, permissions);
    }));
    __publicField(this, "updatePermissions", buildTransactionFunction(async (signerAddress, permissions) => {
      return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).updatePermissions.prepare(signerAddress, permissions);
    }));
    __publicField(this, "revokeAccess", buildTransactionFunction(async (signerAddress) => {
      return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).revokeAccess.prepare(signerAddress);
    }));
    __publicField(this, "approveTargetForSigner", buildTransactionFunction(async (signerAddress, target) => {
      return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).approveTargetForSigner.prepare(signerAddress, target);
    }));
    __publicField(this, "disapproveTargetForSigner", buildTransactionFunction(async (signerAddress, target) => {
      return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).disapproveTargetForSigner.prepare(signerAddress, target);
    }));
    __publicField(this, "resetAllPermissions", buildTransactionFunction(async (permissionSnapshot) => {
      return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).resetAllPermissions.prepare(permissionSnapshot);
    }));
    this.contractWrapper = contractWrapper;
    this.accountPermissions = this.detectAccountPermissions();
  }
  detectAccountPermissions() {
    if (detectContractFeature(this.contractWrapper, "AccountPermissions") || detectContractFeature(this.contractWrapper, "AccountPermissionsV1")) {
      return new AccountPermissions(this.contractWrapper);
    }
    return void 0;
  }
  getAddress() {
    return this.contractWrapper.address;
  }
  async isAdmin(signerAddress) {
    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).isAdmin(signerAddress);
  }
  async isSigner(signerAddress) {
    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).isSigner(signerAddress);
  }
  async getAllAdmins() {
    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).getAllAdmins();
  }
  async getAllSigners() {
    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).getAllSigners();
  }
  async getAllAdminsAndSigners() {
    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).getAllAdminsAndSigners();
  }
};
var AccountFactory = class {
  constructor(contractWrapper) {
    __publicField(this, "featureName", FEATURE_ACCOUNT_FACTORY.name);
    __publicField(this, "createAccount", buildTransactionFunction(async (accountAdmin, extraData) => {
      if (await this.isAccountDeployed(accountAdmin, extraData)) {
        throw new Error(`Account already deployed for admin: ${accountAdmin}`);
      }
      let data = utils_exports.toUtf8Bytes("");
      if (extraData) {
        data = extraData;
      }
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "createAccount",
        args: [accountAdmin, data],
        parse: (receipt) => {
          const event = this.contractWrapper.parseLogs("AccountCreated", receipt == null ? void 0 : receipt.logs);
          return {
            address: event[0].args.account,
            receipt
          };
        }
      });
    }));
    this.contractWrapper = contractWrapper;
    this.events = new ContractEvents(this.contractWrapper);
  }
  getAddress() {
    return this.contractWrapper.address;
  }
  async predictAccountAddress(admin, extraData) {
    let data = utils_exports.toUtf8Bytes("");
    if (extraData) {
      data = extraData;
    }
    return this.contractWrapper.read("getAddress", [admin, data]);
  }
  async getAssociatedAccounts(signer) {
    return this.contractWrapper.read("getAccountsOfSigner", [signer]);
  }
  async getAllAccounts() {
    return await this.contractWrapper.read("getAllAccounts", []);
  }
  async isAccountDeployed(admin, extraData) {
    const addr = await this.predictAccountAddress(admin, extraData);
    return isContractDeployed(addr, this.contractWrapper.getProvider());
  }
};

// node_modules/@thirdweb-dev/sdk/dist/deployWithThrowawayDeployer-1d350b63.browser.esm.js
init_shim();
init_lib();
function getFunctionSignature(fnInputs) {
  return "(" + fnInputs.map((i) => {
    return i.type === "tuple" ? getFunctionSignature(i.components) : i.type === "tuple[]" ? getFunctionSignature(i.components) + `[]` : i.type;
  }).join(",") + ")";
}
function generatePluginFunctions(pluginAddress, pluginAbi) {
  const pluginInterface = new utils_exports.Interface(pluginAbi);
  const pluginFunctions = [];
  for (const fnFragment of Object.values(pluginInterface.functions)) {
    const fn = pluginInterface.getFunction(pluginInterface.getSighash(fnFragment));
    if (fn.name.includes("_")) {
      continue;
    }
    pluginFunctions.push({
      functionSelector: pluginInterface.getSighash(fn),
      functionSignature: fn.name + getFunctionSignature(fn.inputs),
      pluginAddress
    });
  }
  return pluginFunctions;
}
function generateExtensionFunctions(extensionAbi) {
  const extensionInterface = new utils_exports.Interface(extensionAbi);
  const extensionFunctions = [];
  for (const fnFragment of Object.values(extensionInterface.functions)) {
    const fn = extensionInterface.getFunction(extensionInterface.getSighash(fnFragment));
    if (fn.name.startsWith("_")) {
      continue;
    }
    extensionFunctions.push({
      functionSelector: extensionInterface.getSighash(fn),
      functionSignature: fn.name + getFunctionSignature(fn.inputs)
    });
  }
  return extensionFunctions;
}
async function getDeploymentInfo(metadataUri, storage, provider, create2Factory, clientId, secretKey) {
  caches.deploymentPresets = {};
  const [create2FactoryAddress, {
    compilerMetadata,
    extendedMetadata
  }] = await Promise.all([create2Factory ? create2Factory : getCreate2FactoryAddress(provider), fetchAndCacheDeployMetadata(metadataUri, storage)]);
  const customParams = {};
  const finalDeploymentInfo = [];
  const defaultExtensions = extendedMetadata == null ? void 0 : extendedMetadata.defaultExtensions;
  if ((extendedMetadata == null ? void 0 : extendedMetadata.routerType) === "plugin" && defaultExtensions) {
    invariant(clientId || secretKey, "Require Client Id / Secret Key");
    const publishedExtensions = await Promise.all(defaultExtensions.map((e) => {
      return fetchPublishedContractFromPolygon(e.publisherAddress, e.extensionName, e.extensionVersion, storage, clientId, secretKey);
    }));
    const pluginMetadata = (await Promise.all(publishedExtensions.map((c) => fetchAndCacheDeployMetadata(c.metadataUri, storage)))).map((fetchedMetadata) => fetchedMetadata.compilerMetadata);
    const pluginDeploymentInfo = await Promise.all(pluginMetadata.map((metadata) => computeDeploymentInfo("plugin", provider, storage, create2FactoryAddress, {
      metadata
    }, clientId, secretKey)));
    const mapInput = [];
    pluginMetadata.forEach((metadata, index) => {
      const input = generatePluginFunctions(pluginDeploymentInfo[index].transaction.predictedAddress, metadata.abi);
      mapInput.push(...input);
    });
    const pluginMapTransaction = await computeDeploymentInfo("plugin", provider, storage, create2FactoryAddress, {
      contractName: "PluginMap",
      constructorParams: {
        _pluginsToAdd: {
          value: mapInput
        }
      }
    }, clientId, secretKey);
    customParams["_pluginMap"] = {
      value: pluginMapTransaction.transaction.predictedAddress
    };
    finalDeploymentInfo.push(...pluginDeploymentInfo, pluginMapTransaction);
  } else if ((extendedMetadata == null ? void 0 : extendedMetadata.routerType) === "dynamic" && defaultExtensions) {
    invariant(clientId || secretKey, "Require Client Id / Secret Key");
    const publishedExtensions = await Promise.all(defaultExtensions.map((e) => {
      return fetchPublishedContractFromPolygon(e.publisherAddress, e.extensionName, e.extensionVersion, storage, clientId, secretKey);
    }));
    const extensionMetadata = (await Promise.all(publishedExtensions.map(async (c) => {
      return fetchAndCacheDeployMetadata(c.metadataUri, storage);
    }))).map((fetchedMetadata) => fetchedMetadata.compilerMetadata);
    const extensionDeploymentInfo = await Promise.all(extensionMetadata.map((metadata) => computeDeploymentInfo("extension", provider, storage, create2FactoryAddress, {
      metadata
    }, clientId, secretKey)));
    const routerInput = [];
    extensionMetadata.forEach((metadata, index) => {
      const extensionFunctions = generateExtensionFunctions(metadata.abi);
      routerInput.push({
        metadata: {
          name: metadata.name,
          metadataURI: "",
          implementation: extensionDeploymentInfo[index].transaction.predictedAddress
        },
        functions: extensionFunctions
      });
    });
    customParams["_extensions"] = {
      value: routerInput
    };
    finalDeploymentInfo.push(...extensionDeploymentInfo);
  }
  const [implementationDeployInfo, factoryInfo] = await Promise.all([
    computeDeploymentInfo("implementation", provider, storage, create2FactoryAddress, {
      metadata: compilerMetadata,
      constructorParams: customParams
    }, clientId, secretKey),
    computeDeploymentInfo("infra", provider, storage, create2FactoryAddress, {
      contractName: "TWCloneFactory"
    }, clientId, secretKey)
  ]);
  finalDeploymentInfo.push(factoryInfo);
  finalDeploymentInfo.push(...Object.values(caches.deploymentPresets));
  finalDeploymentInfo.push(implementationDeployInfo);
  return finalDeploymentInfo;
}
function estimateGasForDeploy(initCode) {
  let gasLimit = utils_exports.arrayify(initCode).map((x) => x === 0 ? 4 : 16).reduce((sum, x) => sum + x) + 200 * initCode.length / 2 + 6 * Math.ceil(initCode.length / 64) + 32e3 + 21e3;
  gasLimit = Math.floor(gasLimit * 64 / 63);
  return gasLimit;
}
function createTransactionBatches(transactions) {
  let upperGasLimit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : GAS_LIMIT_FOR_DEPLOYER;
  transactions = transactions.filter((tx) => {
    return tx.data.length > 0;
  });
  if (transactions.length === 0) {
    return [];
  }
  const transactionBatches = [];
  let sum = 0;
  let batch = [];
  transactions.forEach((tx) => {
    const gas = estimateGasForDeploy(tx.data);
    if (sum + gas > upperGasLimit) {
      if (batch.length === 0) {
        transactionBatches.push([tx]);
      } else {
        transactionBatches.push(batch);
        sum = gas;
        batch = [tx];
      }
    } else {
      sum += gas;
      batch.push(tx);
    }
  });
  if (batch.length > 0) {
    transactionBatches.push(batch);
  }
  return transactionBatches;
}
async function deployContractDeterministic(signer, transaction, options) {
  var _a, _b;
  let gasLimit = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 7e6;
  invariant(signer.provider, "Provider required");
  const contractDeployed = await isContractDeployed(transaction.predictedAddress, signer.provider);
  if (!contractDeployed) {
    console.debug(`deploying contract via create2 factory at: ${transaction.predictedAddress}`);
    const tx = {
      to: transaction.to,
      data: transaction.data
    };
    try {
      await signer.estimateGas(tx);
    } catch (e) {
      console.debug("error estimating gas while deploying prebuilt: ", e);
      tx.gasLimit = BigNumber.from(gasLimit);
    }
    (_a = options == null ? void 0 : options.notifier) == null ? void 0 : _a.call(options, "deploying", "preset");
    await (await signer.sendTransaction(tx)).wait();
    (_b = options == null ? void 0 : options.notifier) == null ? void 0 : _b.call(options, "deployed", "preset");
  }
}
async function deployWithThrowawayDeployer(signer, transactions, options) {
  var _a, _b;
  const transactionBatches = createTransactionBatches(transactions);
  if (transactionBatches.length === 0) {
    return;
  }
  (_a = options == null ? void 0 : options.notifier) == null ? void 0 : _a.call(options, "deploying", "infra");
  const deployTxns = await Promise.all(transactionBatches.map((txBatch) => {
    const deployer = new ContractFactory(DEPLOYER_ABI, DEPLOYER_BYTECODE).connect(signer).deploy(txBatch);
    return deployer;
  }));
  await Promise.all(deployTxns.map((tx) => {
    return tx.deployed();
  }));
  (_b = options == null ? void 0 : options.notifier) == null ? void 0 : _b.call(options, "deployed", "infra");
}

export {
  extractEventsFromAbi,
  ContractPublishedMetadata,
  AdminFlag,
  DEFAULT_PERMISSIONS,
  SignerPermissionsSchema,
  PermissionSnapshotSchema,
  SignerPermissionRequestV1,
  SignerPermissionRequest,
  Account,
  AccountFactory,
  generateExtensionFunctions,
  getDeploymentInfo,
  estimateGasForDeploy,
  createTransactionBatches,
  deployContractDeterministic,
  deployWithThrowawayDeployer
};
//# sourceMappingURL=chunk-FDQU4DVM.js.map
