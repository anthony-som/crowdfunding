'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var useWalletConnect = require('./useWalletConnect-bed2bed2.cjs.dev.js');
var coinbaseWallet = require('./safeChainSlug-4ee42df9.cjs.dev.js');
var reactCore = require('@thirdweb-dev/react-core');
var smartWallet$2 = require('@thirdweb-dev/wallets/evm/wallets/smart-wallet');
var React = require('react');
var bloctoWallet = require('./bloctoWallet-407626c4.cjs.dev.js');
var frameWallet = require('./frameWallet-47bcf554.cjs.dev.js');
var wallets = require('@thirdweb-dev/wallets');
var formElements = require('./formElements-6d38cf23.cjs.dev.js');
var reactIcons = require('@radix-ui/react-icons');
var styled = require('@emotion/styled');
var jsxRuntime = require('react/jsx-runtime');
var magicLink = require('./magicLink-c629443b.cjs.dev.js');
var paperWallet = require('./paperWallet-2e11953c.cjs.dev.js');
var safeWallet = require('./safeWallet-b9e4fac0.cjs.dev.js');
var walletConnectV1 = require('./walletConnectV1-ec7aed2e.cjs.dev.js');
var useSafe = require('./useSafe-74b7167d.cjs.dev.js');
var useMagic = require('./useMagic-b6b178b3.cjs.dev.js');
require('./Tooltip-512594e3.cjs.dev.js');
require('@emotion/react');
require('@radix-ui/react-tooltip');
require('@tanstack/react-query');
require('@radix-ui/react-popover');
require('copy-to-clipboard');
require('@radix-ui/react-tabs');
require('fuse.js');
require('@radix-ui/react-dropdown-menu');
require('@thirdweb-dev/chains');
require('ethers');
require('@thirdweb-dev/sdk');
require('tiny-invariant');
require('@radix-ui/react-dialog');
require('qrcode');
require('detect-browser');
require('@radix-ui/colors');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var styled__default = /*#__PURE__*/_interopDefault(styled);

function useSmartWallet(personalWallet, options) {
  const create = reactCore.useCreateWalletInstance();
  const setStatus = reactCore.useSetConnectionStatus();
  const setWallet = reactCore.useSetConnectedWallet();
  const context = reactCore.useWalletContext();
  const supportedWallets = reactCore.useWallets();
  const predictAddress = React.useCallback(async args => {
    return smartWallet$2.getSmartWalletAddress(context.activeChain, options.factoryAddress, args.personalWalletAddress, args.data);
  }, [context.activeChain, options.factoryAddress]);
  const connect = React.useCallback(async args => {
    if (!supportedWallets.find(w => w.id === personalWallet.id)) {
      console.warn("Please, add your smart wallet to the supportedWallets prop of the ThirdwebProvider to enjoy auto-connecting to the wallet.");
    }
    const {
      smartWallet
    } = await Promise.resolve().then(function () { return smartWallet$1; });
    setStatus("connecting");
    const pw = create(personalWallet);
    const sw = create(smartWallet(personalWallet, options));
    try {
      if (args?.connectPersonalWallet) {
        // if passed in, use custom function to connect personal wallet
        await args.connectPersonalWallet(pw);
      } else {
        // otherwise default to auto-connecting personal wallet with chainId
        await pw.connect({
          chainId: context.activeChain.chainId
        });
      }
      await sw.connect({
        ...args?.connectionArgs,
        personalWallet: pw
      });
      setStatus("connected");
      setWallet(sw);
    } catch (e) {
      console.error("Error connecting to smart wallet", e);
      setStatus("disconnected");
      throw e;
    }
    return sw;
  }, [context.activeChain.chainId, create, options, personalWallet, setStatus, setWallet, supportedWallets]);
  return {
    connect,
    predictAddress
  };
}

function useLocalWalletInfo(localWalletConfig, persist) {
  const [walletData, setWalletData] = React.useState("loading");
  const createWalletInstance = reactCore.useCreateWalletInstance();
  const [localWallet, setLocalWallet] = React.useState(null);
  React.useEffect(() => {
    const wallet = createWalletInstance(localWalletConfig);
    setLocalWallet(wallet);
    if (persist) {
      wallet.getSavedData().then(data => {
        setWalletData(data);
      });
    }
  }, [createWalletInstance, localWalletConfig, persist]);
  return {
    setLocalWallet,
    localWallet,
    walletData,
    meta: localWalletConfig.meta,
    persist: persist
  };
}

const DragNDrop = props => {
  const [error, setError] = React.useState(false);
  const [uploaded, setUploaded] = React.useState();
  const [isDragging, setIsDragging] = React.useState(false);
  const dragIn = e => {
    setError(false);
    setUploaded(undefined);
    setIsDragging(true);
    e.preventDefault();
    e.stopPropagation();
  };
  const dragOut = e => {
    setIsDragging(false);
    e.preventDefault();
    e.stopPropagation();
  };
  const handleFileUpload = file => {
    if (file.type !== props.accept) {
      setError(true);
    } else {
      setUploaded(file);
      props.onUpload(file);
    }
  };
  const drop = e => {
    setIsDragging(false);
    e.preventDefault();
    e.stopPropagation();
    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
      const fileContent = e.dataTransfer.files[0];
      if (fileContent) {
        handleFileUpload(fileContent);
        e.dataTransfer.clearData();
      }
    }
  };
  const message = formElements.isMobile() ? "Click to Upload" : "Drop your file here or click to upload";
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    onDragEnter: dragIn,
    onDragLeave: dragOut,
    onDragOver: e => {
      setIsDragging(true);
      e.preventDefault();
      e.stopPropagation();
    },
    onClick: () => {
      setError(false);
    },
    onDrop: drop,
    style: {
      cursor: "pointer"
    },
    children: /*#__PURE__*/jsxRuntime.jsxs("label", {
      htmlFor: "file-upload",
      children: [/*#__PURE__*/jsxRuntime.jsx("input", {
        id: "file-upload",
        type: "file",
        accept: props.accept,
        multiple: false,
        style: {
          display: "none"
        },
        onChange: e => {
          if (e.target.files && e.target.files[0]) {
            handleFileUpload(e.target.files[0]);
          }
        }
      }), /*#__PURE__*/jsxRuntime.jsx(DropContainer, {
        "data-error": error,
        "data-is-dragging": isDragging,
        children: !uploaded ? /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
          children: [" ", /*#__PURE__*/jsxRuntime.jsx(UploadIconSecondary, {
            width: formElements.iconSize.lg,
            height: formElements.iconSize.lg
          }), /*#__PURE__*/jsxRuntime.jsx(formElements.Spacer, {
            y: "md"
          }), /*#__PURE__*/jsxRuntime.jsxs(formElements.Text, {
            color: "primaryText",
            weight: 600,
            center: true,
            multiline: true,
            children: [" ", message]
          }), /*#__PURE__*/jsxRuntime.jsx(formElements.Spacer, {
            y: "lg"
          }), error ? /*#__PURE__*/jsxRuntime.jsx(formElements.Text, {
            color: "danger",
            size: "sm",
            children: props.locale.wrongFileError
          }) : /*#__PURE__*/jsxRuntime.jsxs(formElements.Text, {
            size: "sm",
            children: [" ", props.extension, " "]
          })]
        }) : /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
          children: [/*#__PURE__*/jsxRuntime.jsxs(formElements.Text, {
            weight: 600,
            color: "primaryText",
            center: true,
            multiline: true,
            children: [uploaded.name, " ", props.locale.uploadedSuccessfully]
          }), /*#__PURE__*/jsxRuntime.jsx(formElements.Spacer, {
            y: "md"
          }), /*#__PURE__*/jsxRuntime.jsx(formElements.Container, {
            color: "success",
            children: /*#__PURE__*/jsxRuntime.jsx(CheckCircleIcon, {
              size: formElements.iconSize.xl
            })
          })]
        })
      })]
    })
  });
};
const UploadIconSecondary = styled__default["default"](reactIcons.UploadIcon)`
  color: ${props => props.theme.colors.secondaryIconColor};
  transition:
    transform 200ms ease,
    color 200ms ease;
`;
const DropContainer = styled__default["default"].div`
  border: 2px solid ${p => p.theme.colors.borderColor};
  border-radius: ${formElements.radius.md};
  padding: ${formElements.spacing.xl} ${formElements.spacing.md};
  display: flex;
  align-items: center;
  flex-direction: column;
  cursor: pointer;
  transition: border-color 200ms ease;

  &:hover,
  &[data-is-dragging="true"] {
    border-color: ${p => p.theme.colors.accentText};
    svg {
      color: ${p => p.theme.colors.accentText};
    }
  }

  &[data-error="true"] {
    border-color: ${p => p.theme.colors.danger};
  }
`;
const CheckCircleIcon = props => /*#__PURE__*/jsxRuntime.jsxs("svg", {
  width: props.size,
  height: props.size,
  viewBox: "0 0 38 38",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  children: [/*#__PURE__*/jsxRuntime.jsx("path", {
    d: "M35.6666 17.4671V19.0004C35.6645 22.5945 34.5008 26.0916 32.3488 28.9701C30.1969 31.8487 27.1721 33.9546 23.7255 34.9736C20.279 35.9926 16.5954 35.8703 13.224 34.6247C9.85272 33.3792 6.97434 31.0773 5.01819 28.0622C3.06203 25.0472 2.1329 21.4805 2.36938 17.8943C2.60586 14.308 3.99526 10.8943 6.33039 8.16221C8.66551 5.43012 11.8212 3.52606 15.3269 2.734C18.8326 1.94194 22.5004 2.30432 25.7833 3.76709",
    stroke: "currentColor",
    strokeWidth: "3.33333",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /*#__PURE__*/jsxRuntime.jsx("path", {
    d: "M35.6667 5.66699L19 22.3503L14 17.3503",
    stroke: "currentColor",
    strokeWidth: "3.33333",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  })]
});

const ImportLocalWallet = props => {
  const locale = formElements.useTWLocale().wallets.localWallet;
  const [jsonString, setJsonString] = React.useState();
  const {
    setLocalWallet
  } = useLocalWalletInfo(props.localWalletConf, props.persist);
  const createWalletInstance = reactCore.useCreateWalletInstance();
  const [password, setPassword] = React.useState("");
  const [isWrongPassword, setIsWrongPassword] = React.useState(false);
  const [showPassword, setShowPassword] = React.useState(false);
  const [importedAddress, setImportedAddress] = React.useState();
  const {
    setConnectedWallet,
    setConnectionStatus
  } = reactCore.useWalletContext();
  const handleImport = async () => {
    const localWallet = createWalletInstance(props.localWalletConf);
    if (!localWallet || !jsonString) {
      throw new Error("Invalid state");
    }
    try {
      await localWallet.import({
        encryptedJson: jsonString,
        password
      });
    } catch (e) {
      console.error(e);
      setIsWrongPassword(true);
      return;
    }
    setConnectionStatus("connecting");
    await localWallet.connect();
    await localWallet.save({
      strategy: "encryptedJson",
      password
    });
    setConnectedWallet(localWallet);
    setLocalWallet(localWallet);
    props.onConnect();
  };
  return /*#__PURE__*/jsxRuntime.jsxs(formElements.Container, {
    animate: "fadein",
    children: [/*#__PURE__*/jsxRuntime.jsx(formElements.Container, {
      p: "lg",
      children: /*#__PURE__*/jsxRuntime.jsx(formElements.ModalHeader, {
        onBack: props.goBack,
        title: locale.importScreen.title
      })
    }), /*#__PURE__*/jsxRuntime.jsx(formElements.Line, {}), /*#__PURE__*/jsxRuntime.jsxs(formElements.Container, {
      p: "lg",
      children: [/*#__PURE__*/jsxRuntime.jsx(formElements.ModalDescription, {
        children: locale.importScreen.description1
      }), /*#__PURE__*/jsxRuntime.jsx(formElements.Spacer, {
        y: "xs"
      }), /*#__PURE__*/jsxRuntime.jsx(formElements.ModalDescription, {
        children: locale.importScreen.description2
      }), /*#__PURE__*/jsxRuntime.jsx(formElements.Spacer, {
        y: "lg"
      }), /*#__PURE__*/jsxRuntime.jsx(DragNDrop, {
        locale: {
          uploadedSuccessfully: locale.importScreen.uploadedSuccessfully,
          wrongFileError: locale.importScreen.uploadJSON
        },
        extension: "JSON",
        accept: "application/json",
        onUpload: file => {
          const reader = new FileReader();
          reader.onload = event => {
            setJsonString(event.target?.result);
            const obj = JSON.parse(event.target?.result);
            setImportedAddress(obj.address);
          };
          reader.readAsText(file, "utf-8");
        }
      }), /*#__PURE__*/jsxRuntime.jsx(formElements.Spacer, {
        y: "lg"
      }), /*#__PURE__*/jsxRuntime.jsxs("form", {
        onSubmit: e => {
          e.preventDefault();
          handleImport();
        },
        children: [jsonString && /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
          children: [/*#__PURE__*/jsxRuntime.jsx("input", {
            type: "text",
            name: "username",
            autoComplete: "off",
            value: importedAddress || "",
            disabled: true,
            style: {
              display: "none"
            }
          }), /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.FormFieldWithIconButton, {
            required: true,
            noSave: true,
            name: "password",
            autocomplete: "off",
            id: "password",
            onChange: value => {
              setPassword(value);
              setIsWrongPassword(false);
            },
            right: {
              onClick: () => setShowPassword(!showPassword),
              icon: showPassword ? /*#__PURE__*/jsxRuntime.jsx(reactIcons.EyeClosedIcon, {}) : /*#__PURE__*/jsxRuntime.jsx(reactIcons.EyeOpenIcon, {})
            },
            label: locale.passwordLabel,
            type: showPassword ? "text" : "password",
            value: password,
            error: isWrongPassword ? "Wrong Password" : ""
          }), /*#__PURE__*/jsxRuntime.jsx(formElements.Spacer, {
            y: "xl"
          })]
        }), /*#__PURE__*/jsxRuntime.jsx(formElements.Container, {
          flex: "row",
          style: {
            justifyContent: "flex-end"
          },
          children: /*#__PURE__*/jsxRuntime.jsx(formElements.Button, {
            variant: "accent",
            type: "submit",
            disabled: !jsonString,
            style: {
              minWidth: "110px",
              opacity: jsonString ? 1 : 0.5
            },
            children: locale.importScreen.import
          })
        })]
      })]
    })]
  });
};

const CreateLocalWallet_Password = props => {
  const locale = formElements.useTWLocale().wallets.localWallet;
  const [password, setPassword] = React.useState("");
  const [confirmPassword, setConfirmPassword] = React.useState("");
  const [showPassword, setShowPassword] = React.useState(false);
  const passwordMismatch = confirmPassword && password !== confirmPassword;
  const [isConnecting, setIsConnecting] = React.useState(false);
  const {
    localWallet
  } = useLocalWalletInfo(props.localWalletConf, props.persist);
  const {
    setConnectedWallet,
    setConnectionStatus
  } = reactCore.useWalletContext();
  const [showImportScreen, setShowImportScreen] = React.useState(false);
  const [generatedAddress, setGeneratedAddress] = React.useState(null);

  // generating wallet before it's required to render a form with hidden address as username for better autofill
  React.useEffect(() => {
    if (!localWallet || showImportScreen || localWallet.ethersWallet) {
      return;
    }
    localWallet.generate().then(_address => {
      setGeneratedAddress(_address);
    });
  }, [localWallet, showImportScreen]);
  if (showImportScreen) {
    return /*#__PURE__*/jsxRuntime.jsx(ImportLocalWallet, {
      localWalletConf: props.localWalletConf,
      onConnect: props.onConnect,
      goBack: () => {
        setShowImportScreen(false);
      },
      persist: props.persist
    });
  }
  const handleConnect = async () => {
    if (passwordMismatch || !localWallet) {
      throw new Error("Invalid state");
    }
    setIsConnecting(true);
    setConnectionStatus("connecting");
    await localWallet.connect();
    await localWallet.save({
      strategy: "encryptedJson",
      password
    });
    setConnectedWallet(localWallet);
    setIsConnecting(false);
    props.onConnect();
  };
  return /*#__PURE__*/jsxRuntime.jsxs(formElements.Container, {
    fullHeight: true,
    flex: "column",
    animate: "fadein",
    children: [/*#__PURE__*/jsxRuntime.jsx(formElements.Container, {
      p: "lg",
      children: /*#__PURE__*/jsxRuntime.jsx(formElements.ModalHeader, {
        onBack: props.renderBackButton ? props.goBack : undefined,
        title: props.localWalletConf.meta.name
      })
    }), /*#__PURE__*/jsxRuntime.jsx(formElements.Line, {}), /*#__PURE__*/jsxRuntime.jsxs(formElements.Container, {
      expand: true,
      p: "lg",
      children: [/*#__PURE__*/jsxRuntime.jsx(formElements.ModalDescription, {
        children: locale.createScreen.instruction
      }), /*#__PURE__*/jsxRuntime.jsx(formElements.Spacer, {
        y: "lg"
      }), /*#__PURE__*/jsxRuntime.jsxs("form", {
        onSubmit: e => {
          e.preventDefault();
          handleConnect();
        },
        children: [/*#__PURE__*/jsxRuntime.jsx("input", {
          type: "text",
          name: "username",
          autoComplete: "off",
          value: generatedAddress || "",
          disabled: true,
          style: {
            display: "none"
          }
        }), /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.FormFieldWithIconButton, {
          name: "password",
          required: true,
          autocomplete: "new-password",
          id: "new-password",
          onChange: value => setPassword(value),
          right: {
            icon: showPassword ? /*#__PURE__*/jsxRuntime.jsx(reactIcons.EyeClosedIcon, {}) : /*#__PURE__*/jsxRuntime.jsx(reactIcons.EyeOpenIcon, {}),
            onClick: () => setShowPassword(!showPassword)
          },
          label: locale.passwordLabel,
          type: showPassword ? "text" : "password",
          value: password,
          dataTest: "new-password"
        }), /*#__PURE__*/jsxRuntime.jsx(formElements.Spacer, {
          y: "lg"
        }), /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.FormFieldWithIconButton, {
          name: "confirm-password",
          required: true,
          autocomplete: "new-password",
          id: "confirm-password",
          onChange: value => setConfirmPassword(value),
          right: {
            icon: showPassword ? /*#__PURE__*/jsxRuntime.jsx(reactIcons.EyeClosedIcon, {}) : /*#__PURE__*/jsxRuntime.jsx(reactIcons.EyeOpenIcon, {}),
            onClick: () => setShowPassword(!showPassword)
          },
          label: locale.confirmPasswordLabel,
          type: showPassword ? "text" : "password",
          value: confirmPassword,
          error: passwordMismatch ? "Passwords don't match" : "",
          dataTest: "confirm-password",
          noErrorShift: true
        }), /*#__PURE__*/jsxRuntime.jsx(formElements.Spacer, {
          y: "md"
        }), /*#__PURE__*/jsxRuntime.jsxs(formElements.Button, {
          variant: "accent",
          type: "submit",
          disabled: isConnecting,
          fullWidth: true,
          style: {
            gap: formElements.spacing.xs,
            display: "flex",
            justifyContent: "center",
            alignItems: "center"
          },
          "data-test": "create-new-wallet-button",
          children: [isConnecting ? locale.createScreen.connecting : locale.createScreen.createNewWallet, isConnecting && /*#__PURE__*/jsxRuntime.jsx(formElements.Spinner, {
            size: "sm",
            color: "accentButtonText"
          })]
        })]
      })]
    }), /*#__PURE__*/jsxRuntime.jsx(formElements.Spacer, {
      y: "sm"
    }), /*#__PURE__*/jsxRuntime.jsx(formElements.Line, {}), /*#__PURE__*/jsxRuntime.jsx(formElements.Container, {
      p: "lg",
      children: /*#__PURE__*/jsxRuntime.jsx(formElements.Button, {
        fullWidth: true,
        variant: "link",
        onClick: () => {
          setShowImportScreen(true);
        },
        style: {
          display: "flex",
          gap: formElements.spacing.sm,
          alignItems: "center"
        },
        children: locale.createScreen.importWallet
      })
    })]
  });
};
const CreateLocalWallet_Guest = props => {
  const {
    localWallet
  } = useLocalWalletInfo(props.localWallet, props.persist);
  const {
    setConnectedWallet,
    setConnectionStatus
  } = reactCore.useWalletContext();
  const {
    onConnect
  } = props;
  const handleConnect = React.useCallback(async () => {
    if (!localWallet) {
      throw new Error("Invalid state");
    }
    await localWallet.generate();
    setConnectionStatus("connecting");
    await coinbaseWallet.wait(1000);
    await localWallet.connect();
    setConnectedWallet(localWallet);
    onConnect();
  }, [localWallet, setConnectedWallet, onConnect, setConnectionStatus]);
  const connecting = React.useRef(false);
  React.useEffect(() => {
    if (connecting.current || !localWallet) {
      return;
    }
    connecting.current = true;
    handleConnect();
  }, [handleConnect, localWallet]);
  return /*#__PURE__*/jsxRuntime.jsx(formElements.Container, {
    flex: "row",
    center: "both",
    fullHeight: true,
    style: {
      minHeight: "300px"
    },
    children: /*#__PURE__*/jsxRuntime.jsx(formElements.Spinner, {
      size: "xl",
      color: "accentText"
    })
  });
};

const OverrideConfirmation = props => {
  const locale = formElements.useTWLocale().wallets.localWallet.warningScreen;
  const isCompact = React.useContext(formElements.ModalConfigCtx).modalSize === "compact";
  return /*#__PURE__*/jsxRuntime.jsxs(formElements.Container, {
    fullHeight: true,
    flex: "column",
    animate: "fadein",
    children: [/*#__PURE__*/jsxRuntime.jsx(formElements.Container, {
      p: "lg",
      children: /*#__PURE__*/jsxRuntime.jsx(formElements.ModalHeader, {
        onBack: props.onBack,
        title: locale.title
      })
    }), /*#__PURE__*/jsxRuntime.jsxs(formElements.Container, {
      p: isCompact ? "lg" : "xxl",
      expand: true,
      center: "y",
      flex: "column",
      children: [/*#__PURE__*/jsxRuntime.jsx(formElements.Container, {
        flex: "row",
        center: "x",
        color: "danger",
        children: /*#__PURE__*/jsxRuntime.jsx(reactIcons.ExclamationTriangleIcon, {
          width: formElements.iconSize.xl,
          height: formElements.iconSize.xl
        })
      }), /*#__PURE__*/jsxRuntime.jsx(formElements.Spacer, {
        y: "xl"
      }), /*#__PURE__*/jsxRuntime.jsx(formElements.Text, {
        multiline: true,
        center: true,
        balance: true,
        children: locale.warning
      }), /*#__PURE__*/jsxRuntime.jsx(formElements.Spacer, {
        y: "lg"
      }), /*#__PURE__*/jsxRuntime.jsx(formElements.Container, {
        flex: "row",
        style: {
          justifyContent: "flex-end"
        },
        children: /*#__PURE__*/jsxRuntime.jsx(formElements.Button, {
          variant: "accent",
          fullWidth: true,
          onClick: props.onBackup,
          children: locale.backupWallet
        })
      })]
    })]
  });
};

/**
 * For No-Credential scenario
 */
const ReconnectLocalWallet = props => {
  const locale = formElements.useTWLocale().wallets.localWallet;
  const [password, setPassword] = React.useState("");
  const [showPassword, setShowPassword] = React.useState(false);
  const [isWrongPassword, setIsWrongPassword] = React.useState(false);
  const {
    setConnectedWallet,
    setConnectionStatus
  } = reactCore.useWalletContext();
  const [isConnecting, setIsConnecting] = React.useState(false);
  const [showCreate, setShowCreate] = React.useState(false);
  const [showBackupConfirmation, setShowBackupConfirmation] = React.useState(false);
  const [showExport, setShowExport] = React.useState(false);
  const {
    localWallet,
    meta,
    walletData
  } = useLocalWalletInfo(props.localWallet, props.persist);
  const savedAddress = walletData ? walletData === "loading" ? "" : walletData.address : "";
  if (showExport) {
    if (!localWallet) {
      throw new Error("Invalid state");
    }
    return /*#__PURE__*/jsxRuntime.jsx(useWalletConnect.ExportLocalWallet, {
      modalSize: props.modalSize,
      localWalletConfig: props.localWallet,
      onBack: () => {
        setShowExport(false);
      },
      onExport: () => {
        setShowExport(false);
        setShowBackupConfirmation(false);
        setShowCreate(true);
      }
    });
  }
  if (showBackupConfirmation) {
    return /*#__PURE__*/jsxRuntime.jsx(OverrideConfirmation, {
      meta: meta,
      onBackup: () => {
        setShowExport(true);
      },
      onBack: () => {
        setShowBackupConfirmation(false);
      }
    });
  }
  if (showCreate) {
    return /*#__PURE__*/jsxRuntime.jsx(CreateLocalWallet_Password, {
      renderBackButton: props.supportedWallets.length > 1,
      localWalletConf: props.localWallet,
      goBack: () => {
        setShowCreate(false);
      },
      onConnect: props.onConnect,
      persist: props.persist
    });
  }
  const handleReconnect = async () => {
    if (!localWallet) {
      throw new Error("Invalid state");
    }
    setIsConnecting(true);
    try {
      await localWallet.load({
        strategy: "encryptedJson",
        password
      });
      setConnectionStatus("connecting");
      await localWallet.connect();
      setConnectedWallet(localWallet);
      props.onConnect();
    } catch (e) {
      setIsWrongPassword(true);
    }
    setIsConnecting(false);
  };
  return /*#__PURE__*/jsxRuntime.jsxs(formElements.Container, {
    animate: "fadein",
    flex: "column",
    fullHeight: true,
    children: [/*#__PURE__*/jsxRuntime.jsx(formElements.Container, {
      p: "lg",
      children: /*#__PURE__*/jsxRuntime.jsx(formElements.ModalHeader, {
        onBack: props.renderBackButton ? props.goBack : undefined,
        title: meta.name
      })
    }), /*#__PURE__*/jsxRuntime.jsx(formElements.Line, {}), /*#__PURE__*/jsxRuntime.jsxs(formElements.Container, {
      p: "lg",
      expand: true,
      children: [/*#__PURE__*/jsxRuntime.jsx(formElements.Text, {
        multiline: true,
        size: "lg",
        color: "primaryText",
        children: locale.reconnectScreen.title
      }), /*#__PURE__*/jsxRuntime.jsx(formElements.Spacer, {
        y: "xl"
      }), /*#__PURE__*/jsxRuntime.jsx(formElements.Label, {
        children: locale.reconnectScreen.savedWallet
      }), /*#__PURE__*/jsxRuntime.jsx(formElements.Spacer, {
        y: "sm"
      }), /*#__PURE__*/jsxRuntime.jsx(formElements.Text, {
        children: savedAddress === "" ? "Loading..." : reactCore.shortenAddress(savedAddress)
      }), /*#__PURE__*/jsxRuntime.jsx(formElements.Spacer, {
        y: "xl"
      }), /*#__PURE__*/jsxRuntime.jsxs("form", {
        onSubmit: e => {
          e.preventDefault();
          handleReconnect();
        },
        children: [/*#__PURE__*/jsxRuntime.jsx("input", {
          type: "text",
          name: "username",
          autoComplete: "off",
          value: savedAddress,
          disabled: true,
          style: {
            display: "none"
          }
        }), /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.FormFieldWithIconButton, {
          required: true,
          name: "current-password",
          autocomplete: "current-password",
          id: "current-password",
          onChange: value => {
            setPassword(value);
            setIsWrongPassword(false);
          },
          right: {
            onClick: () => setShowPassword(!showPassword),
            icon: showPassword ? /*#__PURE__*/jsxRuntime.jsx(reactIcons.EyeClosedIcon, {}) : /*#__PURE__*/jsxRuntime.jsx(reactIcons.EyeOpenIcon, {})
          },
          label: locale.passwordLabel,
          type: showPassword ? "text" : "password",
          value: password,
          error: isWrongPassword ? "Wrong Password" : "",
          dataTest: "current-password",
          placeholder: locale.enterYourPassword
        }), /*#__PURE__*/jsxRuntime.jsx(formElements.Spacer, {
          y: "md"
        }), /*#__PURE__*/jsxRuntime.jsxs(formElements.Button, {
          variant: "accent",
          type: "submit",
          fullWidth: true,
          style: {
            display: "flex",
            gap: formElements.spacing.sm
          },
          children: [locale.reconnectScreen.continue, isConnecting && /*#__PURE__*/jsxRuntime.jsx(formElements.Spinner, {
            size: "sm",
            color: "accentButtonText"
          })]
        })]
      })]
    }), /*#__PURE__*/jsxRuntime.jsx(formElements.Spacer, {
      y: "sm"
    }), /*#__PURE__*/jsxRuntime.jsx(formElements.Line, {}), /*#__PURE__*/jsxRuntime.jsx(formElements.Container, {
      p: "lg",
      children: /*#__PURE__*/jsxRuntime.jsx(formElements.Button, {
        variant: "link",
        fullWidth: true,
        style: {
          textAlign: "center"
        },
        onClick: () => {
          setShowBackupConfirmation(true);
        },
        children: locale.reconnectScreen.createNewWallet
      })
    })]
  });
};

const LocalWalletConnectUI = props => {
  const {
    walletData
  } = useLocalWalletInfo(props.walletConfig, props.persist);
  if (!props.persist) {
    return /*#__PURE__*/jsxRuntime.jsx(CreateLocalWallet_Guest, {
      persist: props.persist,
      localWallet: props.walletConfig,
      goBack: props.goBack,
      onConnect: props.connected
    });
  }
  if (walletData === "loading") {
    return /*#__PURE__*/jsxRuntime.jsx(formElements.Container, {
      flex: "row",
      center: "both",
      style: {
        height: "300px"
      },
      children: /*#__PURE__*/jsxRuntime.jsx(formElements.Spinner, {
        size: "xl",
        color: "accentText"
      })
    });
  }
  if (walletData) {
    return /*#__PURE__*/jsxRuntime.jsx(ReconnectLocalWallet, {
      modalSize: props.modalSize,
      renderBackButton: props.supportedWallets.length > 1,
      supportedWallets: props.supportedWallets,
      onConnect: props.connected,
      goBack: props.goBack,
      localWallet: props.walletConfig,
      persist: props.persist
    });
  }
  return /*#__PURE__*/jsxRuntime.jsx(CreateLocalWallet_Password, {
    goBack: props.goBack,
    localWalletConf: props.walletConfig,
    onConnect: props.connected,
    renderBackButton: props.supportedWallets.length > 1,
    persist: props.persist
  });
};

const desktopIcon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iODAiIHZpZXdCb3g9IjAgMCA4MCA4MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjgwIiByeD0iMTIiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcl8xXzY0KSIvPgo8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfMV82NCkiPgo8cGF0aCBkPSJNNTguNzUgMTkuMTY2N0gyMS4yNUMxOC45NTgzIDE5LjE2NjcgMTcuMDgzMyAyMS4wNDE3IDE3LjA4MzMgMjMuMzMzNFY0OC4zMzM0QzE3LjA4MzMgNTAuNjI1IDE4Ljk1ODMgNTIuNSAyMS4yNSA1Mi41SDM1LjgzMzNMMzEuNjY2NyA1OC43NVY2MC44MzM0SDQ4LjMzMzNWNTguNzVMNDQuMTY2NyA1Mi41SDU4Ljc1QzYxLjA0MTcgNTIuNSA2Mi45MTY3IDUwLjYyNSA2Mi45MTY3IDQ4LjMzMzRWMjMuMzMzNEM2Mi45MTY3IDIxLjA0MTcgNjEuMDQxNyAxOS4xNjY3IDU4Ljc1IDE5LjE2NjdaTTU4Ljc1IDQ0LjE2NjdIMjEuMjVWMjMuMzMzNEg1OC43NVY0NC4xNjY3WiIgZmlsbD0id2hpdGUiLz4KPC9nPgo8ZGVmcz4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDBfbGluZWFyXzFfNjQiIHgxPSI0MCIgeTE9IjAiIHgyPSI0MCIgeTI9IjgwIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIHN0b3AtY29sb3I9IiNDRTExQUIiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjOTAwQkI1Ii8+CjwvbGluZWFyR3JhZGllbnQ+CjxjbGlwUGF0aCBpZD0iY2xpcDBfMV82NCI+CjxyZWN0IHdpZHRoPSI1MCIgaGVpZ2h0PSI1MCIgZmlsbD0id2hpdGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE1IDE1KSIvPgo8L2NsaXBQYXRoPgo8L2RlZnM+Cjwvc3ZnPgo=";
const phoneIcon = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iODAiIHZpZXdCb3g9IjAgMCA4MCA4MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjgwIiByeD0iMTIiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcl80NF8yKSIvPgo8cGF0aCBkPSJNNDguNjE1NCAxNkgzMS4zODQ2QzI4LjQxMjMgMTYgMjYgMTguMzkyNyAyNiAyMS4zNDA5VjU3LjY1OTFDMjYgNjAuNjA3MyAyOC40MTIzIDYzIDMxLjM4NDYgNjNINDguNjE1NEM1MS41ODc3IDYzIDU0IDYwLjYwNzMgNTQgNTcuNjU5MVYyMS4zNDA5QzU0IDE4LjM5MjcgNTEuNTg3NyAxNiA0OC42MTU0IDE2Wk00MCA2MC44NjM2QzM4LjIxMjMgNjAuODYzNiAzNi43NjkyIDU5LjQzMjMgMzYuNzY5MiA1Ny42NTkxQzM2Ljc2OTIgNTUuODg1OSAzOC4yMTIzIDU0LjQ1NDUgNDAgNTQuNDU0NUM0MS43ODc3IDU0LjQ1NDUgNDMuMjMwOCA1NS44ODU5IDQzLjIzMDggNTcuNjU5MUM0My4yMzA4IDU5LjQzMjMgNDEuNzg3NyA2MC44NjM2IDQwIDYwLjg2MzZaTTQ5LjY5MjMgNTIuMzE4MkgzMC4zMDc3VjIyLjQwOTFINDkuNjkyM1Y1Mi4zMTgyWiIgZmlsbD0id2hpdGUiLz4KPGRlZnM+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQwX2xpbmVhcl80NF8yIiB4MT0iNDAiIHkxPSIwIiB4Mj0iNDAiIHkyPSI4MCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBzdG9wLWNvbG9yPSIjQ0UxMUFCIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzkwMEJCNSIvPgo8L2xpbmVhckdyYWRpZW50Pgo8L2RlZnM+Cjwvc3ZnPgo=`;
const localWallet = config => {
  return {
    id: wallets.LocalWallet.id,
    isHeadless: true,
    meta: {
      ...wallets.LocalWallet.meta,
      name: "Guest Wallet",
      iconURL: formElements.isMobile() ? phoneIcon : desktopIcon
    },
    create: options => new wallets.LocalWallet(options),
    connectUI(props) {
      return /*#__PURE__*/jsxRuntime.jsx(LocalWalletConnectUI, {
        ...props,
        persist: config && config.persist !== undefined ? config.persist : true
      });
    }
  };
};

const SmartWalletConnecting = props => {
  const locale = formElements.useTWLocale().wallets.smartWallet;
  const activeWallet = reactCore.useWallet(); // personal wallet

  const connect = reactCore.useConnect();
  const connectedChain = reactCore.useChain();
  const targetChain = reactCore.useWalletContext().activeChain;
  const mismatch = reactCore.useNetworkMismatch();
  const [connectError, setConnectError] = React.useState(false);
  const [switchError, setSwitchError] = React.useState(false);
  const [switchingNetwork, setSwitchingNetwork] = React.useState(false);
  const connectionStatus = reactCore.useConnectionStatus();
  const {
    onConnect
  } = props;
  const connectStarted = React.useRef(false);
  const switchChain = reactCore.useSwitchChain();
  const modalSize = React.useContext(formElements.ModalConfigCtx).modalSize;
  const handleConnect = React.useCallback(async () => {
    if (!activeWallet || !connectedChain || connectStarted.current) {
      return;
    }
    setConnectError(false);
    try {
      connectStarted.current = true;
      await connect(props.smartWallet, {
        personalWallet: activeWallet
      });
      onConnect();
    } catch (e) {
      console.error(e);
      setConnectError(true);
    }
  }, [activeWallet, connectedChain, connect, props.smartWallet, onConnect]);
  React.useEffect(() => {
    if (!mismatch) {
      handleConnect();
    }
  }, [mismatch, handleConnect, activeWallet, connectedChain]);
  if (!connectError && (connectionStatus === "connecting" || !mismatch)) {
    return /*#__PURE__*/jsxRuntime.jsxs(formElements.Container, {
      fullHeight: true,
      flex: "column",
      center: "both",
      style: {
        minHeight: "300px"
      },
      children: [/*#__PURE__*/jsxRuntime.jsx(formElements.Text, {
        color: "primaryText",
        multiline: true,
        center: true,
        children: locale.connecting
      }), /*#__PURE__*/jsxRuntime.jsx(formElements.Spacer, {
        y: "lg"
      }), /*#__PURE__*/jsxRuntime.jsx(formElements.Spinner, {
        color: "accentText",
        size: "xl"
      })]
    });
  }
  if (connectError) {
    return /*#__PURE__*/jsxRuntime.jsx(formElements.Container, {
      fullHeight: true,
      animate: "fadein",
      flex: "column",
      center: "both",
      p: "lg",
      style: {
        minHeight: "300px"
      },
      children: /*#__PURE__*/jsxRuntime.jsx(formElements.Text, {
        color: "danger",
        children: locale.failedToConnect
      })
    });
  }
  return /*#__PURE__*/jsxRuntime.jsxs(formElements.Container, {
    fullHeight: true,
    animate: "fadein",
    flex: "column",
    children: [/*#__PURE__*/jsxRuntime.jsx(formElements.Container, {
      p: "lg",
      children: /*#__PURE__*/jsxRuntime.jsx(formElements.ModalHeader, {
        title: props.personalWallet.meta.name,
        imgSrc: props.personalWallet.meta.iconURL,
        onBack: props.onBack
      })
    }), modalSize === "compact" && /*#__PURE__*/jsxRuntime.jsx(formElements.Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsxRuntime.jsx(formElements.Container, {
      expand: true,
      flex: "column",
      center: "both",
      p: "lg",
      children: /*#__PURE__*/jsxRuntime.jsxs(formElements.Container, {
        p: modalSize === "wide" ? "lg" : undefined,
        children: [/*#__PURE__*/jsxRuntime.jsx(formElements.Container, {
          flex: "row",
          center: "x",
          color: "danger",
          children: /*#__PURE__*/jsxRuntime.jsx(reactIcons.ExclamationTriangleIcon, {
            width: formElements.iconSize.lg,
            height: formElements.iconSize.lg
          })
        }), /*#__PURE__*/jsxRuntime.jsx(formElements.Spacer, {
          y: "md"
        }), /*#__PURE__*/jsxRuntime.jsx(formElements.Text, {
          size: "lg",
          color: "primaryText",
          center: true,
          weight: 500,
          children: locale.wrongNetworkScreen.title
        }), /*#__PURE__*/jsxRuntime.jsx(formElements.Spacer, {
          y: "lg"
        }), /*#__PURE__*/jsxRuntime.jsx(formElements.Text, {
          multiline: true,
          center: true,
          children: locale.wrongNetworkScreen.subtitle
        }), /*#__PURE__*/jsxRuntime.jsx(formElements.Spacer, {
          y: "xl"
        }), /*#__PURE__*/jsxRuntime.jsxs(formElements.Container, {
          flex: "column",
          gap: "md",
          children: [/*#__PURE__*/jsxRuntime.jsxs(formElements.Button, {
            type: "button",
            fullWidth: true,
            variant: "accent",
            style: {
              display: "flex",
              alignItems: "center",
              gap: formElements.spacing.sm
            },
            onClick: async () => {
              if (!activeWallet) {
                throw new Error("No active wallet");
              }
              setConnectError(false);
              setSwitchError(false);
              setSwitchingNetwork(true);
              try {
                await switchChain(targetChain.chainId);
              } catch (e) {
                setSwitchError(true);
              } finally {
                setSwitchingNetwork(false);
              }
            },
            children: [" ", switchingNetwork ? "Switching" : "Switch Network", switchingNetwork && /*#__PURE__*/jsxRuntime.jsx(formElements.Spinner, {
              size: "sm",
              color: "accentButtonText"
            })]
          }), /*#__PURE__*/jsxRuntime.jsxs(formElements.Container, {
            flex: "row",
            gap: "sm",
            center: "both",
            color: "danger",
            style: {
              textAlign: "center",
              fontSize: formElements.fontSize.sm,
              opacity: switchError ? 1 : 0,
              transition: "opacity 200ms ease"
            },
            children: [/*#__PURE__*/jsxRuntime.jsx(reactIcons.ExclamationTriangleIcon, {
              width: formElements.iconSize.sm,
              height: formElements.iconSize.sm
            }), /*#__PURE__*/jsxRuntime.jsx("span", {
              children: locale.wrongNetworkScreen.failedToSwitch
            })]
          })]
        })]
      })
    })]
  });
};

const smartWallet = (wallet, config) => {
  const WalletSelectUI = wallet.selectUI;
  return {
    ...wallet,
    create: options => new wallets.SmartWallet({
      ...options,
      ...config
    }),
    connectUI(props) {
      return /*#__PURE__*/jsxRuntime.jsx(SmartConnectUI, {
        ...props,
        personalWallet: wallet
      });
    },
    selectUI: WalletSelectUI ? props => {
      return /*#__PURE__*/jsxRuntime.jsx(WalletSelectUI, {
        ...props,
        walletConfig: wallet
      });
    } : undefined,
    personalWallets: [wallet]
  };
};
const SmartConnectUI = props => {
  const activeWallet = reactCore.useWallet();
  const {
    walletConfig
  } = props;
  const PersonalWalletConfig = props.personalWallet;
  if (!activeWallet) {
    const _props = {
      ...props,
      walletConfig: PersonalWalletConfig,
      connected: () => {
        // override to no-op
      }
    };
    if (PersonalWalletConfig.connectUI) {
      return /*#__PURE__*/jsxRuntime.jsx(PersonalWalletConfig.connectUI, {
        ..._props
      });
    }
    return /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.HeadlessConnectUI, {
      ..._props
    });
  }
  return /*#__PURE__*/jsxRuntime.jsx(SmartWalletConnecting, {
    onBack: props.goBack,
    onConnect: props.connected,
    smartWallet: walletConfig,
    personalWallet: props.personalWallet
  });
};

var smartWallet$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  smartWallet: smartWallet,
  SmartConnectUI: SmartConnectUI
});

const OKXScan = _ref => {
  let {
    onBack,
    onConnected,
    onGetStarted,
    walletConfig,
    hideBackButton
  } = _ref;
  const locale = formElements.useTWLocale().wallets.okxWallet;
  const createInstance = reactCore.useCreateWalletInstance();
  const [qrCodeUri, setQrCodeUri] = React.useState();
  const {
    setConnectedWallet,
    chainToConnect,
    setConnectionStatus
  } = reactCore.useWalletContext();
  const scanStarted = React.useRef(false);
  React.useEffect(() => {
    if (scanStarted.current) {
      return;
    }
    scanStarted.current = true;
    const wallet = createInstance(walletConfig);
    setConnectionStatus("connecting");
    wallet.connectWithQrCode({
      chainId: chainToConnect?.chainId,
      onQrCodeUri(uri) {
        setQrCodeUri(uri);
      },
      onConnected() {
        setConnectedWallet(wallet);
        onConnected();
      }
    });
  }, [createInstance, setConnectedWallet, chainToConnect, onConnected, walletConfig, setConnectionStatus]);
  return /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.ScanScreen, {
    qrScanInstruction: locale.scanScreen.instruction,
    onBack: onBack,
    onGetStarted: onGetStarted,
    qrCodeUri: qrCodeUri,
    walletName: walletConfig.meta.name,
    walletIconURL: walletConfig.meta.iconURL,
    hideBackButton: hideBackButton,
    getStartedLink: locale.getStartedLink
  });
};

const OKXConnectUI = props => {
  const [screen, setScreen] = React.useState("connecting");
  const locale = formElements.useTWLocale().wallets.okxWallet;
  const {
    walletConfig,
    connected
  } = props;
  const connect = reactCore.useConnect();
  const [errorConnecting, setErrorConnecting] = React.useState(false);
  const hideBackButton = props.supportedWallets.length === 1;
  const connectToExtension = React.useCallback(async () => {
    try {
      connectPrompted.current = true;
      setErrorConnecting(false);
      setScreen("connecting");
      await coinbaseWallet.wait(1000);
      await connect(walletConfig);
      connected();
    } catch (e) {
      setErrorConnecting(true);
      console.error(e);
    }
  }, [connected, connect, walletConfig]);
  const connectPrompted = React.useRef(false);
  React.useEffect(() => {
    if (connectPrompted.current) {
      return;
    }
    const isInstalled = walletConfig.isInstalled ? walletConfig.isInstalled() : false;

    // if loading
    (async () => {
      if (isInstalled) {
        connectToExtension();
      }

      // if wallet is not injected
      else {
        // on mobile, deep link to the okx app
        if (formElements.isMobile()) {
          window.open(`okx://wallet/dapp/details?dappUrl=${window.location.toString()}`);
        } else {
          // on desktop, show the OKX scan qr code
          setScreen("scanning");
        }
      }
    })();
  }, [connectToExtension, walletConfig]);
  if (screen === "connecting") {
    return /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.ConnectingScreen, {
      locale: {
        getStartedLink: locale.getStartedLink,
        instruction: locale.connectionScreen.instruction,
        tryAgain: locale.connectionScreen.retry,
        inProgress: locale.connectionScreen.inProgress,
        failed: locale.connectionScreen.failed
      },
      errorConnecting: errorConnecting,
      onGetStarted: () => {
        setScreen("get-started");
      },
      onRetry: connectToExtension,
      hideBackButton: hideBackButton,
      onBack: props.goBack,
      walletName: walletConfig.meta.name,
      walletIconURL: walletConfig.meta.iconURL
    });
  }
  if (screen === "get-started") {
    return /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.GetStartedScreen, {
      locale: {
        scanToDownload: locale.getStartedScreen.instruction
      },
      walletIconURL: walletConfig.meta.iconURL,
      walletName: walletConfig.meta.name,
      chromeExtensionLink: walletConfig.meta.urls?.chrome,
      googlePlayStoreLink: walletConfig.meta.urls?.android,
      appleStoreLink: walletConfig.meta.urls?.ios,
      onBack: props.goBack
    });
  }
  if (screen === "scanning") {
    return /*#__PURE__*/jsxRuntime.jsx(OKXScan, {
      onBack: props.goBack,
      onConnected: props.connected,
      onGetStarted: () => {
        setScreen("get-started");
      },
      hideBackButton: hideBackButton,
      walletConfig: walletConfig
    });
  }
  return null;
};

const okxWallet = options => {
  return {
    id: wallets.OKXWallet.id,
    recommended: options?.recommended,
    meta: {
      name: "OKX Wallet",
      urls: {
        chrome: "https://chrome.google.com/webstore/detail/okx-wallet/mcohilncbfahbmgdjkbpemcciiolgcge",
        android: "https://play.google.com/store/apps/details?id=com.okinc.okex.gp&pli=1",
        ios: "https://apps.apple.com/us/app/okx-buy-bitcoin-eth-crypto/id1327268470"
      },
      iconURL: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iODAiIHZpZXdCb3g9IjAgMCA4MCA4MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjgwIiByeD0iMTIiIGZpbGw9ImJsYWNrIi8+CjxwYXRoIGQ9Ik00Ni4wMjg0IDMyLjk2NjhIMzMuMDE5OUMzMi40Njc3IDMyLjk2NjggMzIuMDE1IDMzLjQxOTUgMzIuMDE1IDMzLjk3MTZWNDYuOTgwMUMzMi4wMTUgNDcuNTMyMyAzMi40Njc3IDQ3Ljk4NSAzMy4wMTk5IDQ3Ljk4NUg0Ni4wMjg0QzQ2LjU4MDUgNDcuOTg1IDQ3LjAzMzIgNDcuNTMyMyA0Ny4wMzMyIDQ2Ljk4MDFWMzMuOTcxNkM0Ny4wMzMyIDMzLjQxOTUgNDYuNTgwNSAzMi45NjY4IDQ2LjAyODQgMzIuOTY2OFoiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik0zMS4wMTMzIDE4SDE4LjAwNDlDMTcuNDUyNyAxOCAxNyAxOC40NTI3IDE3IDE5LjAwNDlWMzIuMDEzM0MxNyAzMi41NjU1IDE3LjQ1MjcgMzMuMDE4MiAxOC4wMDQ5IDMzLjAxODJIMzEuMDEzM0MzMS41NjU1IDMzLjAxODIgMzIuMDE4MiAzMi41NjU1IDMyLjAxODIgMzIuMDEzM1YxOS4wMDQ5QzMyLjAxNSAxOC40NTI3IDMxLjU2NTUgMTggMzEuMDEzMyAxOFoiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik02MC45OTUyIDE4SDQ3Ljk4NjdDNDcuNDM0NSAxOCA0Ni45ODE4IDE4LjQ1MjcgNDYuOTgxOCAxOS4wMDQ5VjMyLjAxMzNDNDYuOTgxOCAzMi41NjU1IDQ3LjQzNDUgMzMuMDE4MiA0Ny45ODY3IDMzLjAxODJINjAuOTk1MkM2MS41NDczIDMzLjAxODIgNjIgMzIuNTY1NSA2MiAzMi4wMTMzVjE5LjAwNDlDNjIgMTguNDUyNyA2MS41NDczIDE4IDYwLjk5NTIgMThaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNMzEuMDEzMyA0Ny45MzM3SDE4LjAwNDlDMTcuNDUyNyA0Ny45MzM3IDE3IDQ4LjM4NjQgMTcgNDguOTM4NlY2MS45NDcxQzE3IDYyLjQ5OTIgMTcuNDUyNyA2Mi45NTE5IDE4LjAwNDkgNjIuOTUxOUgzMS4wMTMzQzMxLjU2NTUgNjIuOTUxOSAzMi4wMTgyIDYyLjQ5OTIgMzIuMDE4MiA2MS45NDcxVjQ4LjkzODZDMzIuMDE1IDQ4LjM4NjQgMzEuNTY1NSA0Ny45MzM3IDMxLjAxMzMgNDcuOTMzN1oiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik02MC45OTUyIDQ3LjkzMzdINDcuOTg2N0M0Ny40MzQ1IDQ3LjkzMzcgNDYuOTgxOCA0OC4zODY0IDQ2Ljk4MTggNDguOTM4NlY2MS45NDcxQzQ2Ljk4MTggNjIuNDk5MiA0Ny40MzQ1IDYyLjk1MTkgNDcuOTg2NyA2Mi45NTE5SDYwLjk5NTJDNjEuNTQ3MyA2Mi45NTE5IDYyIDYyLjQ5OTIgNjIgNjEuOTQ3MVY0OC45Mzg2QzYyIDQ4LjM4NjQgNjEuNTQ3MyA0Ny45MzM3IDYwLjk5NTIgNDcuOTMzN1oiIGZpbGw9IndoaXRlIi8+Cjwvc3ZnPgo="
    },
    create: walletOptions => {
      const wallet = new wallets.OKXWallet({
        ...walletOptions,
        projectId: options?.projectId,
        qrcode: false
      });
      return wallet;
    },
    connectUI: OKXConnectUI,
    isInstalled() {
      return !!wallets.getInjectedOKXProvider();
    }
  };
};

const CoreWalletScan = _ref => {
  let {
    onBack,
    onConnected,
    onGetStarted,
    walletConfig,
    hideBackButton
  } = _ref;
  const locale = formElements.useTWLocale().wallets.coreWallet;
  const createInstance = reactCore.useCreateWalletInstance();
  const [qrCodeUri, setQrCodeUri] = React.useState();
  const {
    setConnectedWallet,
    chainToConnect,
    setConnectionStatus
  } = reactCore.useWalletContext();
  const scanStarted = React.useRef(false);
  React.useEffect(() => {
    if (scanStarted.current) {
      return;
    }
    scanStarted.current = true;
    const wallet = createInstance(walletConfig);
    setConnectionStatus("connecting");
    wallet.connectWithQrCode({
      chainId: chainToConnect?.chainId,
      onQrCodeUri(uri) {
        setQrCodeUri(uri);
      },
      onConnected() {
        setConnectedWallet(wallet);
        onConnected();
      }
    });
  }, [createInstance, setConnectedWallet, chainToConnect, onConnected, walletConfig, setConnectionStatus]);
  return /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.ScanScreen, {
    qrScanInstruction: locale.scanScreen.instruction,
    onBack: onBack,
    onGetStarted: onGetStarted,
    qrCodeUri: qrCodeUri,
    walletName: walletConfig.meta.name,
    walletIconURL: walletConfig.meta.iconURL,
    hideBackButton: hideBackButton,
    getStartedLink: locale.getStartedLink
  });
};

const coreWalletUris = {
  ios: "core://",
  android: "core://",
  other: "core://"
};

const CoreWalletConnectUI = props => {
  const [screen, setScreen] = React.useState("connecting");
  const locale = formElements.useTWLocale().wallets.coreWallet;
  const connectingLocale = {
    getStartedLink: locale.getStartedLink,
    instruction: locale.connectionScreen.instruction,
    tryAgain: locale.connectionScreen.retry,
    inProgress: locale.connectionScreen.inProgress,
    failed: locale.connectionScreen.failed
  };
  const {
    walletConfig,
    connected
  } = props;
  const connect = reactCore.useConnect();
  const [errorConnecting, setErrorConnecting] = React.useState(false);
  const hideBackButton = props.supportedWallets.length === 1;
  const connectToExtension = React.useCallback(async () => {
    try {
      connectPrompted.current = true;
      setErrorConnecting(false);
      setScreen("connecting");
      await coinbaseWallet.wait(1000);
      await connect(walletConfig);
      connected();
    } catch (e) {
      setErrorConnecting(true);
      console.error(e);
    }
  }, [connected, connect, walletConfig]);
  const connectPrompted = React.useRef(false);
  React.useEffect(() => {
    if (connectPrompted.current) {
      return;
    }
    const isInstalled = walletConfig.isInstalled ? walletConfig.isInstalled() : false;

    // if loading
    (async () => {
      if (isInstalled) {
        connectToExtension();
      }

      // if wallet is not injected
      else {
        // on mobile, open the Core Mobile via wallet connect
        if (formElements.isMobile()) {
          setScreen("open-wc-uri");
        } else {
          // on desktop, show the Core app scan qr code
          setScreen("scanning");
        }
      }
    })();
  }, [connectToExtension, walletConfig]);
  if (screen === "connecting") {
    return /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.ConnectingScreen, {
      locale: {
        getStartedLink: locale.getStartedLink,
        instruction: locale.connectionScreen.instruction,
        tryAgain: locale.connectionScreen.retry,
        inProgress: locale.connectionScreen.inProgress,
        failed: locale.connectionScreen.failed
      },
      errorConnecting: errorConnecting,
      onGetStarted: () => {
        setScreen("get-started");
      },
      onRetry: connectToExtension,
      hideBackButton: hideBackButton,
      onBack: props.goBack,
      walletName: walletConfig.meta.name,
      walletIconURL: walletConfig.meta.iconURL
    });
  }
  if (screen === "open-wc-uri") {
    return /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.WCOpenURI, {
      locale: connectingLocale,
      onRetry: () => {
        // NOOP - TODO make onRetry optional
      },
      errorConnecting: errorConnecting,
      onGetStarted: () => {
        setScreen("get-started");
      },
      hideBackButton: hideBackButton,
      onBack: props.goBack,
      onConnected: connected,
      walletConfig: walletConfig,
      appUriPrefix: coreWalletUris
    });
  }
  if (screen === "get-started") {
    return /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.GetStartedScreen, {
      locale: {
        scanToDownload: locale.getStartedScreen.instruction
      },
      walletIconURL: walletConfig.meta.iconURL,
      walletName: walletConfig.meta.name,
      chromeExtensionLink: walletConfig.meta.urls?.chrome,
      googlePlayStoreLink: walletConfig.meta.urls?.android,
      appleStoreLink: walletConfig.meta.urls?.ios,
      onBack: props.goBack
    });
  }
  if (screen === "scanning") {
    return /*#__PURE__*/jsxRuntime.jsx(CoreWalletScan, {
      onBack: props.goBack,
      onConnected: props.connected,
      onGetStarted: () => {
        setScreen("get-started");
      },
      hideBackButton: hideBackButton,
      walletConfig: walletConfig
    });
  }
  return null;
};

const coreWallet = options => {
  return {
    id: wallets.CoreWallet.id,
    recommended: options?.recommended,
    meta: {
      name: "Core Wallet",
      urls: {
        chrome: "https://chrome.google.com/webstore/detail/core-crypto-wallet-nft-ex/agoakfejjabomempkjlepdflaleeobhb",
        android: "https://play.google.com/store/apps/details?id=com.avaxwallet",
        ios: "https://apps.apple.com/us/app/core-crypto-wallet-nfts/id6443685999"
      },
      iconURL: "data:image/png;base64,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"
    },
    create: walletOptions => {
      const wallet = new wallets.CoreWallet({
        ...walletOptions,
        projectId: options?.projectId,
        qrcode: false
      });
      return wallet;
    },
    connectUI: CoreWalletConnectUI,
    isInstalled() {
      return !!wallets.getInjectedCoreWalletProvider();
    }
  };
};

// wallets that connect via extension and QR scan
function extensionAndQRScanScreens$1(walletName) {
  return {
    connectionScreen: {
      inProgress: "確認待ち",
      failed: "接続に失敗しました",
      instruction: `${walletName}のウォレットで接続リクエストを承認してください`,
      retry: "再試行"
    },
    getStartedScreen: {
      instruction: `QRコードをスキャンして${walletName}アプリをダウンロードしてください`
    },
    scanScreen: {
      instruction: `${walletName}のウォレットアプリでQRコードをスキャンして接続してください`
    },
    getStartedLink: `${walletName}のウォレットを持っていませんか？`
  };
}
function jaDefault() {
  return {
    connectWallet: {
      signIn: "サインイン",
      defaultButtonTitle: "ウォレット接続",
      connecting: "接続中",
      switchNetwork: "ネットワークを切り替える",
      switchingNetwork: "ネットワークの切替中",
      defaultModalTitle: "接続",
      recommended: "推奨",
      installed: "インストール済み",
      continueAsGuest: "ゲストとして続ける",
      connectAWallet: "ウォレットを接続する",
      newToWallets: "ウォレットは初めてですか？",
      getStarted: "始める",
      guest: "ゲスト",
      send: "送る",
      receive: "受け取る",
      currentNetwork: "現在のネットワーク",
      switchAccount: "アカウントを切り替える",
      requestTestnetFunds: "テストネットの資金をリクエストする",
      transactionHistory: "取引履歴",
      backupWallet: "ウォレットのバックアップ",
      guestWalletWarning: "これは一時的なゲストウォレットです。アクセスできなくなることを防ぐため、バックアップをしてください",
      switchTo: "切り替え先",
      // Used in "Switch to <Wallet-Name>"
      connectedToSmartWallet: "スマートウォレットに接続済み",
      confirmInWallet: "ウォレットで確認",
      disconnectWallet: "ウォレットの切断",
      copyAddress: "アドレスをコピー",
      personalWallet: "パーソナルウォレット",
      smartWallet: "スマートウォレット",
      or: "または",
      download: {
        chrome: "Chrome拡張をダウンロード",
        android: "Google Playでダウンロード",
        iOS: "App Storeでダウンロード"
      },
      welcomeScreen: {
        defaultTitle: "分散型世界へのゲートウェイ",
        defaultSubtitle: "始めるためにウォレットを接続してください"
      },
      agreement: {
        prefix: "接続することで、以下に同意したことになります：",
        termsOfService: "利用規約",
        and: "および",
        privacyPolicy: "プライバシーポリシー"
      },
      networkSelector: {
        title: "ネットワークの選択",
        mainnets: "メインネット",
        testnets: "テストネット",
        allNetworks: "すべて",
        addCustomNetwork: "カスタムネットワークを追加",
        inputPlaceholder: "ネットワーク名またはチェーンIDを検索",
        categoryLabel: {
          recentlyUsed: "最近使用したもの",
          popular: "人気",
          others: "全てのネットワーク"
        },
        loading: "読み込み中",
        failedToSwitch: "ネットワークの切替に失敗しました"
      },
      receiveFundsScreen: {
        title: "資金を受け取る",
        instruction: "このウォレットに資金を送るためのウォレットアドレスをコピーしてください"
      },
      sendFundsScreen: {
        title: "資金の送付",
        submitButton: "送信",
        token: "トークン",
        sendTo: "送信先",
        amount: "金額",
        successMessage: "取引成功",
        invalidAddress: "無効なアドレス",
        noTokensFound: "トークンが見つかりません",
        searchToken: "トークンのアドレスを検索するか、貼り付けてください",
        transactionFailed: "取引に失敗しました",
        transactionRejected: "取引が拒否されました",
        insufficientFunds: "資金が不足しています",
        selectTokenTitle: "トークンを選択",
        sending: "送信中"
      },
      signatureScreen: {
        instructionScreen: {
          title: "サインイン",
          instruction: "続行するためにウォレットでメッセージリクエストにサインしてください",
          signInButton: "サインイン"
        },
        signingScreen: {
          title: "サインイン中",
          prompt: "ウォレットで署名リクエストにサインしてください",
          promptForSafe: "ウォレットで署名リクエストにサインし、Safeで取引を承認してください",
          approveTransactionInSafe: "Safeで取引を承認",
          tryAgain: "再試行",
          failedToSignIn: "サインインに失敗しました"
        }
      }
    },
    wallets: {
      walletConnect: {
        scanInstruction: "接続するためにウォレットアプリでこちらをスキャンしてください"
      },
      smartWallet: {
        connecting: "スマートウォレットに接続中",
        failedToConnect: "スマートウォレットに接続できませんでした",
        wrongNetworkScreen: {
          title: "異なるネットワーク",
          subtitle: "ウォレットが必要なネットワークに接続されていません",
          failedToSwitch: "ネットワークの切り替えに失敗しました"
        }
      },
      safeWallet: {
        connectWalletScreen: {
          title: "パーソナルウォレットのリンク",
          subtitle: "Safeを使用するためにパーソナルウォレットを接続してください。",
          learnMoreLink: "もっと詳しく"
        },
        accountDetailsScreen: {
          title: "Safeの詳細を入力してください",
          findSafeAddressIn: "Safeのアドレスは以下で見つけることができます",
          // You can find your safe address in + <dashboardLink>
          dashboardLink: "Safeダッシュボード",
          // <dashboardLink>
          network: "Safeネットワーク",
          selectNetworkPlaceholder: "Safeがデプロイされているネットワーク",
          invalidChainConfig: "アプリにSafeをサポートするチェーンが設定されていないため、Safeを使用できません",
          failedToConnect: "Safeに接続できませんでした。Safeアドレスとネットワークが正しいことを確認してください。",
          failedToSwitch: "ネットワークの切り替えに失敗しました",
          switchNetwork: "ネットワークを切り替える",
          switchingNetwork: "ネットワークを切り替え中",
          connectToSafe: "Safeに接続",
          connecting: "接続中",
          mainnets: "メインネット",
          testnets: "テストネット",
          safeAddress: "Safeアドレス"
        }
      },
      coinbaseWallet: extensionAndQRScanScreens$1("Coinbase"),
      metamaskWallet: extensionAndQRScanScreens$1("MetaMask"),
      okxWallet: extensionAndQRScanScreens$1("OKX"),
      coreWallet: extensionAndQRScanScreens$1("Core"),
      phantomWallet: extensionAndQRScanScreens$1("Phantom"),
      rainbowWallet: extensionAndQRScanScreens$1("Rainbow"),
      trustWallet: extensionAndQRScanScreens$1("Trust"),
      zerionWallet: extensionAndQRScanScreens$1("Zerion"),
      paperWallet: {
        signIn: "サインイン",
        signInWithGoogle: "Googleでサインイン",
        emailPlaceholder: "メールアドレスを入力してください",
        submitEmail: "続ける",
        invalidEmail: "無効なメールアドレス",
        emailRequired: "メールアドレスが必要です",
        googleLoginScreen: {
          title: "サインイン",
          instruction: "ポップアップ内でGoogleアカウントを選択してください",
          failed: "サインインに失敗しました",
          retry: "再試行"
        },
        emailLoginScreen: {
          title: "サインイン",
          enterCodeSendTo: "送信された確認コードを入力してください",
          // Enter the verification code sent to + <email>
          newDeviceDetected: "新しいデバイスが検出されました",
          enterRecoveryCode: "初回サインアップ時にメールで送信されたリカバリーコードを入力してください",
          invalidCode: "無効な確認コード",
          invalidCodeOrRecoveryCode: "無効な確認コードまたはリカバリーコード",
          verify: "確認",
          failedToSendCode: "確認コードの送信に失敗しました",
          sendingCode: "確認コードを送信中",
          resendCode: "確認コードを再送"
        }
      },
      embeddedWallet: {
        signInWithGoogle: "Googleでサインイン",
        signInWithFacebook: "Facebookでサインイン",
        signInWithApple: "Appleでサインイン",
        emailPlaceholder: "メールアドレスを入力してください",
        submitEmail: "続ける",
        emailRequired: "メールアドレスが必要です",
        invalidEmail: "無効なメールアドレス",
        signIn: "サインイン",
        socialLoginScreen: {
          title: "サインイン",
          instruction: "ポップアップウィンドウでアカウントにサインインします",
          // TODO: check if this is correct
          failed: "サインインに失敗しました",
          retry: "再試行"
        },
        emailLoginScreen: {
          title: "サインイン",
          enterCodeSendTo: "送信された確認コードを入力してください",
          newDeviceDetected: "新しいデバイスが検出されました",
          enterRecoveryCode: "初回サインアップ時にメールで送信されたリカバリーコードを入力してください",
          invalidCode: "無効な確認コード",
          invalidCodeOrRecoveryCode: "無効な確認コードまたはリカバリーコード",
          verify: "確認",
          failedToSendCode: "確認コードの送信に失敗しました",
          sendingCode: "確認コードを送信中",
          resendCode: "確認コードを再送"
        },
        createPassword: {
          title: "パスワードを作成",
          instruction: "アカウントのパスワードを設定してください。新しいデバイスから接続する際にこのパスワードが必要となります。",
          saveInstruction: "パスワードは必ず保存してください。",
          inputPlaceholder: "パスワードを入力してください",
          confirmation: "パスワードを保存しました。",
          submitButton: "パスワードを設定",
          failedToSetPassword: "パスワードの設定に失敗しました。"
        },
        enterPassword: {
          title: "パスワードを入力",
          instruction: "アカウントのパスワードを入力してください",
          inputPlaceholder: "パスワードを入力してください",
          submitButton: "確認",
          wrongPassword: "パスワードが違います"
        }
      },
      magicLink: {
        signIn: "サインイン",
        loginWith: "次でログイン：",
        submitEmail: "続ける",
        loginWithEmailOrPhone: "メールアドレスまたは電話番号でログイン",
        emailOrPhoneRequired: "メールアドレスまたは電話番号が必要です",
        loginWithPhone: "電話番号でログイン",
        phoneRequired: "電話番号が必要です",
        invalidEmail: "無効なメールアドレス",
        invalidPhone: "無効な電話番号",
        invalidEmailOrPhone: "無効なメールアドレスまたは電話番号",
        countryCodeMissing: "電話番号は国コードから始める必要があります",
        emailPlaceholder: "メールアドレスを入力してください",
        emailRequired: "メールアドレスが必要です"
      },
      localWallet: {
        passwordLabel: "パスワード",
        confirmPasswordLabel: "パスワードを確認",
        enterYourPassword: "パスワードを入力してください",
        warningScreen: {
          title: "警告",
          warning: "新しいウォレットを作成すると、現在のウォレットは削除されます。新しいウォレットを作成する前に、ウォレットのバックアップをデバイスに保存してください",
          backupWallet: "ウォレットのバックアップ"
        },
        reconnectScreen: {
          title: "保存されたウォレットへの接続",
          savedWallet: "保存されたウォレット",
          continue: "続ける",
          createNewWallet: "新しいウォレットを作成"
        },
        createScreen: {
          instruction: "ウォレットのパスワードを選択してください。このパスワードで、このウォレットにアクセスしたり、同じパスワードでエクスポートすることができます",
          importWallet: "ウォレットをインポート",
          createNewWallet: "新しいウォレットを作成",
          connecting: "接続中"
        },
        exportScreen: {
          description1: "この操作は、ウォレット情報を含む、パスワードで暗号化されたJSONファイルをデバイスにダウンロードします",
          description2: "このJSONファイルを使用して、同じパスワードでMetaMaskにアカウントをインポートすることができます",
          walletAddress: "ウォレットアドレス",
          download: "ダウンロード",
          title: "ウォレットのバックアップ"
        },
        importScreen: {
          title: "ウォレットをインポート",
          description1: "アプリケーションは、ウォレットの代わりに任意の取引を承認なしで認証することができます",
          description2: "信頼できるアプリケーションにのみ接続することをお勧めします",
          import: "インポート",
          uploadJSON: "JSONファイルをアップロードしてください",
          uploadedSuccessfully: "正常にアップロードされました"
        }
      },
      frameWallet: {
        ...extensionAndQRScanScreens$1("Frame"),
        connectionFailedScreen: {
          title: "Frameに接続できませんでした",
          description: "デスクトップアプリがインストールされていて実行中であることを確認してください。以下のリンクからFrameをダウンロードすることができます。Frameが実行されている場合は、このページをリフレッシュしてください。",
          downloadFrame: "Frameをダウンロード",
          supportLink: "まだ接続に問題がありますか？"
        }
      }
    }
  };
}
function ja(overrides) {
  const defaultObj = jaDefault();
  if (!overrides) {
    return defaultObj;
  }
  return formElements.immutableOverride(defaultObj, overrides);
}

// ...

function extensionAndQRScanScreens(walletName) {
  return {
    connectionScreen: {
      inProgress: "Esperando confirmación",
      failed: "Conexión fallida",
      instruction: `Acepta la solicitud de conexión en tu cartera ${walletName}`,
      retry: "Intentar de nuevo"
    },
    getStartedScreen: {
      instruction: `Escanea el código QR para descargar la aplicación ${walletName}`
    },
    scanScreen: {
      instruction: `Escanea el código QR con la aplicación de cartera ${walletName} para conectarte`
    },
    getStartedLink: `¿No tienes la cartera ${walletName}?`
  };
}
function esDefault() {
  return {
    connectWallet: {
      signIn: "Iniciar sesión",
      defaultButtonTitle: "Conectar cartera",
      connecting: "Conectando",
      switchNetwork: "Cambiar red",
      switchingNetwork: "Cambiando de red",
      defaultModalTitle: "Conectar",
      recommended: "Recomendado",
      installed: "Instalado",
      continueAsGuest: "Continuar como invitado",
      connectAWallet: "Conectar una cartera",
      newToWallets: "¿Nuevo en carteras?",
      getStarted: "Comenzar",
      guest: "Invitado",
      send: "Enviar",
      receive: "Recibir",
      currentNetwork: "Red actual",
      switchAccount: "Cambiar cuenta",
      requestTestnetFunds: "Solicitar fondos de Testnet",
      transactionHistory: "Historial de transacciones",
      backupWallet: "Respaldar cartera",
      guestWalletWarning: "Esta es una cartera de invitado temporal. Haz una copia de seguridad si no quieres perder el acceso a ella",
      switchTo: "Cambiar a",
      connectedToSmartWallet: "Conectado a la cartera inteligente",
      confirmInWallet: "Confirmar en cartera",
      disconnectWallet: "Desconectar cartera",
      copyAddress: "Copiar dirección",
      personalWallet: "Cartera personal",
      smartWallet: "Cartera inteligente",
      or: "O",
      download: {
        chrome: "Descargar extensión para Chrome",
        android: "Descargar en Google Play",
        iOS: "Descargar en App Store"
      },
      welcomeScreen: {
        defaultTitle: "Tu puerta de entrada al mundo descentralizado",
        defaultSubtitle: "Conecta una cartera para empezar"
      },
      agreement: {
        prefix: "Al conectar, aceptas los",
        termsOfService: "Términos de servicio",
        and: "y",
        privacyPolicy: "Política de privacidad"
      },
      networkSelector: {
        title: "Seleccionar red",
        mainnets: "Redes principales",
        testnets: "Redes de prueba",
        allNetworks: "Todas",
        addCustomNetwork: "Agregar red personalizada",
        inputPlaceholder: "Buscar red o ID de cadena",
        categoryLabel: {
          recentlyUsed: "Usadas recientemente",
          popular: "Populares",
          others: "Todas las redes"
        },
        loading: "Cargando",
        failedToSwitch: "Error al cambiar de red"
      },
      receiveFundsScreen: {
        title: "Recibir fondos",
        instruction: "Copia la dirección de la cartera para enviar fondos a esta cartera"
      },
      sendFundsScreen: {
        title: "Enviar fondos",
        submitButton: "Enviar",
        token: "Token",
        sendTo: "Enviar a",
        amount: "Cantidad",
        successMessage: "Transacción exitosa",
        invalidAddress: "Dirección inválida",
        noTokensFound: "No se encontraron tokens",
        searchToken: "Buscar o pegar la dirección del token",
        transactionFailed: "Transacción fallida",
        transactionRejected: "Transacción rechazada",
        insufficientFunds: "Fondos insuficientes",
        selectTokenTitle: "Seleccione un Token",
        sending: "Enviando"
      },
      signatureScreen: {
        instructionScreen: {
          title: "Iniciar sesión",
          instruction: "Por favor, firma la solicitud de mensaje en tu cartera para continuar",
          signInButton: "Iniciar sesión"
        },
        signingScreen: {
          title: "Iniciando sesión",
          prompt: "Firma la solicitud de firma en tu cartera",
          promptForSafe: "Firma la solicitud de firma en tu cartera y aprueba la transacción en Safe",
          approveTransactionInSafe: "Aprobar transacción en Safe",
          tryAgain: "Intentar de nuevo",
          failedToSignIn: "Error al iniciar sesión"
        }
      }
    },
    wallets: {
      walletConnect: {
        scanInstruction: "Escanea esto con tu aplicación de cartera para conectar"
      },
      smartWallet: {
        connecting: "Conectando a Smart Wallet",
        failedToConnect: "Error al conectar con Smart Wallet",
        wrongNetworkScreen: {
          title: "Red incorrecta",
          subtitle: "Tu cartera no está conectada a la red requerida",
          failedToSwitch: "Error al cambiar de red"
        }
      },
      safeWallet: {
        connectWalletScreen: {
          title: "Vincular cartera personal",
          subtitle: "Conecta tu cartera personal para usar Safe",
          learnMoreLink: "Saber más"
        },
        accountDetailsScreen: {
          title: "Introduce los detalles de tu safe",
          findSafeAddressIn: "Puedes encontrar tu dirección de safe en",
          dashboardLink: "Tablero de Safe",
          network: "Red de Safe",
          selectNetworkPlaceholder: "Red a la que se ha desplegado tu safe",
          invalidChainConfig: "No se puede usar Safe: No hay cadenas compatibles con Safe configuradas en la aplicación",
          failedToConnect: "No se pudo conectar con Safe. Asegúrate de que la dirección y red del safe son correctas",
          failedToSwitch: "Error al cambiar de red",
          switchNetwork: "Cambiar de red",
          switchingNetwork: "Cambiando de red",
          connectToSafe: "Conectar a Safe",
          connecting: "Conectando",
          mainnets: "Redes principales",
          testnets: "Redes de prueba",
          safeAddress: "Dirección de Safe"
        }
      },
      coinbaseWallet: extensionAndQRScanScreens("Coinbase"),
      metamaskWallet: extensionAndQRScanScreens("MetaMask"),
      okxWallet: extensionAndQRScanScreens("OKX"),
      coreWallet: extensionAndQRScanScreens("Core"),
      phantomWallet: extensionAndQRScanScreens("Phantom"),
      rainbowWallet: extensionAndQRScanScreens("Rainbow"),
      trustWallet: extensionAndQRScanScreens("Trust"),
      zerionWallet: extensionAndQRScanScreens("Zerion"),
      paperWallet: {
        signIn: "Iniciar sesión",
        signInWithGoogle: "Iniciar sesión con Google",
        emailPlaceholder: "Ingresa tu dirección de correo electrónico",
        submitEmail: "Continuar",
        invalidEmail: "Dirección de correo electrónico inválida",
        emailRequired: "Se requiere dirección de correo electrónico",
        googleLoginScreen: {
          title: "Iniciar sesión",
          instruction: "Selecciona tu cuenta de Google en la ventana emergente",
          failed: "Error al iniciar sesión",
          retry: "Reintentar"
        },
        emailLoginScreen: {
          title: "Iniciar sesión",
          enterCodeSendTo: "Ingresa el código de verificación enviado a",
          newDeviceDetected: "Nuevo dispositivo detectado",
          enterRecoveryCode: "Ingresa el código de recuperación que se te envió por correo electrónico cuando te registraste por primera vez",
          invalidCode: "Código de verificación inválido",
          invalidCodeOrRecoveryCode: "Código de verificación o de recuperación inválido",
          verify: "Verificar",
          failedToSendCode: "Error al enviar el código de verificación",
          sendingCode: "Enviando código de verificación",
          resendCode: "Reenviar código de verificación"
        }
      },
      embeddedWallet: {
        signInWithGoogle: "Iniciar sesión con Google",
        signInWithFacebook: "Iniciar sesión con Facebook",
        signInWithApple: "Iniciar sesión con Apple",
        emailPlaceholder: "Ingresa tu dirección de correo electrónico",
        submitEmail: "Continuar",
        signIn: "Iniciar sesión",
        emailRequired: "Se requiere dirección de correo electrónico",
        invalidEmail: "Dirección de correo electrónico inválida",
        socialLoginScreen: {
          title: "Iniciar sesión",
          instruction: "Inicie sesión en su cuenta en la ventana abierta",
          failed: "Error al iniciar sesión",
          retry: "Reintentar"
        },
        emailLoginScreen: {
          title: "Iniciar sesión",
          enterCodeSendTo: "Ingresa el código de verificación enviado a",
          newDeviceDetected: "Nuevo dispositivo detectado",
          enterRecoveryCode: "Ingresa el código de recuperación que se te envió por correo electrónico cuando te registraste por primera vez",
          invalidCode: "Código de verificación inválido",
          invalidCodeOrRecoveryCode: "Código de verificación o de recuperación inválido",
          verify: "Verificar",
          failedToSendCode: "Error al enviar el código de verificación",
          sendingCode: "Enviando código de verificación",
          resendCode: "Reenviar código de verificación"
        },
        createPassword: {
          title: "Crear contraseña",
          instruction: "Establezca una contraseña para su cuenta. Necesitará esta contraseña cuando se conecte desde un nuevo dispositivo.",
          saveInstruction: "Asegúrese de guardarla",
          inputPlaceholder: "Ingrese su contraseña",
          confirmation: "He guardado mi contraseña",
          submitButton: "Establecer contraseña",
          failedToSetPassword: "Error al establecer la contraseña"
        },
        enterPassword: {
          title: "Ingrese la contraseña",
          instruction: "Ingrese la contraseña de su cuenta",
          inputPlaceholder: "Ingrese su contraseña",
          submitButton: "Verificar",
          wrongPassword: "Contraseña incorrecta"
        }
      },
      magicLink: {
        signIn: "Iniciar sesión",
        loginWith: "Iniciar sesión con",
        submitEmail: "Continuar",
        loginWithEmailOrPhone: "Iniciar sesión con correo electrónico o número de teléfono",
        emailOrPhoneRequired: "Se requiere correo electrónico o número de teléfono",
        loginWithPhone: "Iniciar sesión con número de teléfono",
        phoneRequired: "Se requiere número de teléfono",
        invalidEmail: "Dirección de correo electrónico inválida",
        invalidPhone: "Número de teléfono inválido",
        invalidEmailOrPhone: "Dirección de correo electrónico o número de teléfono inválido",
        countryCodeMissing: "El número de teléfono debe comenzar con un código de país",
        emailPlaceholder: "Ingresa tu dirección de correo electrónico",
        emailRequired: "Se requiere dirección de correo electrónico"
      },
      localWallet: {
        passwordLabel: "Contraseña",
        confirmPasswordLabel: "Confirmar contraseña",
        enterYourPassword: "Ingresa tu contraseña",
        warningScreen: {
          title: "Advertencia",
          warning: "Tu cartera actual se eliminará si creas una nueva. Haz una copia de seguridad de la cartera en tu dispositivo antes de crear una nueva",
          backupWallet: "Copia de seguridad de la cartera"
        },
        reconnectScreen: {
          title: "Conectar a cartera guardada",
          savedWallet: "Cartera guardada",
          continue: "Continuar",
          createNewWallet: "Crear una nueva cartera"
        },
        createScreen: {
          instruction: "Elige una contraseña para tu cartera. Podrás acceder y exportar esta cartera con la misma contraseña",
          importWallet: "Importar cartera",
          createNewWallet: "Crear nueva cartera",
          connecting: "Conectando"
        },
        exportScreen: {
          description1: "Esto descargará un archivo JSON que contiene la información de la cartera en tu dispositivo cifrado con la contraseña",
          description2: "Puedes usar este archivo JSON para importar la cuenta en MetaMask usando la misma contraseña",
          walletAddress: "Dirección de la cartera",
          download: "Descargar",
          title: "Respaldar cartera"
        },
        importScreen: {
          title: "Importar cartera",
          description1: "La aplicación puede autorizar cualquier transacción en nombre de la cartera sin ninguna aprobación",
          description2: "Recomendamos conectar solo con aplicaciones de confianza",
          import: "Importar",
          uploadJSON: "Por favor sube un archivo JSON",
          uploadedSuccessfully: "Subido con éxito"
        }
      },
      frameWallet: {
        ...extensionAndQRScanScreens("Frame"),
        connectionFailedScreen: {
          title: "Fallo al conectar con Frame",
          description: "Asegúrate de que la aplicación de escritorio esté instalada y en funcionamiento. Puedes descargar Frame desde el enlace de abajo. Asegúrate de actualizar esta página una vez que Frame esté funcionando.",
          downloadFrame: "Descargar Frame",
          supportLink: "¿Sigues teniendo problemas para conectar?"
        }
      }
    }
  };
}
function es(overrides) {
  const defaultObj = esDefault();
  if (!overrides) {
    return defaultObj;
  }
  return formElements.immutableOverride(defaultObj, overrides);
}

exports.ConnectModalInline = useWalletConnect.ConnectModalInline;
exports.ConnectWallet = useWalletConnect.ConnectWallet;
exports.MediaRenderer = useWalletConnect.MediaRenderer;
exports.NetworkSelector = useWalletConnect.NetworkSelector;
exports.ThirdwebNftMedia = useWalletConnect.ThirdwebNftMedia;
exports.ThirdwebProvider = useWalletConnect.ThirdwebProvider;
exports.Web3Button = useWalletConnect.Web3Button;
exports.defaultTokens = useWalletConnect.defaultTokens;
exports.embeddedWallet = useWalletConnect.embeddedWallet;
exports.useBloctoWallet = useWalletConnect.useBloctoWallet;
exports.useCoinbaseWallet = useWalletConnect.useCoinbaseWallet;
exports.useEmbeddedWallet = useWalletConnect.useEmbeddedWallet;
exports.useEmbeddedWalletSendVerificationEmail = useWalletConnect.useEmbeddedWalletSendVerificationEmail;
exports.useFrameWallet = useWalletConnect.useFrameWallet;
exports.useInstalledWallets = useWalletConnect.useInstalledWallets;
exports.useMetamask = useWalletConnect.useMetamask;
exports.usePaperWallet = useWalletConnect.usePaperWallet;
exports.usePaperWalletUserEmail = useWalletConnect.usePaperWalletUserEmail;
exports.useRainbowWallet = useWalletConnect.useRainbowWallet;
exports.useResolvedMediaType = useWalletConnect.useResolvedMediaType;
exports.useTrustWallet = useWalletConnect.useTrustWallet;
exports.useWalletConnect = useWalletConnect.useWalletConnect;
exports.useWalletConnectV1 = useWalletConnect.useWalletConnectV1;
exports.coinbaseWallet = coinbaseWallet.coinbaseWallet;
exports.defaultWallets = coinbaseWallet.defaultWallets;
exports.metamaskWallet = coinbaseWallet.metamaskWallet;
exports.phantomWallet = coinbaseWallet.phantomWallet;
exports.rainbowWallet = coinbaseWallet.rainbowWallet;
exports.trustWallet = coinbaseWallet.trustWallet;
exports.walletConnect = coinbaseWallet.walletConnect;
exports.zerionWallet = coinbaseWallet.zerionWallet;
exports.bloctoWallet = bloctoWallet.bloctoWallet;
exports.frameWallet = frameWallet.frameWallet;
Object.defineProperty(exports, 'BloctoWallet', {
  enumerable: true,
  get: function () { return wallets.BloctoWallet; }
});
Object.defineProperty(exports, 'CoinbaseWallet', {
  enumerable: true,
  get: function () { return wallets.CoinbaseWallet; }
});
Object.defineProperty(exports, 'CoreWallet', {
  enumerable: true,
  get: function () { return wallets.CoreWallet; }
});
Object.defineProperty(exports, 'EmbeddedWallet', {
  enumerable: true,
  get: function () { return wallets.EmbeddedWallet; }
});
Object.defineProperty(exports, 'FrameWallet', {
  enumerable: true,
  get: function () { return wallets.FrameWallet; }
});
Object.defineProperty(exports, 'InjectedWallet', {
  enumerable: true,
  get: function () { return wallets.InjectedWallet; }
});
Object.defineProperty(exports, 'LocalWallet', {
  enumerable: true,
  get: function () { return wallets.LocalWallet; }
});
Object.defineProperty(exports, 'MagicLink', {
  enumerable: true,
  get: function () { return wallets.MagicLink; }
});
Object.defineProperty(exports, 'MetaMaskWallet', {
  enumerable: true,
  get: function () { return wallets.MetaMaskWallet; }
});
Object.defineProperty(exports, 'OKXWallet', {
  enumerable: true,
  get: function () { return wallets.OKXWallet; }
});
Object.defineProperty(exports, 'PaperWallet', {
  enumerable: true,
  get: function () { return wallets.PaperWallet; }
});
Object.defineProperty(exports, 'PhantomWallet', {
  enumerable: true,
  get: function () { return wallets.PhantomWallet; }
});
Object.defineProperty(exports, 'RainbowWallet', {
  enumerable: true,
  get: function () { return wallets.RainbowWallet; }
});
Object.defineProperty(exports, 'SafeWallet', {
  enumerable: true,
  get: function () { return wallets.SafeWallet; }
});
Object.defineProperty(exports, 'SignerWallet', {
  enumerable: true,
  get: function () { return wallets.SignerWallet; }
});
Object.defineProperty(exports, 'SmartWallet', {
  enumerable: true,
  get: function () { return wallets.SmartWallet; }
});
Object.defineProperty(exports, 'TrustWallet', {
  enumerable: true,
  get: function () { return wallets.TrustWallet; }
});
Object.defineProperty(exports, 'WalletConnect', {
  enumerable: true,
  get: function () { return wallets.WalletConnect; }
});
Object.defineProperty(exports, 'ZerionWallet', {
  enumerable: true,
  get: function () { return wallets.ZerionWallet; }
});
Object.defineProperty(exports, 'setWalletAnalyticsEnabled', {
  enumerable: true,
  get: function () { return wallets.setWalletAnalyticsEnabled; }
});
exports.darkTheme = formElements.darkTheme;
exports.en = formElements.en;
exports.lightTheme = formElements.lightTheme;
exports.useIsWalletModalOpen = formElements.useIsWalletModalOpen;
exports.useSetIsWalletModalOpen = formElements.useSetIsWalletModalOpen;
exports.magicLink = magicLink.magicLink;
exports.paperWallet = paperWallet.paperWallet;
exports.safeWallet = safeWallet.safeWallet;
exports.walletConnectV1 = walletConnectV1.walletConnectV1;
exports.useSafe = useSafe.useSafe;
exports.useMagic = useMagic.useMagic;
exports.coreWallet = coreWallet;
exports.es = es;
exports.ja = ja;
exports.localWallet = localWallet;
exports.okxWallet = okxWallet;
exports.smartWallet = smartWallet;
exports.useSmartWallet = useSmartWallet;
Object.keys(reactCore).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () { return reactCore[k]; }
  });
});
